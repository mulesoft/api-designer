(function (f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f();
  } else if (typeof define === 'function' && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }
    (g.jsTraverse || (g.jsTraverse = {})).traverse = f();
  }
}(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == 'function' && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error('Cannot find module \'' + o + '\'');
          throw f.code = 'MODULE_NOT_FOUND', f;
        }
        var l = n[o] = { exports: {} };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == 'function' && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  }({
    1: [
      function (require, module, exports) {
        var traverse = module.exports = function (obj) {
            return new Traverse(obj);
          };
        function Traverse(obj) {
          this.value = obj;
        }
        Traverse.prototype.get = function (ps) {
          var node = this.value;
          for (var i = 0; i < ps.length; i++) {
            var key = ps[i];
            if (!node || !hasOwnProperty.call(node, key)) {
              node = undefined;
              break;
            }
            node = node[key];
          }
          return node;
        };
        Traverse.prototype.has = function (ps) {
          var node = this.value;
          for (var i = 0; i < ps.length; i++) {
            var key = ps[i];
            if (!node || !hasOwnProperty.call(node, key)) {
              return false;
            }
            node = node[key];
          }
          return true;
        };
        Traverse.prototype.set = function (ps, value) {
          var node = this.value;
          for (var i = 0; i < ps.length - 1; i++) {
            var key = ps[i];
            if (!hasOwnProperty.call(node, key))
              node[key] = {};
            node = node[key];
          }
          node[ps[i]] = value;
          return value;
        };
        Traverse.prototype.map = function (cb) {
          return walk(this.value, cb, true);
        };
        Traverse.prototype.forEach = function (cb) {
          this.value = walk(this.value, cb, false);
          return this.value;
        };
        Traverse.prototype.reduce = function (cb, init) {
          var skip = arguments.length === 1;
          var acc = skip ? this.value : init;
          this.forEach(function (x) {
            if (!this.isRoot || !skip) {
              acc = cb.call(this, acc, x);
            }
          });
          return acc;
        };
        Traverse.prototype.paths = function () {
          var acc = [];
          this.forEach(function (x) {
            acc.push(this.path);
          });
          return acc;
        };
        Traverse.prototype.nodes = function () {
          var acc = [];
          this.forEach(function (x) {
            acc.push(this.node);
          });
          return acc;
        };
        Traverse.prototype.clone = function () {
          var parents = [], nodes = [];
          return function clone(src) {
            for (var i = 0; i < parents.length; i++) {
              if (parents[i] === src) {
                return nodes[i];
              }
            }
            if (typeof src === 'object' && src !== null) {
              var dst = copy(src);
              parents.push(src);
              nodes.push(dst);
              forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
              });
              parents.pop();
              nodes.pop();
              return dst;
            } else {
              return src;
            }
          }(this.value);
        };
        function walk(root, cb, immutable) {
          var path = [];
          var parents = [];
          var alive = true;
          return function walker(node_) {
            var node = immutable ? copy(node_) : node_;
            var modifiers = {};
            var keepGoing = true;
            var state = {
                node: node,
                node_: node_,
                path: [].concat(path),
                parent: parents[parents.length - 1],
                parents: parents,
                key: path.slice(-1)[0],
                isRoot: path.length === 0,
                level: path.length,
                circular: null,
                update: function (x, stopHere) {
                  if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                  }
                  state.node = x;
                  if (stopHere)
                    keepGoing = false;
                },
                'delete': function (stopHere) {
                  delete state.parent.node[state.key];
                  if (stopHere)
                    keepGoing = false;
                },
                remove: function (stopHere) {
                  if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                  } else {
                    delete state.parent.node[state.key];
                  }
                  if (stopHere)
                    keepGoing = false;
                },
                keys: null,
                before: function (f) {
                  modifiers.before = f;
                },
                after: function (f) {
                  modifiers.after = f;
                },
                pre: function (f) {
                  modifiers.pre = f;
                },
                post: function (f) {
                  modifiers.post = f;
                },
                stop: function () {
                  alive = false;
                },
                block: function () {
                  keepGoing = false;
                }
              };
            if (!alive)
              return state;
            function updateState() {
              if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                  state.keys = objectKeys(state.node);
                }
                state.isLeaf = state.keys.length == 0;
                for (var i = 0; i < parents.length; i++) {
                  if (parents[i].node_ === node_) {
                    state.circular = parents[i];
                    break;
                  }
                }
              } else {
                state.isLeaf = true;
                state.keys = null;
              }
              state.notLeaf = !state.isLeaf;
              state.notRoot = !state.isRoot;
            }
            updateState();
            // use return values to update if defined
            var ret = cb.call(state, state.node);
            if (ret !== undefined && state.update)
              state.update(ret);
            if (modifiers.before)
              modifiers.before.call(state, state.node);
            if (!keepGoing)
              return state;
            if (typeof state.node == 'object' && state.node !== null && !state.circular) {
              parents.push(state);
              updateState();
              forEach(state.keys, function (key, i) {
                path.push(key);
                if (modifiers.pre)
                  modifiers.pre.call(state, state.node[key], key);
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                  state.node[key] = child.node;
                }
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                if (modifiers.post)
                  modifiers.post.call(state, child);
                path.pop();
              });
              parents.pop();
            }
            if (modifiers.after)
              modifiers.after.call(state, state.node);
            return state;
          }(root).node;
        }
        function copy(src) {
          if (typeof src === 'object' && src !== null) {
            var dst;
            if (isArray(src)) {
              dst = [];
            } else if (isDate(src)) {
              dst = new Date(src.getTime ? src.getTime() : src);
            } else if (isRegExp(src)) {
              dst = new RegExp(src);
            } else if (isError(src)) {
              dst = { message: src.message };
            } else if (isBoolean(src)) {
              dst = new Boolean(src);
            } else if (isNumber(src)) {
              dst = new Number(src);
            } else if (isString(src)) {
              dst = new String(src);
            } else if (Object.create && Object.getPrototypeOf) {
              dst = Object.create(Object.getPrototypeOf(src));
            } else if (src.constructor === Object) {
              dst = {};
            } else {
              var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};
              ;
              var T = function () {
              };
              T.prototype = proto;
              dst = new T();
            }
            forEach(objectKeys(src), function (key) {
              dst[key] = src[key];
            });
            return dst;
          } else
            return src;
        }
        var objectKeys = Object.keys || function keys(obj) {
            var res = [];
            for (var key in obj)
              res.push(key);
            return res;
          };
        function toS(obj) {
          return Object.prototype.toString.call(obj);
        }
        function isDate(obj) {
          return toS(obj) === '[object Date]';
        }
        function isRegExp(obj) {
          return toS(obj) === '[object RegExp]';
        }
        function isError(obj) {
          return toS(obj) === '[object Error]';
        }
        function isBoolean(obj) {
          return toS(obj) === '[object Boolean]';
        }
        function isNumber(obj) {
          return toS(obj) === '[object Number]';
        }
        function isString(obj) {
          return toS(obj) === '[object String]';
        }
        var isArray = Array.isArray || function isArray(xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
          };
        var forEach = function (xs, fn) {
          if (xs.forEach)
            return xs.forEach(fn);
          else
            for (var i = 0; i < xs.length; i++) {
              fn(xs[i], i, xs);
            }
        };
        forEach(objectKeys(Traverse.prototype), function (key) {
          traverse[key] = function (obj) {
            var args = [].slice.call(arguments, 1);
            var t = new Traverse(obj);
            return t[key].apply(t, args);
          };
        });
        var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
            return key in obj;
          };
      },
      {}
    ]
  }, {}, [1])(1);
}));
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == 'function' && require;
        if (!u && a)
          return a(o, !0);
        if (i)
          return i(o, !0);
        var f = new Error('Cannot find module \'' + o + '\'');
        throw f.code = 'MODULE_NOT_FOUND', f;
      }
      var l = n[o] = { exports: {} };
      t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == 'function' && require;
  for (var o = 0; o < r.length; o++)
    s(r[o]);
  return s;
}({
  1: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, legacy_scorer, pluckCandidates, scorer, sortCandidates;
        scorer = require('./scorer');
        legacy_scorer = require('./legacy');
        pluckCandidates = function (a) {
          return a.candidate;
        };
        sortCandidates = function (a, b) {
          return b.score - a.score;
        };
        PathSeparator = require('path').sep;
        module.exports = function (candidates, query, _arg) {
          var allowErrors, bAllowErrors, bKey, candidate, coreQuery, key, legacy, maxInners, maxResults, prepQuery, queryHasSlashes, score, scoredCandidates, spotLeft, string, _i, _j, _len, _len1, _ref;
          _ref = _arg != null ? _arg : {}, key = _ref.key, maxResults = _ref.maxResults, maxInners = _ref.maxInners, allowErrors = _ref.allowErrors, legacy = _ref.legacy;
          scoredCandidates = [];
          spotLeft = maxInners != null && maxInners > 0 ? maxInners : candidates.length;
          bAllowErrors = !!allowErrors;
          bKey = key != null;
          prepQuery = scorer.prepQuery(query);
          if (!legacy) {
            for (_i = 0, _len = candidates.length; _i < _len; _i++) {
              candidate = candidates[_i];
              string = bKey ? candidate[key] : candidate;
              if (!string) {
                continue;
              }
              score = scorer.score(string, query, prepQuery, bAllowErrors);
              if (score > 0) {
                scoredCandidates.push({
                  candidate: candidate,
                  score: score
                });
                if (!--spotLeft) {
                  break;
                }
              }
            }
          } else {
            queryHasSlashes = prepQuery.depth > 0;
            coreQuery = prepQuery.core;
            for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
              candidate = candidates[_j];
              string = key != null ? candidate[key] : candidate;
              if (!string) {
                continue;
              }
              score = legacy_scorer.score(string, coreQuery, queryHasSlashes);
              if (!queryHasSlashes) {
                score = legacy_scorer.basenameScore(string, coreQuery, score);
              }
              if (score > 0) {
                scoredCandidates.push({
                  candidate: candidate,
                  score: score
                });
              }
            }
          }
          scoredCandidates.sort(sortCandidates);
          candidates = scoredCandidates.map(pluckCandidates);
          if (maxResults != null) {
            candidates = candidates.slice(0, maxResults);
          }
          return candidates;
        };
      }.call(this));
    },
    {
      './legacy': 3,
      './scorer': 5,
      'path': 6
    }
  ],
  2: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, filter, legacy_scorer, matcher, prepQueryCache, scorer;
        scorer = require('./scorer');
        legacy_scorer = require('./legacy');
        filter = require('./filter');
        matcher = require('./matcher');
        PathSeparator = require('path').sep;
        prepQueryCache = null;
        module.exports = {
          filter: function (candidates, query, options) {
            if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
              return [];
            }
            return filter(candidates, query, options);
          },
          prepQuery: function (query) {
            return scorer.prepQuery(query);
          },
          score: function (string, query, prepQuery, _arg) {
            var allowErrors, coreQuery, legacy, queryHasSlashes, score, _ref;
            _ref = _arg != null ? _arg : {}, allowErrors = _ref.allowErrors, legacy = _ref.legacy;
            if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
              return 0;
            }
            if (prepQuery == null) {
              prepQuery = prepQueryCache && prepQueryCache.query === query ? prepQueryCache : prepQueryCache = scorer.prepQuery(query);
            }
            if (!legacy) {
              score = scorer.score(string, query, prepQuery, !!allowErrors);
            } else {
              queryHasSlashes = prepQuery.depth > 0;
              coreQuery = prepQuery.core;
              score = legacy_scorer.score(string, coreQuery, queryHasSlashes);
              if (!queryHasSlashes) {
                score = legacy_scorer.basenameScore(string, coreQuery, score);
              }
            }
            return score;
          },
          match: function (string, query, prepQuery, _arg) {
            var allowErrors, baseMatches, matches, query_lw, string_lw, _i, _ref, _results;
            allowErrors = (_arg != null ? _arg : {}).allowErrors;
            if (!string) {
              return [];
            }
            if (!query) {
              return [];
            }
            if (string === query) {
              return function () {
                _results = [];
                for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
                  _results.push(_i);
                }
                return _results;
              }.apply(this);
            }
            if (prepQuery == null) {
              prepQuery = prepQueryCache && prepQueryCache.query === query ? prepQueryCache : prepQueryCache = scorer.prepQuery(query);
            }
            if (!(allowErrors || scorer.isMatch(string, prepQuery.core_lw, prepQuery.core_up))) {
              return [];
            }
            string_lw = string.toLowerCase();
            query_lw = prepQuery.query_lw;
            matches = matcher.match(string, string_lw, prepQuery);
            if (matches.length === 0) {
              return matches;
            }
            if (string.indexOf(PathSeparator) > -1) {
              baseMatches = matcher.basenameMatch(string, string_lw, prepQuery);
              matches = matcher.mergeMatches(matches, baseMatches);
            }
            return matches;
          }
        };
      }.call(this));
    },
    {
      './filter': 1,
      './legacy': 3,
      './matcher': 4,
      './scorer': 5,
      'path': 6
    }
  ],
  3: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, queryIsLastPathSegment;
        PathSeparator = require('path').sep;
        exports.basenameScore = function (string, query, score) {
          var base, depth, index, lastCharacter, segmentCount, slashCount;
          index = string.length - 1;
          while (string[index] === PathSeparator) {
            index--;
          }
          slashCount = 0;
          lastCharacter = index;
          base = null;
          while (index >= 0) {
            if (string[index] === PathSeparator) {
              slashCount++;
              if (base == null) {
                base = string.substring(index + 1, lastCharacter + 1);
              }
            } else if (index === 0) {
              if (lastCharacter < string.length - 1) {
                if (base == null) {
                  base = string.substring(0, lastCharacter + 1);
                }
              } else {
                if (base == null) {
                  base = string;
                }
              }
            }
            index--;
          }
          if (base === string) {
            score *= 2;
          } else if (base) {
            score += exports.score(base, query);
          }
          segmentCount = slashCount + 1;
          depth = Math.max(1, 10 - segmentCount);
          score *= depth * 0.01;
          return score;
        };
        exports.score = function (string, query) {
          var character, characterScore, indexInQuery, indexInString, lowerCaseIndex, minIndex, queryLength, queryScore, stringLength, totalCharacterScore, upperCaseIndex, _ref;
          if (string === query) {
            return 1;
          }
          if (queryIsLastPathSegment(string, query)) {
            return 1;
          }
          totalCharacterScore = 0;
          queryLength = query.length;
          stringLength = string.length;
          indexInQuery = 0;
          indexInString = 0;
          while (indexInQuery < queryLength) {
            character = query[indexInQuery++];
            lowerCaseIndex = string.indexOf(character.toLowerCase());
            upperCaseIndex = string.indexOf(character.toUpperCase());
            minIndex = Math.min(lowerCaseIndex, upperCaseIndex);
            if (minIndex === -1) {
              minIndex = Math.max(lowerCaseIndex, upperCaseIndex);
            }
            indexInString = minIndex;
            if (indexInString === -1) {
              return 0;
            }
            characterScore = 0.1;
            if (string[indexInString] === character) {
              characterScore += 0.1;
            }
            if (indexInString === 0 || string[indexInString - 1] === PathSeparator) {
              characterScore += 0.8;
            } else if ((_ref = string[indexInString - 1]) === '-' || _ref === '_' || _ref === ' ') {
              characterScore += 0.7;
            }
            string = string.substring(indexInString + 1, stringLength);
            totalCharacterScore += characterScore;
          }
          queryScore = totalCharacterScore / queryLength;
          return (queryScore * (queryLength / stringLength) + queryScore) / 2;
        };
        queryIsLastPathSegment = function (string, query) {
          if (string[string.length - query.length - 1] === PathSeparator) {
            return string.lastIndexOf(query) === string.length - query.length;
          }
        };
        exports.match = function (string, query, stringOffset) {
          var character, indexInQuery, indexInString, lowerCaseIndex, matches, minIndex, queryLength, stringLength, upperCaseIndex, _i, _ref, _results;
          if (stringOffset == null) {
            stringOffset = 0;
          }
          if (string === query) {
            return function () {
              _results = [];
              for (var _i = stringOffset, _ref = stringOffset + string.length; stringOffset <= _ref ? _i < _ref : _i > _ref; stringOffset <= _ref ? _i++ : _i--) {
                _results.push(_i);
              }
              return _results;
            }.apply(this);
          }
          queryLength = query.length;
          stringLength = string.length;
          indexInQuery = 0;
          indexInString = 0;
          matches = [];
          while (indexInQuery < queryLength) {
            character = query[indexInQuery++];
            lowerCaseIndex = string.indexOf(character.toLowerCase());
            upperCaseIndex = string.indexOf(character.toUpperCase());
            minIndex = Math.min(lowerCaseIndex, upperCaseIndex);
            if (minIndex === -1) {
              minIndex = Math.max(lowerCaseIndex, upperCaseIndex);
            }
            indexInString = minIndex;
            if (indexInString === -1) {
              return [];
            }
            matches.push(stringOffset + indexInString);
            stringOffset += indexInString + 1;
            string = string.substring(indexInString + 1, stringLength);
          }
          return matches;
        };
      }.call(this));
    },
    { 'path': 6 }
  ],
  4: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, scorer;
        PathSeparator = require('path').sep;
        scorer = require('./scorer');
        exports.basenameMatch = function (subject, subject_lw, prepQuery) {
          var basePos, depth, end;
          end = subject.length - 1;
          while (subject[end] === PathSeparator) {
            end--;
          }
          basePos = subject.lastIndexOf(PathSeparator, end);
          if (basePos === -1) {
            return [];
          }
          depth = prepQuery.depth;
          while (depth-- > 0) {
            basePos = subject.lastIndexOf(PathSeparator, basePos - 1);
            if (basePos === -1) {
              return [];
            }
          }
          basePos++;
          end++;
          return exports.match(subject.slice(basePos, end), subject_lw.slice(basePos, end), prepQuery, basePos);
        };
        exports.mergeMatches = function (a, b) {
          var ai, bj, i, j, m, n, out;
          m = a.length;
          n = b.length;
          if (n === 0) {
            return a.slice();
          }
          if (m === 0) {
            return b.slice();
          }
          i = -1;
          j = 0;
          bj = b[j];
          out = [];
          while (++i < m) {
            ai = a[i];
            while (bj <= ai && ++j < n) {
              if (bj < ai) {
                out.push(bj);
              }
              bj = b[j];
            }
            out.push(ai);
          }
          while (j < n) {
            out.push(b[j++]);
          }
          return out;
        };
        exports.match = function (subject, subject_lw, prepQuery, offset) {
          var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
          if (offset == null) {
            offset = 0;
          }
          query = prepQuery.query;
          query_lw = prepQuery.query_lw;
          m = subject.length;
          n = query.length;
          acro_score = scorer.scoreAcronyms(subject, subject_lw, query, query_lw).score;
          score_row = new Array(n);
          csc_row = new Array(n);
          STOP = 0;
          UP = 1;
          LEFT = 2;
          DIAGONAL = 3;
          trace = new Array(m * n);
          pos = -1;
          j = -1;
          while (++j < n) {
            score_row[j] = 0;
            csc_row[j] = 0;
          }
          i = -1;
          while (++i < m) {
            score = 0;
            score_up = 0;
            csc_diag = 0;
            si_lw = subject_lw[i];
            j = -1;
            while (++j < n) {
              csc_score = 0;
              align = 0;
              score_diag = score_up;
              if (query_lw[j] === si_lw) {
                start = scorer.isWordStart(i, subject, subject_lw);
                csc_score = csc_diag > 0 ? csc_diag : scorer.scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
                align = score_diag + scorer.scoreCharacter(i, j, start, acro_score, csc_score);
              }
              score_up = score_row[j];
              csc_diag = csc_row[j];
              if (score > score_up) {
                move = LEFT;
              } else {
                score = score_up;
                move = UP;
              }
              if (align > score) {
                score = align;
                move = DIAGONAL;
              } else {
                csc_score = 0;
              }
              score_row[j] = score;
              csc_row[j] = csc_score;
              trace[++pos] = score > 0 ? move : STOP;
            }
          }
          i = m - 1;
          j = n - 1;
          pos = i * n + j;
          backtrack = true;
          matches = [];
          while (backtrack && i >= 0 && j >= 0) {
            switch (trace[pos]) {
            case UP:
              i--;
              pos -= n;
              break;
            case LEFT:
              j--;
              pos--;
              break;
            case DIAGONAL:
              matches.push(i + offset);
              j--;
              i--;
              pos -= n + 1;
              break;
            default:
              backtrack = false;
            }
          }
          matches.reverse();
          return matches;
        };
      }.call(this));
    },
    {
      './scorer': 5,
      'path': 6
    }
  ],
  5: [
    function (require, module, exports) {
      (function () {
        var AcronymResult, PathSeparator, Query, basenameScore, coreChars, countDir, doScore, emptyAcronymResult, file_coeff, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, opt_char_re, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_depth, tau_size, truncatedUpperCase, wm;
        PathSeparator = require('path').sep;
        wm = 150;
        pos_bonus = 20;
        tau_depth = 13;
        tau_size = 85;
        file_coeff = 1.2;
        miss_coeff = 0.75;
        opt_char_re = /[ _\-:\/\\]/g;
        exports.coreChars = coreChars = function (query) {
          return query.replace(opt_char_re, '');
        };
        exports.score = function (string, query, prepQuery, allowErrors) {
          var score, string_lw;
          if (prepQuery == null) {
            prepQuery = new Query(query);
          }
          if (allowErrors == null) {
            allowErrors = false;
          }
          if (!(allowErrors || isMatch(string, prepQuery.core_lw, prepQuery.core_up))) {
            return 0;
          }
          string_lw = string.toLowerCase();
          score = doScore(string, string_lw, prepQuery);
          return Math.ceil(basenameScore(string, string_lw, prepQuery, score));
        };
        Query = function () {
          function Query(query) {
            if (!(query != null ? query.length : void 0)) {
              return null;
            }
            this.query = query;
            this.query_lw = query.toLowerCase();
            this.core = coreChars(query);
            this.core_lw = this.core.toLowerCase();
            this.core_up = truncatedUpperCase(this.core);
            this.depth = countDir(query, query.length);
          }
          return Query;
        }();
        exports.prepQuery = function (query) {
          return new Query(query);
        };
        exports.isMatch = isMatch = function (subject, query_lw, query_up) {
          var i, j, m, n, qj_lw, qj_up, si;
          m = subject.length;
          n = query_lw.length;
          if (!m || n > m) {
            return false;
          }
          i = -1;
          j = -1;
          while (++j < n) {
            qj_lw = query_lw[j];
            qj_up = query_up[j];
            while (++i < m) {
              si = subject[i];
              if (si === qj_lw || si === qj_up) {
                break;
              }
            }
            if (i === m) {
              return false;
            }
          }
          return true;
        };
        doScore = function (subject, subject_lw, prepQuery) {
          var acro, acro_score, align, csc_diag, csc_row, csc_score, i, j, m, miss_budget, miss_left, mm, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
          query = prepQuery.query;
          query_lw = prepQuery.query_lw;
          m = subject.length;
          n = query.length;
          acro = scoreAcronyms(subject, subject_lw, query, query_lw);
          acro_score = acro.score;
          if (acro.count === n) {
            return scoreExact(n, m, acro_score, acro.pos);
          }
          pos = subject_lw.indexOf(query_lw);
          if (pos > -1) {
            return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
          }
          score_row = new Array(n);
          csc_row = new Array(n);
          sz = scoreSize(n, m);
          miss_budget = Math.ceil(miss_coeff * n) + 5;
          miss_left = miss_budget;
          j = -1;
          while (++j < n) {
            score_row[j] = 0;
            csc_row[j] = 0;
          }
          i = subject_lw.indexOf(query_lw[0]);
          if (i > -1) {
            i--;
          }
          mm = subject_lw.lastIndexOf(query_lw[n - 1], m);
          if (mm > i) {
            m = mm + 1;
          }
          while (++i < m) {
            score = 0;
            score_diag = 0;
            csc_diag = 0;
            si_lw = subject_lw[i];
            record_miss = true;
            j = -1;
            while (++j < n) {
              score_up = score_row[j];
              if (score_up > score) {
                score = score_up;
              }
              csc_score = 0;
              if (query_lw[j] === si_lw) {
                start = isWordStart(i, subject, subject_lw);
                csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
                align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
                if (align > score) {
                  score = align;
                  miss_left = miss_budget;
                } else {
                  if (record_miss && --miss_left <= 0) {
                    return score_row[n - 1] * sz;
                  }
                  record_miss = false;
                }
              }
              score_diag = score_up;
              csc_diag = csc_row[j];
              csc_row[j] = csc_score;
              score_row[j] = score;
            }
          }
          return score * sz;
        };
        exports.isWordStart = isWordStart = function (pos, subject, subject_lw) {
          var curr_s, prev_s;
          if (pos === 0) {
            return true;
          }
          curr_s = subject[pos];
          prev_s = subject[pos - 1];
          return isSeparator(curr_s) || isSeparator(prev_s) || curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1];
        };
        exports.isWordEnd = isWordEnd = function (pos, subject, subject_lw, len) {
          var curr_s, next_s;
          if (pos === len - 1) {
            return true;
          }
          curr_s = subject[pos];
          next_s = subject[pos + 1];
          return isSeparator(curr_s) || isSeparator(next_s) || curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1];
        };
        isSeparator = function (c) {
          return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\';
        };
        scorePosition = function (pos) {
          var sc;
          if (pos < pos_bonus) {
            sc = pos_bonus - pos;
            return 100 + sc * sc;
          } else {
            return Math.max(100 + pos_bonus - pos, 0);
          }
        };
        scoreSize = function (n, m) {
          return tau_size / (tau_size + Math.abs(m - n));
        };
        scoreExact = function (n, m, quality, pos) {
          return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
        };
        exports.scorePattern = scorePattern = function (count, len, sameCase, start, end) {
          var bonus, sz;
          sz = count;
          bonus = 6;
          if (sameCase === count) {
            bonus += 2;
          }
          if (start) {
            bonus += 3;
          }
          if (end) {
            bonus += 1;
          }
          if (count === len) {
            if (start) {
              if (sameCase === len) {
                sz += 2;
              } else {
                sz += 1;
              }
            }
            if (end) {
              bonus += 1;
            }
          }
          return sameCase + sz * (sz + bonus);
        };
        exports.scoreCharacter = scoreCharacter = function (i, j, start, acro_score, csc_score) {
          var posBonus;
          posBonus = scorePosition(i);
          if (start) {
            return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
          }
          return posBonus + wm * csc_score;
        };
        exports.scoreConsecutives = scoreConsecutives = function (subject, subject_lw, query, query_lw, i, j, start) {
          var k, m, mi, n, nj, sameCase, startPos, sz;
          m = subject.length;
          n = query.length;
          mi = m - i;
          nj = n - j;
          k = mi < nj ? mi : nj;
          startPos = i;
          sameCase = 0;
          sz = 0;
          if (query[j] === subject[i]) {
            sameCase++;
          }
          while (++sz < k && query_lw[++j] === subject_lw[++i]) {
            if (query[j] === subject[i]) {
              sameCase++;
            }
          }
          if (sz === 1) {
            return 1 + 2 * sameCase;
          }
          return scorePattern(sz, n, sameCase, start, isWordEnd(i, subject, subject_lw, m));
        };
        exports.scoreExactMatch = scoreExactMatch = function (subject, subject_lw, query, query_lw, pos, n, m) {
          var end, i, pos2, sameCase, start;
          start = isWordStart(pos, subject, subject_lw);
          if (!start) {
            pos2 = subject_lw.indexOf(query_lw, pos + 1);
            if (pos2 > -1) {
              start = isWordStart(pos2, subject, subject_lw);
              if (start) {
                pos = pos2;
              }
            }
          }
          i = -1;
          sameCase = 0;
          while (++i < n) {
            if (query[pos + i] === subject[i]) {
              sameCase++;
            }
          }
          end = isWordEnd(pos + n - 1, subject, subject_lw, m);
          return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
        };
        AcronymResult = function () {
          function AcronymResult(score, pos, count) {
            this.score = score;
            this.pos = pos;
            this.count = count;
          }
          return AcronymResult;
        }();
        emptyAcronymResult = new AcronymResult(0, 0.1, 0);
        exports.scoreAcronyms = scoreAcronyms = function (subject, subject_lw, query, query_lw) {
          var count, i, j, m, n, pos, qj_lw, sameCase, score;
          m = subject.length;
          n = query.length;
          if (!(m > 1 && n > 1)) {
            return emptyAcronymResult;
          }
          count = 0;
          pos = 0;
          sameCase = 0;
          i = -1;
          j = -1;
          while (++j < n) {
            qj_lw = query_lw[j];
            while (++i < m) {
              if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
                if (query[j] === subject[i]) {
                  sameCase++;
                }
                pos += i;
                count++;
                break;
              }
            }
            if (i === m) {
              break;
            }
          }
          if (count < 2) {
            return emptyAcronymResult;
          }
          score = scorePattern(count, n, sameCase, true, false);
          return new AcronymResult(score, pos / count, count);
        };
        basenameScore = function (subject, subject_lw, prepQuery, fullPathScore) {
          var alpha, basePathScore, basePos, depth, end;
          if (fullPathScore === 0) {
            return 0;
          }
          end = subject.length - 1;
          while (subject[end] === PathSeparator) {
            end--;
          }
          basePos = subject.lastIndexOf(PathSeparator, end);
          if (basePos === -1) {
            return fullPathScore;
          }
          depth = prepQuery.depth;
          while (depth-- > 0) {
            basePos = subject.lastIndexOf(PathSeparator, basePos - 1);
            if (basePos === -1) {
              return fullPathScore;
            }
          }
          basePos++;
          end++;
          basePathScore = doScore(subject.slice(basePos, end), subject_lw.slice(basePos, end), prepQuery);
          alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1));
          return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * (end - basePos));
        };
        exports.countDir = countDir = function (path, end) {
          var count, i;
          if (end < 1) {
            return 0;
          }
          count = 0;
          i = -1;
          while (++i < end && path[i] === PathSeparator) {
            continue;
          }
          while (++i < end) {
            if (path[i] === PathSeparator) {
              count++;
              while (++i < end && path[i] === PathSeparator) {
                continue;
              }
            }
          }
          return count;
        };
        truncatedUpperCase = function (str) {
          var char, upper, _i, _len;
          upper = '';
          for (_i = 0, _len = str.length; _i < _len; _i++) {
            char = str[_i];
            upper += char.toUpperCase()[0];
          }
          return upper;
        };
      }.call(this));
    },
    { 'path': 6 }
  ],
  6: [
    function (require, module, exports) {
      (function (process) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // resolves . and .. elements in a path array with directory names there
        // must be no slashes, empty elements, or device names (c:\) in the array
        // (so also no leading and trailing slashes - it does not distinguish
        // relative and absolute paths)
        function normalizeArray(parts, allowAboveRoot) {
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === '.') {
              parts.splice(i, 1);
            } else if (last === '..') {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          // if the path is allowed to go above the root, restore leading ..s
          if (allowAboveRoot) {
            for (; up--; up) {
              parts.unshift('..');
            }
          }
          return parts;
        }
        // Split a filename into [root, dir, basename, ext], unix version
        // 'root' is just a slash, or nothing.
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        var splitPath = function (filename) {
          return splitPathRe.exec(filename).slice(1);
        };
        // path.resolve([from ...], to)
        // posix version
        exports.resolve = function () {
          var resolvedPath = '', resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : process.cwd();
            // Skip empty and invalid entries
            if (typeof path !== 'string') {
              throw new TypeError('Arguments to path.resolve must be strings');
            } else if (!path) {
              continue;
            }
            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charAt(0) === '/';
          }
          // At this point the path should be resolved to a full absolute path, but
          // handle relative paths to be safe (might happen when process.cwd() fails)
          // Normalize the path
          resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
            return !!p;
          }), !resolvedAbsolute).join('/');
          return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
        };
        // path.normalize(path)
        // posix version
        exports.normalize = function (path) {
          var isAbsolute = exports.isAbsolute(path), trailingSlash = substr(path, -1) === '/';
          // Normalize the path
          path = normalizeArray(filter(path.split('/'), function (p) {
            return !!p;
          }), !isAbsolute).join('/');
          if (!path && !isAbsolute) {
            path = '.';
          }
          if (path && trailingSlash) {
            path += '/';
          }
          return (isAbsolute ? '/' : '') + path;
        };
        // posix version
        exports.isAbsolute = function (path) {
          return path.charAt(0) === '/';
        };
        // posix version
        exports.join = function () {
          var paths = Array.prototype.slice.call(arguments, 0);
          return exports.normalize(filter(paths, function (p, index) {
            if (typeof p !== 'string') {
              throw new TypeError('Arguments to path.join must be strings');
            }
            return p;
          }).join('/'));
        };
        // path.relative(from, to)
        // posix version
        exports.relative = function (from, to) {
          from = exports.resolve(from).substr(1);
          to = exports.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== '')
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== '')
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split('/'));
          var toParts = trim(to.split('/'));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push('..');
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join('/');
        };
        exports.sep = '/';
        exports.delimiter = ':';
        exports.dirname = function (path) {
          var result = splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            // No dirname whatsoever
            return '.';
          }
          if (dir) {
            // It has a dirname, strip trailing slash
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        };
        exports.basename = function (path, ext) {
          var f = splitPath(path)[2];
          // TODO: make this comparison case-insensitive on windows?
          if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
          }
          return f;
        };
        exports.extname = function (path) {
          return splitPath(path)[3];
        };
        function filter(xs, f) {
          if (xs.filter)
            return xs.filter(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs))
              res.push(xs[i]);
          }
          return res;
        }
        // String.prototype.substr - negative index don't work in IE8
        var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
            return str.substr(start, len);
          } : function (str, start, len) {
            if (start < 0)
              start = str.length + start;
            return str.substr(start, len);
          };
        ;
      }.call(this, require('_process')));
    },
    { '_process': 7 }
  ],
  7: [
    function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {};
      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      }());
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = '';
      // empty string to avoid regexp issues
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };
      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };
    },
    {}
  ],
  8: [
    function (require, module, exports) {
      window['RAML'] = window['RAML'] || {};
      window['RAML'].Suggestions = require('./index');
    },
    { './index': 10 }
  ],
  9: [
    function (require, module, exports) {
      'use strict';
      /// <reference path="../typings/main.d.ts" />
      var parserApi = window.RAML.Parser;
      var def = parserApi.ds;
      var search = parserApi.search;
      var universeModule = parserApi.universes;
      var universeHelpers = parserApi.universeHelpers;
      var services = def;
      var _ = require('underscore');
      var categories = require('../resources/categories.json');
      var CompletionRequest = function () {
          function CompletionRequest(content) {
            this.async = false;
            this.content = content;
          }
          CompletionRequest.prototype.prefix = function () {
            if (typeof this.prefixValue !== 'undefined') {
              return this.prefixValue;
            }
            return getPrefix(this);
          };
          CompletionRequest.prototype.setPrefix = function (value) {
            this.prefixValue = value;
          };
          CompletionRequest.prototype.valuePrefix = function () {
            var offset = this.content.getOffset();
            var text = this.content.getText();
            for (var i = offset - 1; i >= 0; i--) {
              var c = text.charAt(i);
              if (c === '\r' || c === '\n' || c === ' ' || c === '\t' || c === '"' || c === '\'' || c === ':' || c === '(') {
                return text.substring(i + 1, offset);
              }
            }
            return '';
          };
          return CompletionRequest;
        }();
      exports.CompletionRequest = CompletionRequest;
      var CompletionProvider = function () {
          function CompletionProvider(contentProvider) {
            this.currentRequest = null;
            this.level = 0;
            this.contentProvider = contentProvider;
          }
          CompletionProvider.prototype.suggest = function (request, doPostProcess) {
            if (doPostProcess === void 0) {
              doPostProcess = false;
            }
            var suggestions = doSuggest(request, this);
            return doPostProcess ? postProcess(suggestions, request) : suggestions;
          };
          CompletionProvider.prototype.suggestAsync = function (request, doPostProcess) {
            if (doPostProcess === void 0) {
              doPostProcess = false;
            }
            return doSuggestAsync(request, this).then(function (suggestions) {
              return doPostProcess ? postProcess(suggestions, request) : suggestions;
            }, function (error) {
              return error;
            });
          };
          return CompletionProvider;
        }();
      exports.CompletionProvider = CompletionProvider;
      function suggest(editorState, fsProvider) {
        var completionRequest = new CompletionRequest(editorState);
        var completionProvider = new CompletionProvider(fsProvider);
        return completionProvider.suggest(completionRequest, true);
      }
      exports.suggest = suggest;
      function suggestAsync(editorState, fsProvider) {
        var completionRequest = new CompletionRequest(editorState);
        var completionProvider = new CompletionProvider(fsProvider);
        return completionProvider.suggestAsync(completionRequest, true);
      }
      exports.suggestAsync = suggestAsync;
      function categoryByRanges(suggestion, parentRange, propertyRange) {
        var categoryNames = Object.keys(categories);
        for (var i = 0; i < categoryNames.length; i++) {
          var categoryName = categoryNames[i];
          var issues = Object.keys(categories[categoryName]);
          for (var j = 0; j < issues.length; j++) {
            var issueName = issues[j];
            if (issueName !== suggestion) {
              continue;
            }
            var issue = categories[categoryName][issueName];
            var propertyIs = issue.is || [];
            var parentIs = issue.parentIs || [];
            if (propertyRange && _.find(propertyIs, function (name) {
                return isRangeAssignable(propertyRange, name);
              })) {
              return categoryName;
            }
            if (parentRange && _.find(parentIs, function (name) {
                return isRangeAssignable(parentRange, name);
              })) {
              return categoryName;
            }
          }
        }
        return 'unknown';
      }
      function isRangeAssignable(type, defCode) {
        var keys = defCode.split('.');
        var defObject = parserApi.universes;
        for (var i = 0; i < keys.length; i++) {
          defObject = defObject[keys[i]];
        }
        return type.isAssignableFrom(defObject.name);
      }
      function doSuggest(request, provider) {
        var result = getSuggestions(request, provider);
        if (result)
          return result;
        return [];
      }
      function doSuggestAsync(request, provider) {
        request.async = true;
        request.promises = [];
        var apiPromise = parserApi.parseRAML(modifiedContent(request), {
            fsResolver: provider.contentProvider.fsResolver,
            filePath: request.content.getPath()
          });
        var suggestionsPromise = apiPromise.then(function (api) {
            return getSuggestions(request, provider, findAtOffsetInNode(request.content.getOffset(), api.highLevel()));
          });
        var requestSuggestionsPromise = suggestionsPromise.then(function (suggestions) {
            return Promise.all([suggestions].concat(request.promises));
          });
        var finalPromise = requestSuggestionsPromise.then(function (arrays) {
            var result = [];
            arrays.forEach(function (suggestions) {
              result = result.concat(suggestions);
            });
            return result;
          });
        return finalPromise;
      }
      function getSuggestions(request, provider, preParsedAst) {
        if (preParsedAst === void 0) {
          preParsedAst = undefined;
        }
        provider.currentRequest = request;
        try {
          if (provider.level > 100) {
            return;
          }
          provider.level++;
          var offset = request.content.getOffset();
          var text = request.content.getText();
          var kind = completionKind(request);
          var node = preParsedAst ? preParsedAst : getAstNode(request, provider.contentProvider);
          var hlnode = node;
          if (kind === parserApi.search.LocationKind.DIRECTIVE_COMPLETION) {
            return [{ text: 'include' }];
          }
          if (kind === parserApi.search.LocationKind.ANNOTATION_COMPLETION) {
            var declarations = parserApi.search.globalDeclarations(hlnode).filter(function (x) {
                return parserApi.universeHelpers.isAnnotationTypesProperty(x.property());
              });
            return declarations.map(function (x) {
              return {
                text: parserApi.search.qName(x, hlnode),
                annotation: true
              };
            });
          }
          if (kind === parserApi.search.LocationKind.VERSION_COMPLETION) {
            return ramlVersionCompletion(request);
          }
          if (kind === parserApi.search.LocationKind.INCOMMENT) {
            return [];
          }
          if (node === null) {
            return [];
          }
          var hasNewLine = false;
          for (var position = offset - 1; position >= hlnode.lowLevel().start(); position--) {
            var ch = text[position];
            if (ch == '\r' || ch == '\n') {
              hasNewLine = true;
              break;
            }
          }
          var cmi = offset;
          for (var pm = offset - 1; pm >= 0; pm--) {
            var c = text[pm];
            if (c === ' ' || c === '\t') {
              cmi = pm;
              continue;
            }
            break;
          }
          var attr = _.find(hlnode.attrs(), function (x) {
              return x.lowLevel().start() < cmi && x.lowLevel().end() >= cmi && !x.property().getAdapter(parserApi.ds.RAMLPropertyService).isKey();
            });
          if (!attr) {
            var p = _.find(hlnode.definition().allProperties(), function (p) {
                return p.canBeValue();
              });
            if (!hasNewLine) {
              if (p && kind == parserApi.search.LocationKind.VALUE_COMPLETION && parserApi.universeHelpers.isTypeProperty(p)) {
                if (hlnode.children().length == 1) {
                  attr = parserApi.stubs.createASTPropImpl(hlnode.lowLevel(), hlnode, p.range(), p);
                }
              }
            } else {
              var cm = _.find(hlnode.lowLevel().children(), function (x) {
                  return x.start() < offset && x.end() >= offset;
                });
              if (cm) {
                var p = _.find(hlnode.definition().allProperties(), function (p) {
                    return p.nameId() == cm.key();
                  });
                if (p) {
                  var il = getIndent(cm.keyStart(), cm.unit().contents());
                  var il2 = getIndent(offset, cm.unit().contents());
                  if (il2.length > il.length + 1) {
                    var isValue = p.range().hasValueTypeInHierarchy();
                    if (isValue) {
                      attr = parserApi.stubs.createVirtualASTPropImpl(cm, hlnode, p.range(), p);
                    } else {
                      if (cm.children().length > 0) {
                        hlnode = parserApi.stubs.createVirtualNodeImpl(cm.children()[0], hlnode, p.range(), p);
                      }
                    }
                  }
                }
              }
            }
          }
          if (kind == parserApi.search.LocationKind.PATH_COMPLETION) {
            return pathCompletion(request, provider.contentProvider, attr, hlnode, false);
          }
          if (attr && (kind === parserApi.search.LocationKind.KEY_COMPLETION || kind === parserApi.search.LocationKind.SEQUENCE_KEY_COPLETION)) {
            var txt = '';
            for (var position = offset - 1; position >= 0; position--) {
              var ch = text[position];
              if (ch == '\r' || ch == '\n') {
                break;
              }
              txt = ch + txt;
            }
            txt = txt.trim();
            if (txt != attr.name()) {
              kind = parserApi.search.LocationKind.VALUE_COMPLETION;
            }
          }
          if (kind == parserApi.search.LocationKind.VALUE_COMPLETION) {
            var parentPropertyOfAttr = attr && attr.parent && attr.parent() && attr.parent().property && attr.parent().property();
            if (parentPropertyOfAttr && universeHelpers.isUsesProperty(parentPropertyOfAttr)) {
              return pathCompletion(request, provider.contentProvider, attr, hlnode, false);
            }
            var proposals = valueCompletion(node, attr, request, provider);
            if (!attr) {
              if (!proposals || proposals.length == 0) {
                if (!hasNewLine) {
                  if (hlnode.definition().getAdapter(parserApi.ds.RAMLService).isUserDefined()) {
                    return propertyCompletion(hlnode, request, mv, defNode, hasNewLine);
                  }
                }
              }
            }
            if (attr && attr.property() && (attr.property().getAdapter(parserApi.ds.RAMLPropertyService).isTypeExpr() || attr.property().isAnnotation())) {
              if (!proposals) {
                proposals = [];
              }
              proposals = proposals.filter(function (x) {
                var proposalText = getProposalText(x);
                if (proposalText === hlnode.name()) {
                  return false;
                }
                return true;
              });
              var pref = request.valuePrefix();
              var nmi = pref.lastIndexOf('.');
              if (nmi) {
                pref = pref.substr(0, nmi + 1);
              } else {
                pref = null;
              }
              if (pref) {
                proposals = proposals.filter(function (x) {
                  return getProposalText(x).indexOf(pref) == 0;
                });
                proposals.forEach(function (x) {
                  return updateProposalText(x, getProposalText(x).substring(pref.length));
                });
              }
            }
            if (proposals) {
              if (text[offset - 1] == ':') {
                proposals.forEach(function (x) {
                  if (x.extra) {
                    x.extra = ' ' + x.extra;
                  } else {
                    x.extra = ' ';
                  }
                });
              }
              if (request.prefix().indexOf('[') != -1) {
                request.setPrefix('');
                proposals.forEach(function (x) {
                  x.text = ': [ ' + x.displayText;
                });
              } else if (isSquareBracketExpected(attr)) {
                proposals = proposals.filter(function (proposed) {
                  return !isSiblingExists(attr, proposed.displayText);
                });
                var ending = '';
                var initialPosition = offset;
                for (var i = initialPosition; i < text.length && !/[\t\n\r]/.test(text[i]); i++) {
                  ending += text[i];
                  if (ending.replace(/\s/g, '') === ':') {
                    proposals.forEach(function (x) {
                      x.text = x.displayText;
                      x.snippet = null;
                      x.extra = null;
                    });
                    break;
                  }
                }
                var isOpenSquarePresent = false;
                initialPosition = offset - 1;
                for (var i = initialPosition; i >= 0 && !/[\t\n\r]/.test(text[i]); i--) {
                  if (text[i] === '[') {
                    isOpenSquarePresent = true;
                    break;
                  }
                }
                if (!isOpenSquarePresent) {
                  proposals.forEach(function (x) {
                    if (!request.valuePrefix() && x.snippet) {
                      x.text = x.displayText;
                      x.snippet = '[' + x.snippet + ']';
                      return;
                    }
                    x.extra = ' [';
                    x.text = (x.snippet || x.displayText) + ']';
                    x.snippet = null;
                  });
                }
              } else {
                var ending = '';
                var initialPosition = offset;
                for (var i = initialPosition; i < text.length && !/[\t\n\r]/.test(text[i]); i++) {
                  ending += text[i];
                  if (ending.replace(/\s/g, '') === ':') {
                    proposals.forEach(function (x) {
                      x.text = x.displayText;
                      x.snippet = null;
                      x.extra = null;
                    });
                    break;
                  }
                }
                proposals.forEach(function (x) {
                  if (x.isResourceType && !request.valuePrefix() && x.snippet) {
                    x.snippet = x.extra + x.snippet;
                    x.extra = null;
                    x.text = x.displayText;
                  }
                });
              }
            }
            if (!hasNewLine && proposals && proposals.length > 0) {
              proposals = addDefineInlineProposal2(proposals, hlnode.lowLevel().start(), text);
            }
            if (proposals && isInResourceDescription(attr) && request.prefix() && request.prefix().length > 0) {
              var canBeTemplate = false;
              var canBeTransform1 = 0;
              var canBeTransform2 = 0;
              var txt = '';
              for (var position = offset - 1; position >= 0; position--) {
                var ch = text[position];
                if (ch === '\r' || ch === '\n') {
                  break;
                }
                if (ch === '<' && text[position - 1] === '<') {
                  canBeTemplate = true;
                  break;
                }
                if (ch === '!') {
                  canBeTransform1++;
                }
                if (ch === '|' && canBeTransform1 === 1) {
                  canBeTransform2++;
                }
                txt = ch + txt;
              }
              if (canBeTemplate && canBeTransform1 === 1 && canBeTransform2 === 1) {
                var leftPart = new RegExp(/\|\s*!\s*/.source + request.prefix());
                if (leftPart.test(txt)) {
                  proposals = addTransformers(proposals, request.prefix());
                }
              }
            }
            return proposals;
          }
          if (kind == search.LocationKind.KEY_COMPLETION || kind == search.LocationKind.SEQUENCE_KEY_COPLETION && offset > 0 && text.charAt(offset - 1) != '-' && text.charAt(offset - 1) != ' ') {
            if (node.isAttr() || node.isImplicit()) {
              throw new Error('Should be highlevel node at this place');
            }
            if (search.isExampleNode(hlnode)) {
              return examplePropertyCompletion(hlnode, request, provider);
            }
            if (hlnode.property() && universeHelpers.isUriParametersProperty(hlnode.property()) && hlnode.definition() instanceof def.NodeClass) {
              var nm = hlnode.parent().attr('relativeUri');
              if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                var runtime = parserApi.utils.parseUrl(nm.value());
                if (runtime instanceof Array) {
                  if (runtime) {
                    if (isColonNeeded(offset, text)) {
                      var rs = runtime.map(function (x) {
                          return { text: x + ': \n' + getIndent2(offset, text) + '  ' };
                        });
                    } else {
                      var rs = runtime.map(function (x) {
                          return { text: x };
                        });
                    }
                    return rs;
                  }
                }
              }
            }
            if (hlnode.property() && universeHelpers.isBaseUriParametersProperty(hlnode.property()) && hlnode.definition() instanceof def.NodeClass) {
              var nm = hlnode.root().attr(universeModule.Universe10.Api.properties.baseUri.name);
              if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                var runtime = parserApi.utils.parseUrl(nm.value());
                if (runtime instanceof Array) {
                  if (runtime) {
                    if (isColonNeeded(offset, text)) {
                      var rs = runtime.map(function (x) {
                          return { text: x + ': \n' + getIndent2(offset, text) + '  ' };
                        });
                    } else {
                      var rs = runtime.map(function (x) {
                          return { text: x };
                        });
                    }
                    return rs;
                  }
                }
              }
            }
            //FIXME It still should be improved
            if (hlnode.property() && universeHelpers.isResourcesProperty(hlnode.property())) {
              var nm = hlnode.attr('relativeUri');
              if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                if (nm && nm.value().indexOf('{') != -1) {
                  return [{ text: 'mediaTypeExtension}' }];
                }
                return [];
              }
            }
            var mv = hlnode.property() && hlnode.property().isMultiValue();
            if (hlnode.lowLevel().keyEnd() < offset) {
              mv = false;
            }
            //extra test /*FIXME*/
            var defNode = true;
            if (mv) {
              var ce = hlnode.definition().getAdapter(services.RAMLService).getCanInherit();
              if (ce) {
                var context = hlnode.computedValue(ce[0]);
                if (context) {
                  defNode = true;
                  mv = false;
                }
              }
            }
            return propertyCompletion(hlnode, request, mv, defNode);
          }
          return [];
        } finally {
          provider.level--;
        }  //return [];
      }
      function ramlVersionCompletion(request) {
        var prop = [
            'RAML 0.8',
            'RAML 1.0'
          ];
        var rs = [];
        var text = request.content.getText();
        var offset = request.content.getOffset();
        var start = text.substr(0, offset);
        if (start.indexOf('#%RAML 1.0 ') == 0) {
          var list = [
              'DocumentationItem',
              'DataType',
              'NamedExample',
              'ResourceType',
              'Trait',
              'SecurityScheme',
              'AnnotationTypeDeclaration',
              'Library',
              'Overlay',
              'Extension'
            ];
          return list.map(function (x) {
            return { text: x };
          });
        }
        prop.forEach(function (x) {
          if (('#%' + x).indexOf(start) != 0) {
            return;
          }
          if (text.trim().indexOf('#%') == 0) {
            if (request.prefix().indexOf('R') != -1) {
              rs.push({
                displayText: x,
                text: x
              });
            } else {
              var pref = text.substring(2, offset);
              if (x.indexOf(pref) == 0) {
                if (request.prefix() == '1' || request.prefix() == '0') {
                  rs.push({
                    displayText: x,
                    text: request.prefix() + x.substr(offset - 2)
                  });
                } else {
                  rs.push({
                    displayText: x,
                    text: x.substr(offset - 2)
                  });
                }
              }
            }
          } else {
            rs.push({
              displayText: x,
              text: x,
              extra: '%'
            });
          }
        });
        return rs;
      }
      ;
      function completionKind(request) {
        return parserApi.search.determineCompletionKind(request.content.getText(), request.content.getOffset());
      }
      function getAstNode(request, contentProvider, clearLastChar, allowNull) {
        if (clearLastChar === void 0) {
          clearLastChar = true;
        }
        if (allowNull === void 0) {
          allowNull = true;
        }
        var newProjectId = contentProvider.contentDirName(request.content);
        var project = parserApi.project.createProject(newProjectId, contentProvider.fsResolver);
        var offset = request.content.getOffset();
        var text = request.content.getText();
        var kind = completionKind(request);
        if (kind === parserApi.search.LocationKind.KEY_COMPLETION && clearLastChar) {
          text = text.substring(0, offset) + 'k:' + text.substring(offset);
        }
        var unit = project.setCachedUnitContent(request.content.getBaseName(), text);
        var ast = unit.highLevel();
        var actualOffset = offset;
        for (var currentOffset = offset - 1; currentOffset >= 0; currentOffset--) {
          var symbol = text[currentOffset];
          if (symbol === ' ' || symbol === '\t') {
            actualOffset = currentOffset - 1;
            continue;
          }
          break;
        }
        var astNode = ast.findElementAtOffset(actualOffset);
        if (!allowNull && !astNode) {
          return ast;
        }
        return astNode;
      }
      function modifiedContent(request) {
        var offset = request.content.getOffset();
        var text = request.content.getText();
        var kind = completionKind(request);
        if (kind === parserApi.search.LocationKind.KEY_COMPLETION) {
          text = text.substring(0, offset) + 'k:' + text.substring(offset);
        }
        return text;
      }
      function findAtOffsetInNode(offset, node) {
        var actualOffset = offset;
        var text = node.lowLevel().unit().contents();
        for (var currentOffset = offset - 1; currentOffset >= 0; currentOffset--) {
          var symbol = text[currentOffset];
          if (symbol === ' ' || symbol === '\t') {
            actualOffset = currentOffset - 1;
            continue;
          }
          break;
        }
        return node.findElementAtOffset(actualOffset);
      }
      function getIndent(offset, text) {
        var spaces = '';
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c == ' ' || c == '\t') {
            if (spaces) {
              spaces += c;
            } else {
              spaces = c;
            }
          } else if (c == '\r' || c == '\n') {
            return spaces;
          } else if (spaces) {
            return '';
          }
        }
        return '';
      }
      function getIndentWithSequenc(offset, text) {
        var spaces = '';
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c == ' ' || c == '\t' || c == '-') {
            if (spaces) {
              spaces += c;
            } else {
              spaces = c;
            }
          } else if (c == '\r' || c == '\n') {
            return spaces;
          } else if (spaces) {
            return '';
          }
        }
        return '';
      }
      function getIndent2(offset, text) {
        var spaces = '';
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c == ' ' || c == '\t') {
            if (spaces) {
              spaces += c;
            } else {
              spaces = c;
            }
          } else if (c == '\r' || c == '\n') {
            return spaces;
          }
        }
      }
      function pathCompletion(request, contentProvider, attr, hlNode, custom) {
        var prefix = request.valuePrefix();
        if (prefix.indexOf('#') === -1) {
          return pathPartCompletion(request, contentProvider, attr, hlNode, custom);
        } else {
          return pathReferencePartCompletion(request, contentProvider, attr, hlNode, custom);
        }
      }
      function pathPartCompletion(request, contentProvider, attr, hlNode, custom) {
        var prefix = request.valuePrefix();
        var dn = contentProvider.contentDirName(request.content);
        var ll = contentProvider.resolve(dn, prefix);
        var indexOfDot = ll.lastIndexOf('.');
        var indexOfSlash = ll.lastIndexOf('/');
        if (!(indexOfDot > 0 && (indexOfDot > indexOfSlash || indexOfSlash < 0))) {
          indexOfDot = -1;
        }
        var typedPath = ll;
        if (ll) {
          dn = contentProvider.dirName(ll);
          if (request.async) {
            dn = contentProvider.existsAsync(ll).then(function (isExists) {
              if (!isExists) {
                return contentProvider.dirName(ll);
              }
              return contentProvider.isDirectoryAsync(ll).then(function (isDirectory) {
                if (!isDirectory) {
                  return contentProvider.dirName(ll);
                }
                return ll;
              });
            });
          } else if (contentProvider.exists(ll) && contentProvider.isDirectory(ll)) {
            dn = ll;
          }
        }
        var res = [];
        var known = !custom;
        if (attr) {
          if (custom) {
            if (attr.name() === 'example') {
              res = res.concat(fromDir(prefix, dn, 'examples', contentProvider, request.promises));
              known = true;
            }
            if (attr.name() === 'value' && parserApi.universeHelpers.isGlobalSchemaType(attr.parent().definition())) {
              res = res.concat(fromDir(prefix, dn, 'schemas', contentProvider, request.promises));
              known = true;
            }
          }
        }
        if (!attr) {
          if (custom) {
            if (parserApi.universeHelpers.isTraitType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'traits', contentProvider, request.promises));
              known = true;
            }
            if (parserApi.universeHelpers.isResourceTypeType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'resourceTypes', contentProvider, request.promises));
              known = true;
            }
            if (parserApi.universeHelpers.isSecuritySchemaType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'securitySchemes', contentProvider, request.promises));
              known = true;
            }
            if (parserApi.universeHelpers.isGlobalSchemaType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'schemas', contentProvider, request.promises));
              known = true;
            }
          }
        }
        if (!known || !custom) {
          if (request.async) {
            filtredDirContentAsync(dn, typedPath, indexOfDot, contentProvider, request.promises);
          } else if (contentProvider.exists(dn) && contentProvider.isDirectory(dn)) {
            var dirContent = contentProvider.readDir(dn);
            res = res.concat(dirContent.filter(function (x) {
              try {
                var fullPath = contentProvider.resolve(dn, x);
                if (fullPath.indexOf(typedPath) === 0) {
                  return true;
                }
              } catch (exception) {
                return false;
              }
            }).map(function (x) {
              return { text: indexOfDot > 0 ? contentProvider.resolve(dn, x).substr(indexOfDot + 1) : x };
            }));
          }
        }
        return res;
      }
      function filtredDirContentAsync(dirName, typedPath, indexOfDot, contentProvider, promises) {
        if (promises) {
          var asString;
          var exists = dirName.then(function (dirNameStr) {
              asString = dirNameStr;
              return contentProvider.existsAsync(dirNameStr);
            });
          var dirContent = exists.then(function (isExists) {
              if (!isExists) {
                return [];
              }
              return contentProvider.isDirectoryAsync(asString).then(function (isDir) {
                if (!isDir) {
                  return [];
                }
                return contentProvider.readDirAsync(asString).then(function (dirContent) {
                  return dirContent.filter(function (x) {
                    try {
                      var fullPath = contentProvider.resolve(asString, x);
                      if (fullPath.indexOf(typedPath) === 0) {
                        return true;
                      }
                    } catch (exception) {
                      return false;
                    }
                  }).map(function (x) {
                    return { text: indexOfDot > 0 ? contentProvider.resolve(dirName, x).substr(indexOfDot + 1) : x };
                  });
                });
              });
            });
          promises.push(dirContent);
        }
      }
      function fromDir(prefix, dn, dirToLook, contentProvider, promises) {
        if (promises) {
          var existsPromise = dn.then(function (dirName) {
              var pss = contentProvider.resolve(dirName, dirToLook);
              return contentProvider.existsAsync(pss);
            });
          var proposalsPromise = existsPromise.then(function (result) {
              if (result) {
                return contentProvider.readDirAsync(pss).then(function (dirNames) {
                  var proposals = dirNames.map(function (x) {
                      return {
                        text: x,
                        replacementPrefix: prefix,
                        extra: './' + dirToLook + '/'
                      };
                    });
                  return proposals;
                });
              }
              return [];
            });
          promises.push(proposalsPromise);
          return [];
        }
        var pss = contentProvider.resolve(dn, dirToLook);
        if (contentProvider.exists(pss)) {
          var dirContent = contentProvider.readDir(pss);
          var proposals = dirContent.map(function (x) {
              return {
                text: x,
                replacementPrefix: prefix,
                extra: './' + dirToLook + '/'
              };
            });
          return proposals;
        }
        return [];
      }
      function pathReferencePartCompletion(request, contentProvider, attr, hlNode, custom) {
        var prefix = request.valuePrefix();
        var includePath = parserApi.schema.getIncludePath(prefix);
        var includeReference = parserApi.schema.getIncludeReference(prefix);
        if (!includePath || !includeReference) {
          return [];
        }
        var includeUnit = attr.lowLevel().unit().resolve(includePath);
        if (!includeUnit) {
          return [];
        }
        var content = includeUnit.contents();
        if (!content) {
          return [];
        }
        try {
          var proposals = parserApi.schema.completeReference(includePath, includeReference, content);
          return proposals.map(function (proposal) {
            return { text: proposal };
          });
        } catch (Error) {
          console.log(Error);
        }
        return [];
      }
      function isColonNeeded(offset, text) {
        var needColon = true;
        for (var i = offset > 0 ? offset - 1 : 0; i < text.length; i++) {
          var chr = text.charAt(i);
          if (chr == ' ' || chr == '\r' || chr == '\n') {
            break;
          }
          if (chr == ':') {
            needColon = false;
          }
        }
        return needColon;
      }
      function isAllowed(node, x) {
        var ok = true;
        x.getContextRequirements().forEach(function (y) {
          if (y.name.indexOf('(') !== -1) {
            return;
          }
          var vl = node.computedValue(y.name);
          if (vl) {
            ok = ok && vl == y.value;
          } else {
            if (y.value) {
              ok = false;
            }
          }
        });
        return ok;
      }
      function propertyCompletion(node, request, mv, c, hasNewLine) {
        if (hasNewLine === void 0) {
          hasNewLine = true;
        }
        var hlnode = node;
        var notAKey = false;
        var onlyKey = false;
        var text = request.content.getText();
        var offset = request.content.getOffset();
        if (hasNewLine) {
          var is = getIndentWithSequenc(node.lowLevel().keyStart(), text);
          if (is == undefined) {
            is = '';
          }
          var i2s = getIndentWithSequenc(offset, text);
          var i1 = is.length;
          var i2 = i2s.length;
          if (i1 == i2 && node.parent()) {
            if (node.property().getAdapter(parserApi.ds.RAMLPropertyService).isMerged()) {
              hlnode = hlnode.parent();
            } else {
              notAKey = false;
              onlyKey = true;
            }
          }
          if (i2 > i1) {
            notAKey = true;
            if (i2 >= i1 + 4) {
              onlyKey = true;
              notAKey = false;
            }
          }
          while (i2 < i1 && hlnode.parent()) {
            hlnode = hlnode.parent();
            i1 = i1 - 2;
          }
        }
        var needColon = isColonNeeded(offset, text);
        var ks = needColon ? ': ' : '';
        var props = hlnode.definition().allProperties();
        //basic filtering
        props = props.filter(function (x) {
          return !x.getAdapter(parserApi.ds.RAMLPropertyService).isKey() && !x.getAdapter(parserApi.ds.RAMLPropertyService).isMerged() && !x.getAdapter(services.RAMLPropertyService).isSystem();
        });
        //contextual filtering
        props = props.filter(function (x) {
          return isAllowed(hlnode, x);
        });
        var existing = {};
        hlnode.attrs().forEach(function (x) {
          existing[x.name()] = true;
        });
        props = props.filter(function (x) {
          return !existing[x.nameId()];
        }).filter(function (x) {
          return !x.isAnnotation();
        });
        if (node.definition().isAssignableFrom(parserApi.universes.Universe10.TypeDeclaration.name)) {
          if (!node.definition().isAssignableFrom('ObjectTypeDeclaration')) {
            if (!node.attr('type')) {
              var q = node.definition().universe().type('ObjectTypeDeclaration');
              if (q) {
                props.push(q.property('properties'));
              }
            }
          }
        }
        //TODO MAKE IT BETTER (actually we need to filter out and guess availabe keys)
        var rs = [];
        if (!mv && !onlyKey) {
          rs = props.map(function (x) {
            var complextionText = x.nameId() + ks;
            if (!x.range().hasValueTypeInHierarchy() && needColon) {
              complextionText += '\n' + getIndent(offset, text) + '  ';
            }
            return {
              text: complextionText,
              displayText: x.nameId(),
              description: x.description(),
              category: categoryByRanges(x.nameId(), node.definition(), x.range())
            };
          });
        }
        if (c) {
          hlnode.definition().allProperties().filter(function (x) {
            return x.getAdapter(parserApi.ds.RAMLPropertyService).isMerged() || x.isFromParentKey();
          }).forEach(function (p) {
            if (onlyKey) {
              if (!p.isFromParentKey()) {
                return;
              }
            }
            if (notAKey) {
              if (p.isFromParentKey()) {
                return;
              }
            }
            var prop = p;
            var oftenKeys = p.getOftenKeys();
            if (!oftenKeys) {
              var sug = p.suggester();
              if (sug) {
                oftenKeys = sug(hlnode);
              }
            }
            if (!oftenKeys) {
              oftenKeys = p.enumOptions();
            }
            if (hlnode.property() && parserApi.universeHelpers.isBodyProperty(hlnode.property())) {
              if (!oftenKeys) {
                if (parserApi.universeHelpers.isResponseType(hlnode.property().domain())) {
                  oftenKeys = [
                    'application/json',
                    'application/xml'
                  ];
                }
                if (parserApi.universeHelpers.isMethodBaseType(hlnode.property().domain()) || parserApi.universeHelpers.isMethodType(hlnode.property().domain())) {
                  oftenKeys = [
                    'application/json',
                    'application/xml',
                    'multipart/form-data',
                    'application/x-www-form-urlencoded'
                  ];
                }
              }
            }
            if (oftenKeys) {
              oftenKeys.forEach(function (y) {
                var original = y;
                var cs = prop.valueDocProvider();
                var description = '';
                if (cs) {
                  description = cs(y);
                }
                if (needColon) {
                  rs.push({
                    text: y + ':' + '\n' + getIndent(offset, text) + '  ',
                    description: description,
                    displayText: y,
                    prefix: y.indexOf('/') >= 0 ? request.valuePrefix() : null,
                    category: categoryByRanges(original, hlnode.definition(), prop.range())
                  });
                } else {
                  rs.push({
                    text: y,
                    description: description,
                    displayText: y,
                    prefix: y.indexOf('/') >= 0 ? request.valuePrefix() : null,
                    category: categoryByRanges(original, hlnode.definition(), prop.range())
                  });
                }
              });
            }
          });
        }
        return rs;
      }
      function valueCompletion(node, attr, request, provider) {
        var hlnode = node;
        var text = request.content.getText();
        var offset = request.content.getOffset();
        if (attr) {
          var p = attr.property();
          var vl = attr.value();
          if (typeof vl === 'object' && vl) {
            var innerNode = vl.toHighLevel();
            if (innerNode) {
              return getSuggestions(provider.currentRequest, provider, findASTNodeByOffset(innerNode, request));
            } else if (parserApi.search.isExampleNodeContent(attr)) {
              var contentType = parserApi.search.findExampleContentType(attr);
              if (contentType) {
                var documentationRoot = parserApi.search.parseDocumentationContent(attr, contentType);
                if (documentationRoot) {
                  return getSuggestions(provider.currentRequest, provider, findASTNodeByOffset(documentationRoot, request));
                }
              }
            }
          }
          if (p) {
            var vls = enumValues(p, hlnode);
            if (p.isAllowNull()) {
              vls.push({
                text: 'null',
                description: 'null means - that no value is allowed'
              });
            }
            if (!vls || vls.length == 0) {
              var oftenKeys = p.getOftenKeys();
              if (oftenKeys) {
                return oftenKeys.map(function (x) {
                  return {
                    text: x,
                    displayText: x
                  };
                });
              }
            }
            if (universeHelpers.isExampleProperty(p) && universeHelpers.isBodyLikeType(hlnode.definition())) {
              if (!testVal(attr.value(), offset, text)) {
                return;
              }
              var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                  x.extra = '!include ./examples/';
                  x.displayText = '!include ./examples/' + x.text;
                  return x;
                });
              rs = addDefineInlineProposal(rs, attr.lowLevel().start(), text);
              return rs;
            }
            if (universeHelpers.isValueProperty(p) && universeHelpers.isGlobalSchemaType(hlnode.definition())) {
              if (!testVal(attr.value(), offset, text)) {
                return;
              }
              rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                x.extra = '!include ./schemas/';
                x.displayText = '!include ./schemas/' + x.text;
                return x;
              });
              rs = addDefineInlineProposal(rs, attr.lowLevel().start(), text);
            }
            if (vls) {
              return vls;
            }
          }
          return [];
        } else {
          //FIXME (To DEF)
          if (universeHelpers.isGlobalSchemaType(hlnode.definition())) {
            rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
              x.extra = '!include ./schemas/';
              x.displayText = '!include ./schemas/' + x.text;
              return x;
            });
            rs = addDefineInlineProposal(rs, hlnode.lowLevel().start(), text);
          }
          if (universeHelpers.isTraitType(hlnode.definition())) {
            rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
              x.extra = '!include ./traits/';
              x.displayText = '!include ./traits/' + x.text;
              return x;
            });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
          }
          if (universeHelpers.isResourceTypeType(hlnode.definition())) {
            var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                x.extra = '!include ./resourceTypes/';
                x.displayText = '!include ./resourceTypes/' + x.text;
                return x;
              });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
          }
          if (universeHelpers.isSecuritySchemaType(hlnode.definition())) {
            var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                x.extra = '!include ./securitySchemes/';
                x.displayText = '!include ./securitySchemes/' + x.text;
                return x;
              });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
          }
          if (universeHelpers.isExampleSpecType(hlnode.definition())) {
            return examplePropertyCompletion(hlnode, request, provider);
          }
        }
      }
      exports.valueCompletion = valueCompletion;
      function findASTNodeByOffset(ast, request) {
        var text = request.content.getText();
        var cm = request.content.getOffset();
        for (var pm = cm - 1; pm >= 0; pm--) {
          var c = text[pm];
          if (c == ' ' || c == '\t') {
            cm = pm;
            continue;
          }
          break;
        }
        var astNode = ast.findElementAtOffset(cm);
        return astNode;
      }
      function enumValues(property, parentNode) {
        if (parentNode) {
          if (property.getAdapter(parserApi.ds.RAMLPropertyService).isTypeExpr()) {
            var associatedType = parentNode.associatedType();
            var parentDefinition = parentNode.definition();
            var noArraysOrPrimitives;
            var typeProperty = parentNode.attr(parserApi.universes.Universe10.TypeDeclaration.properties.type.name);
            var typePropertyValue = typeProperty && typeProperty.value();
            var typeProperties = parentNode.children() && parentNode.children().filter(function (child) {
                return child.isAttr() && parserApi.universeHelpers.isTypeProperty(child.property());
              });
            var definitionNodes = parserApi.search.globalDeclarations(parentNode).filter(function (node) {
                if (parserApi.universeHelpers.isGlobalSchemaType(node.definition())) {
                  return true;
                }
                var superTypesOfProposed = node.definition().allSuperTypes();
                if (_.find(superTypesOfProposed, function (supertype) {
                    return parserApi.universeHelpers.isTypeDeclarationType(supertype);
                  })) {
                  var isMultiValue = typePropertyValue && property && property.isMultiValue() && typeProperties && typeProperties.length > 1;
                  if (isMultiValue) {
                    if (!associatedType) {
                      try {
                        associatedType = parentNode.localType();
                      } catch (exception) {
                        console.log(exception);
                      }
                    }
                    if (associatedType && !parentDefinition.hasUnionInHierarchy()) {
                      var supertypes = associatedType.superTypes().filter(function (supertype) {
                          return !supertype.isAssignableFrom('unknown');
                        });
                      if (supertypes) {
                        var isExtendsObject = _.find(supertypes, function (supertype) {
                            return isObject(supertype);
                          });
                        var isExtendsPrimitive = _.find(supertypes, function (supertype) {
                            return isPrimitive(supertype);
                          });
                        var isExtendsArray = _.find(supertypes, function (supertype) {
                            return isArray(supertype);
                          }) || parentDefinition && isArray(parentDefinition);
                        var noObjects = isExtendsArray || isExtendsPrimitive;
                        noArraysOrPrimitives = isExtendsObject || noObjects;
                        if (_.find(supertypes, function (supertype) {
                            return parserApi.search.qName(node, parentNode) === supertype.nameId();
                          })) {
                          return false;
                        }
                        if (noArraysOrPrimitives && (isPrimitive(node.definition()) || isArray(node.definition()))) {
                          return false;
                        }
                        if (noObjects && isObject(node.definition())) {
                          return false;
                        }
                      }
                    }
                    if (parentDefinition.hasUnionInHierarchy()) {
                      var unionClasses = allClassesForUnion(parentDefinition);
                      if (_.find(unionClasses, function (unionPart) {
                          return parserApi.search.qName(node, parentNode) === unionPart.nameId();
                        })) {
                        return false;
                      }
                    }
                  }
                  return true;
                }
                return universeHelpers.isTypeDeclarationType(node.definition()) && node.property().nameId() === 'models';
              });
            var result = definitionNodes.map(function (node) {
                return {
                  text: search.qName(node, parentNode),
                  description: ''
                };
              });
            var typeDeclarationType = property.domain().universe().type('TypeDeclaration');
            //var annotationTypeDeclaration = property.domain().universe().type("AnnotationTypeDeclaration");
            if (typeDeclarationType) {
              var subTypes = typeDeclarationType.allSubTypes();
              result = result.concat(subTypes.filter(function (subType) {
                if (noArraysOrPrimitives && (isPrimitive(subType) || isArray(subType))) {
                  return false;
                }
                return true;
              }).map(function (subType) {
                return {
                  text: subType.getAdapter(services.RAMLService).descriminatorValue(),
                  description: subType.description()
                };
              }));
            }
            return result;
          }
          if (universeHelpers.isSchemaStringType(property.range())) {
            if (property.range().universe().version() === 'RAML10') {
              var definitionNodes = search.globalDeclarations(parentNode).filter(function (node) {
                  if (universeHelpers.isGlobalSchemaType(node.definition())) {
                    return true;
                  }
                  var superTypesOfProposed = node.definition().allSuperTypes();
                  if (_.find(superTypesOfProposed, function (x) {
                      return universeHelpers.isTypeDeclarationType(x);
                    })) {
                    return true;
                  }
                  return universeHelpers.isTypeDeclarationType(node.definition()) && node.property().nameId() === 'models';
                });
              var result = definitionNodes.map(function (node) {
                  return {
                    text: search.qName(node, parentNode),
                    description: ''
                  };
                });
              var subTypes = search.subTypesWithLocals(property.domain().universe().type('TypeDeclaration'), parentNode);
              result = result.concat(subTypes.map(function (subType) {
                return {
                  text: subType.getAdapter(services.RAMLService).descriminatorValue(),
                  description: subType.description()
                };
              }));
              return result;
            }
          }
          if (property.isDescriminator()) {
            var subTypes = search.subTypesWithLocals(property.domain(), parentNode);
            return subTypes.map(function (subType) {
              var suggestionText = subType.getAdapter(services.RAMLService).descriminatorValue();
              return {
                text: suggestionText,
                description: subType.description(),
                category: categoryByRanges(suggestionText, property.domain(), null)
              };
            });
          }
          if (property.isReference()) {
            return search.nodesDeclaringType(property.referencesTo(), parentNode).map(function (subType) {
              return nodeToProposalInfo(subType, parentNode);
            });
          }
          if (property.range().hasValueTypeInHierarchy()) {
            var valueTypeAdapter = property.range().getAdapter(services.RAMLService);
            if (valueTypeAdapter.globallyDeclaredBy().length > 0) {
              var definitionNodes = search.globalDeclarations(parentNode).filter(function (proposedNode) {
                  var proposedDefinition = proposedNode.definition();
                  return _.find(valueTypeAdapter.globallyDeclaredBy(), function (globalDefinition) {
                    return globalDefinition == proposedDefinition;
                  }) != null;
                });
              return definitionNodes.map(function (proposedNode) {
                return nodeToProposalInfo(proposedNode, parentNode);
              });
            }
            if (universeHelpers.isBooleanTypeType(property.range())) {
              return [
                'false',
                'true'
              ].map(function (value) {
                return { text: value };
              });
            }
            var propertyNode = property.node && property.node();
            if (propertyNode) {
              var suggestions = _.filter(propertyNode.children(), function (child) {
                  return child.name && child.value && child.property() && universeHelpers.isEnumProperty(child.property());
                }).map(function (child) {
                  return { text: child.value() };
                });
              return suggestions;
            }
          }
        }
        return search.enumValues(property, parentNode).map(function (proposed) {
          return {
            text: proposed,
            category: categoryByRanges(proposed, parentNode && parentNode.definition(), null)
          };
        });
      }
      function isPrimitive(definition) {
        var isPrimitive = !definition.isArray() && !isObject(definition) && !definition.hasUnionInHierarchy() && definition.key() !== universeModule.Universe10.TypeDeclaration;
        return isPrimitive;
      }
      function isObject(definition) {
        return definition.isAssignableFrom(universeModule.Universe10.ObjectTypeDeclaration.name) || definition.isAssignableFrom('object');
      }
      function isArray(definition) {
        return definition.isAssignableFrom(universeModule.Universe10.ArrayTypeDeclaration.name);
      }
      function allClassesForUnion(definition) {
        var result = [];
        if (!definition || !definition.isUnion()) {
          return definition ? [definition] : result;
        }
        if (definition.left) {
          result.push(definition.left);
          return result.concat(allClassesForUnion(definition.right));
        }
      }
      function addDefineInlineProposal(rs, offset, text) {
        rs = [{
            displayText: 'Define Inline',
            text: '|\n' + leadingIndent(offset - 1, text) + '  '
          }].concat(rs);
        return rs;
      }
      function addDefineInlineProposal2(rs, offset, text) {
        rs = [{
            displayText: 'Define Inline',
            text: '\n' + leadingIndent(offset - 1, text) + '  '
          }].concat(rs);
        return rs;
      }
      function leadingIndent(pos, text) {
        var leading = '';
        while (pos > 0) {
          var ch = text[pos];
          if (ch == '\r' || ch == '\n' || ch != ' ' && ch != '-')
            break;
          leading = leading + ' ';
          pos--;
        }
        return leading;
      }
      ;
      function getProposalText(proposal) {
        if (proposal.text) {
          return proposal.text;
        }
        if (proposal.snippet) {
          return proposal.snippet;
        }
        return proposal.displayText;
      }
      function updateProposalText(proposal, textToUpdateWith) {
        if (proposal.text) {
          proposal.text = textToUpdateWith;
          return;
        }
        if (proposal.snippet) {
          proposal.snippet = textToUpdateWith;
          return;
        }
        proposal.displayText = textToUpdateWith;
      }
      function isSiblingExists(attr, siblingName) {
        var parent = attr.parent && attr.parent();
        if (!parent) {
          return false;
        }
        var propertyName = attr.name && attr.name();
        if (!propertyName) {
          return false;
        }
        var siblings = parent.attributes && parent.attributes(propertyName);
        if (!siblings) {
          return false;
        }
        if (siblings.length === 0) {
          return false;
        }
        var names = [];
        siblings.forEach(function (sibling) {
          var name = sibling.value && sibling.value() && sibling.value().valueName && sibling.value().valueName();
          if (!name) {
            return;
          }
          names.push(name);
        });
        return _.find(names, function (name) {
          return siblingName === name;
        });
      }
      function isSquareBracketExpected(attr) {
        if (!attr) {
          return false;
        }
        if (!attr.definition()) {
          return false;
        }
        if (!attr.property()) {
          return false;
        }
        if (!attr.definition().isAssignableFrom(universeModule.Universe10.TraitRef.name)) {
          return false;
        }
        return true;
      }
      function isInResourceDescription(obj) {
        var definition = obj && obj.definition ? obj.definition() : null;
        if (definition) {
          var name = definition.nameId();
          if (name === 'Api') {
            return false;
          }
          if (name === 'ResourceType' || name === 'Trait') {
            return true;
          }
          var parent = obj.parent();
          if (!parent) {
            return false;
          }
          return isInResourceDescription(parent);
        }
        return false;
      }
      var transformers = parserApi.utils.getTransformerNames();
      var addTransformers = function (proposals, prefix) {
        var result = [];
        transformers.filter(function (transformer) {
          return transformer.indexOf(prefix) === 0;
        }).forEach(function (transformer) {
          result.push({
            displayText: transformer,
            text: transformer
          });
        });
        return result.concat(proposals);
      };
      function testVal(vl, offset, text) {
        if (vl && vl.length > 0) {
          var q = vl.trim();
          if (q.indexOf('{') == 0) {
            return false;
          }
          if (q.indexOf('<') == 0) {
            return false;
          }
          if (q.indexOf('[') == 0) {
            return false;
          }
        }
        for (var i = offset; i >= 0; i--) {
          var c = text[i];
          if (c == ':') {
            return true;
          }
          if (c == '|') {
            return false;
          }
          if (c == '\'') {
            return false;
          }
          if (c == '"') {
            return false;
          }
        }
        return true;
      }
      function nodeToProposalInfo(x, c) {
        var isResourceType = false;
        var d = x.attr('description');
        var ds = '';
        if (d) {
          ds = d.value();
        } else {
          d = x.attr('usage');
          if (d) {
            ds = d.value();
          }
        }
        var tr = x.localType();
        var req = tr.allProperties().filter(function (x) {
            return x.isRequired() && !x.getAdapter(services.RAMLPropertyService).isKey();
          });
        var txt = search.qName(x, c);
        if (!universeHelpers.isAnnotationTypeType(x.definition())) {
          if (req.length > 0) {
            txt += ': {';
            txt += req.map(function (x) {
              return x.nameId() + ' : ';
            }).join(', ') + '}';
            var extra = '';
            if (universeHelpers.isResourceTypeType(x.definition())) {
              txt = '' + txt + ' }';
              extra = ' { ';
              isResourceType = true;
            }
          }
        }
        return {
          displayText: search.qName(x, c),
          snippet: txt,
          description: ds,
          extra: extra,
          isResourceType: isResourceType
        };
      }
      function examplePropertyCompletion(node, request, provider) {
        if (!search.isExampleNode(node)) {
          return [];
        }
        var contentType = search.findExampleContentType(node);
        if (!contentType)
          return [];
        var parsedExample = search.parseStructuredExample(node, contentType);
        if (!parsedExample)
          return [];
        return getSuggestions(request, provider, findASTNodeByOffset(parsedExample, request));
      }
      function postProcess(providerSuggestions, request) {
        var prepared = postProcess1(providerSuggestions, request);
        var added = [];
        var result = [];
        prepared.forEach(function (item) {
          var value = suggestionValue(item);
          if (added.indexOf(value) < 0) {
            result.push(item);
            added.push(value);
          }
        });
        return result;
      }
      exports.postProcess = postProcess;
      function postProcess1(providerSuggestions, request) {
        var hasDeprecations, hasEmpty, suggestion, _i, _len;
        if (providerSuggestions == null) {
          return;
        }
        if (hasDeprecations) {
          providerSuggestions = providerSuggestions.map(function (suggestion) {
            var newSuggestion, _ref1, _ref2;
            newSuggestion = {
              text: (_ref1 = suggestion.text) != null ? _ref1 : suggestion.word,
              snippet: suggestion.snippet,
              replacementPrefix: (_ref2 = suggestion.replacementPrefix) != null ? _ref2 : suggestion.prefix,
              className: suggestion.className,
              type: suggestion.type
            };
            if (newSuggestion.rightLabelHTML == null && suggestion.renderLabelAsHtml) {
              newSuggestion.rightLabelHTML = suggestion.label;
            }
            if (newSuggestion.rightLabel == null && !suggestion.renderLabelAsHtml) {
              newSuggestion.rightLabel = suggestion.label;
            }
            return newSuggestion;
          });
        }
        hasEmpty = false;
        for (_i = 0, _len = providerSuggestions.length; _i < _len; _i++) {
          suggestion = providerSuggestions[_i];
          if (!(suggestion.snippet || suggestion.text)) {
            hasEmpty = true;
          }
          if (suggestion.replacementPrefix == null) {
            suggestion.replacementPrefix = getDefaultReplacementPrefix(request.prefix());
          }
        }
        if (hasEmpty) {
          providerSuggestions = function () {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = providerSuggestions.length; _j < _len1; _j++) {
              suggestion = providerSuggestions[_j];
              if (suggestion.snippet || suggestion.text) {
                _results.push(suggestion);
              }
            }
            return _results;
          }();
        }
        providerSuggestions = filterSuggestions(providerSuggestions, request);
        return providerSuggestions;
      }
      var fuzzaldrinProvider = require('fuzzaldrin-plus');
      function filterSuggestions(suggestions, _arg) {
        var firstCharIsMatch, i, prefix, prefixIsEmpty, results, score, suggestion, suggestionPrefix, text, _i, _len, _ref1;
        prefix = _arg.prefix();
        results = [];
        for (i = _i = 0, _len = suggestions.length; _i < _len; i = ++_i) {
          suggestion = suggestions[i];
          suggestion.sortScore = Math.max(-i / 10 + 3, 0) + 1;
          suggestion.score = null;
          text = suggestion.snippet || suggestion.text;
          suggestionPrefix = (_ref1 = suggestion.replacementPrefix) != null ? _ref1 : prefix;
          prefixIsEmpty = !suggestionPrefix || suggestionPrefix === ' ';
          firstCharIsMatch = !prefixIsEmpty && suggestionPrefix[0].toLowerCase() === text[0].toLowerCase();
          if (prefixIsEmpty) {
            results.push(suggestion);
          }
          if (firstCharIsMatch && (score = fuzzaldrinProvider.score(text, suggestionPrefix)) > 0) {
            suggestion.score = score * suggestion.sortScore;
            results.push(suggestion);
          }
        }
        results.sort(reverseSortOnScoreComparator);
        return results;
      }
      var wordPrefixRegex = /^\w+[\w-]*$/;
      function reverseSortOnScoreComparator(a, b) {
        var _ref1, _ref2;
        return ((_ref1 = b.score) != null ? _ref1 : b.sortScore) - ((_ref2 = a.score) != null ? _ref2 : a.sortScore);
      }
      ;
      function getDefaultReplacementPrefix(prefix) {
        if (wordPrefixRegex.test(prefix)) {
          return prefix;
        } else {
          return '';
        }
      }
      ;
      function suggestionValue(suggestion) {
        return suggestion && (suggestion.displayText || suggestion.text) || null;
      }
      var prefixRegex = /(\b|['"~`!@#\$%^&*\(\)\{\}\[\]=\+,\/\?>])((\w+[\w-]*)|([.:;[{(< ]+))$/;
      function getPrefix(request) {
        var line, _ref1;
        line = getLine(request);
        return ((_ref1 = prefixRegex.exec(line)) != null ? _ref1[2] : void 0) || '';
      }
      exports.getPrefix = getPrefix;
      function getLine(request) {
        var offset = request.content.getOffset();
        var text = request.content.getText();
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c === '\r' || c === '\n' || c === ' ' || c === '\t') {
            return text.substring(i + 1, offset);
          }
        }
        return '';
      }
      var ResolvedProvider = function () {
          function ResolvedProvider(resolver) {
            this.resolver = resolver;
            this.fsResolver = resolver;
          }
          ResolvedProvider.prototype.contentDirName = function (content) {
            return this.resolver.dirname(content.getPath());
          };
          ResolvedProvider.prototype.dirName = function (path) {
            return this.resolver.dirname(path);
          };
          ResolvedProvider.prototype.exists = function (path) {
            return this.resolver.exists(path);
          };
          ResolvedProvider.prototype.resolve = function (contextPath, relativePath) {
            return this.resolver.resolve(contextPath, relativePath);
          };
          ResolvedProvider.prototype.isDirectory = function (path) {
            return this.resolver.isDirectory(path);
          };
          ResolvedProvider.prototype.isDirectoryAsync = function (path) {
            return this.resolver.isDirectoryAsync(path);
          };
          ResolvedProvider.prototype.readDir = function (path) {
            return this.resolver.list(path);
          };
          ResolvedProvider.prototype.existsAsync = function (path) {
            return this.resolver.existsAsync(path);
          };
          ResolvedProvider.prototype.readDirAsync = function (path) {
            return this.resolver.listAsync(path);
          };
          return ResolvedProvider;
        }();
      function getContentProvider(resolver) {
        return new ResolvedProvider(resolver);
      }
      exports.getContentProvider = getContentProvider;
    },
    {
      '../resources/categories.json': 11,
      'fuzzaldrin-plus': 2,
      'underscore': 12
    }
  ],
  10: [
    function (require, module, exports) {
      'use strict';
      var completionProvider = require('./completionProvider');
      var _editorStateProvider = null;
      /**
 * Sets default editor state provider
 * @param editorStateProvider
 */
      function setDefaultEditorStateProvider(editorStateProvider) {
        _editorStateProvider = editorStateProvider;
      }
      exports.setDefaultEditorStateProvider = setDefaultEditorStateProvider;
      var _fsProvider = null;
      /**
 * Sets default FS provider.
 * @param fsProvider
 */
      function setDefaultFSProvider(fsProvider) {
        _fsProvider = fsProvider;
      }
      exports.setDefaultFSProvider = setDefaultFSProvider;
      /**
 * Finds suggestions. Requires setDefaultEditorStateProvider and setDefaultFSProvider methods to be called first.
 * @returns {Suggestion[]} - list of suggestions
 */
      function suggestDefault() {
        return completionProvider.suggest(_editorStateProvider, _fsProvider);
      }
      exports.suggestDefault = suggestDefault;
      /**
 * Finds suggestions.
 * @param editorState - editor state.
 * @param fsProvider - file system data provider.
 * @returns {Suggestion[]} - list of suggestions
 */
      function suggest(editorStateProvider, fsProvider) {
        return completionProvider.suggest(editorStateProvider, fsProvider);
      }
      exports.suggest = suggest;
      /**
 * Finds suggestions.
 * @param editorState - editor state.
 * @param fsProvider - file system data provider.
 * @returns {Promise<Suggestion[]>}
 */
      function suggestAsync(editorState, fsProvider) {
        return completionProvider.suggestAsync(editorState, fsProvider);
      }
      exports.suggestAsync = suggestAsync;
      /**
 * Converts extended fs resolver to FS provider.
 * @param resolver
 * @returns {IFSProvider}
 */
      function getContentProvider(resolver) {
        return completionProvider.getContentProvider(resolver);
      }
      exports.getContentProvider = getContentProvider;
    },
    { './completionProvider': 9 }
  ],
  11: [
    function (require, module, exports) {
      module.exports = {
        'docs': {
          'description': {
            'is': [
              'Universe10.MarkdownString',
              'Universe08.MarkdownString'
            ]
          },
          'displayName': {
            'parentIs': [
              'Universe10.ExampleSpec',
              'Universe10.TypeDeclaration',
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.AbstractSecurityScheme',
              'Universe10.ResourceType',
              'Universe10.Resource',
              'Universe08.Parameter',
              'Universe08.Resource',
              'Universe08.ResourceType',
              'Universe08.Trait'
            ]
          },
          'example': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter',
              'Universe08.BodyLike',
              'Universe08.XMLBody',
              'Universe08.JSONBody'
            ]
          },
          'usage': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe10.Trait',
              'Universe10.ResourceType',
              'Universe08.ResourceType',
              'Universe08.Trait'
            ]
          },
          'content': {
            'parentIs': [
              'Universe10.DocumentationItem',
              'Universe08.DocumentationItem'
            ]
          },
          'documentation': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'title': {
            'parentIs': [
              'Universe10.DocumentationItem',
              'Universe08.DocumentationItem'
            ]
          }
        },
        'parameters': {
          'default': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'enum': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'maximum': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'minimum': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'maxLength': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'minLength': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'required': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'baseUriParameters': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api',
              'Universe08.Resource',
              'Universe08.ResourceType',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'uriParameters': {
            'parentIs': [
              'Universe10.ResourceType',
              'Universe10.ResourceBase',
              'Universe10.Resource',
              'Universe08.Api',
              'Universe08.Resource',
              'Universe08.ResourceType'
            ]
          },
          'headers': {
            'parentIs': [
              'Universe10.Response',
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.Operation',
              'Universe10.AbstractSecurityScheme',
              'Universe08.Response',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'queryParameters': {
            'parentIs': [
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.Operation',
              'Universe10.AbstractSecurityScheme',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'type': { 'parentIs': ['Universe08.Parameter'] }
        },
        'schemas': {
          'schema': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike',
              'Universe08.XMLBody',
              'Universe08.JSONBody'
            ]
          },
          'schemas': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          }
        },
        'root': {
          'baseUri': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'mediaType': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'protocols': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe08.Api',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'version': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'title': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          }
        },
        'responses': {
          'responses': {
            'parentIs': [
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.Operation',
              'Universe10.AbstractSecurityScheme',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          }
        },
        'response': {
          'body': {
            'parentIs': [
              'Universe10.Response',
              'Universe08.Response'
            ]
          }
        },
        'security': {
          'securedBy': {
            'is': [
              'Universe10.SecuritySchemeRef',
              'Universe08.SecuritySchemeRef'
            ]
          },
          'securitySchemes': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'accessTokenUri': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'authorizationGrants': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'authorizationUri': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'requestTokenUri': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'scopes': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'describedBy': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'settings': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'OAuth 1.0': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'OAuth 2.0': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'Basic Authentication': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'Digest Authentication': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'type': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          }
        },
        'types and traits': {
          'type': {
            'parentIs': [
              'Universe10.ResourceType',
              'Universe10.ResourceBase',
              'Universe10.Resource',
              'Universe08.Resource',
              'Universe08.ResourceType'
            ]
          },
          'is': {
            'is': [
              'Universe10.TraitRef',
              'Universe08.TraitRef'
            ]
          },
          'resourceTypes': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'traits': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          }
        },
        'methods': {
          'options': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'get': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'head': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'post': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'put': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'delete': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'trace': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'connect': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'patch': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          }
        },
        'protocols': {
          'HTTP': {
            'parentIs': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'HTTPS': {
            'parentIs': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          }
        },
        'body': {
          'application/json': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'application/x-www-form-urlencoded': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'application/xml': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'multipart/form-data': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'body': {
            'parentIs': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          }
        }
      };
    },
    {}
  ],
  12: [
    function (require, module, exports) {
      //     Underscore.js 1.8.3
      //     http://underscorejs.org
      //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      //     Underscore may be freely distributed under the MIT license.
      (function () {
        // Baseline setup
        // --------------
        // Establish the root object, `window` in the browser, or `exports` on the server.
        var root = this;
        // Save the previous value of the `_` variable.
        var previousUnderscore = root._;
        // Save bytes in the minified (but not gzipped) version:
        var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
        // Create quick reference variables for speed access to core prototypes.
        var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
        // All **ECMAScript 5** native function implementations that we hope to use
        // are declared here.
        var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create;
        // Naked function reference for surrogate-prototype-swapping.
        var Ctor = function () {
        };
        // Create a safe reference to the Underscore object for use below.
        var _ = function (obj) {
          if (obj instanceof _)
            return obj;
          if (!(this instanceof _))
            return new _(obj);
          this._wrapped = obj;
        };
        // Export the Underscore object for **Node.js**, with
        // backwards-compatibility for the old `require()` API. If we're in
        // the browser, add `_` as a global object.
        if (typeof exports !== 'undefined') {
          if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
          }
          exports._ = _;
        } else {
          root._ = _;
        }
        // Current version.
        _.VERSION = '1.8.3';
        // Internal function that returns an efficient (for current engines) version
        // of the passed-in callback, to be repeatedly applied in other Underscore
        // functions.
        var optimizeCb = function (func, context, argCount) {
          if (context === void 0)
            return func;
          switch (argCount == null ? 3 : argCount) {
          case 1:
            return function (value) {
              return func.call(context, value);
            };
          case 2:
            return function (value, other) {
              return func.call(context, value, other);
            };
          case 3:
            return function (value, index, collection) {
              return func.call(context, value, index, collection);
            };
          case 4:
            return function (accumulator, value, index, collection) {
              return func.call(context, accumulator, value, index, collection);
            };
          }
          return function () {
            return func.apply(context, arguments);
          };
        };
        // A mostly-internal function to generate callbacks that can be applied
        // to each element in a collection, returning the desired result  either
        // identity, an arbitrary callback, a property matcher, or a property accessor.
        var cb = function (value, context, argCount) {
          if (value == null)
            return _.identity;
          if (_.isFunction(value))
            return optimizeCb(value, context, argCount);
          if (_.isObject(value))
            return _.matcher(value);
          return _.property(value);
        };
        _.iteratee = function (value, context) {
          return cb(value, context, Infinity);
        };
        // An internal function for creating assigner functions.
        var createAssigner = function (keysFunc, undefinedOnly) {
          return function (obj) {
            var length = arguments.length;
            if (length < 2 || obj == null)
              return obj;
            for (var index = 1; index < length; index++) {
              var source = arguments[index], keys = keysFunc(source), l = keys.length;
              for (var i = 0; i < l; i++) {
                var key = keys[i];
                if (!undefinedOnly || obj[key] === void 0)
                  obj[key] = source[key];
              }
            }
            return obj;
          };
        };
        // An internal function for creating a new object that inherits from another.
        var baseCreate = function (prototype) {
          if (!_.isObject(prototype))
            return {};
          if (nativeCreate)
            return nativeCreate(prototype);
          Ctor.prototype = prototype;
          var result = new Ctor();
          Ctor.prototype = null;
          return result;
        };
        var property = function (key) {
          return function (obj) {
            return obj == null ? void 0 : obj[key];
          };
        };
        // Helper for collection methods to determine whether a collection
        // should be iterated as an array or as an object
        // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
        // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
        var getLength = property('length');
        var isArrayLike = function (collection) {
          var length = getLength(collection);
          return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
        };
        // Collection Functions
        // --------------------
        // The cornerstone, an `each` implementation, aka `forEach`.
        // Handles raw objects in addition to array-likes. Treats all
        // sparse array-likes as if they were dense.
        _.each = _.forEach = function (obj, iteratee, context) {
          iteratee = optimizeCb(iteratee, context);
          var i, length;
          if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; i++) {
              iteratee(obj[i], i, obj);
            }
          } else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; i < length; i++) {
              iteratee(obj[keys[i]], keys[i], obj);
            }
          }
          return obj;
        };
        // Return the results of applying the iteratee to each element.
        _.map = _.collect = function (obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
          for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
        };
        // Create a reducing function iterating left or right.
        function createReduce(dir) {
          // Optimized iterator function as using arguments.length
          // in the main function will deoptimize the, see #1991.
          function iterator(obj, iteratee, memo, keys, index, length) {
            for (; index >= 0 && index < length; index += dir) {
              var currentKey = keys ? keys[index] : index;
              memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
          }
          return function (obj, iteratee, memo, context) {
            iteratee = optimizeCb(iteratee, context, 4);
            var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
            // Determine the initial value if none is provided.
            if (arguments.length < 3) {
              memo = obj[keys ? keys[index] : index];
              index += dir;
            }
            return iterator(obj, iteratee, memo, keys, index, length);
          };
        }
        // **Reduce** builds up a single result from a list of values, aka `inject`,
        // or `foldl`.
        _.reduce = _.foldl = _.inject = createReduce(1);
        // The right-associative version of reduce, also known as `foldr`.
        _.reduceRight = _.foldr = createReduce(-1);
        // Return the first value which passes a truth test. Aliased as `detect`.
        _.find = _.detect = function (obj, predicate, context) {
          var key;
          if (isArrayLike(obj)) {
            key = _.findIndex(obj, predicate, context);
          } else {
            key = _.findKey(obj, predicate, context);
          }
          if (key !== void 0 && key !== -1)
            return obj[key];
        };
        // Return all the elements that pass a truth test.
        // Aliased as `select`.
        _.filter = _.select = function (obj, predicate, context) {
          var results = [];
          predicate = cb(predicate, context);
          _.each(obj, function (value, index, list) {
            if (predicate(value, index, list))
              results.push(value);
          });
          return results;
        };
        // Return all the elements for which a truth test fails.
        _.reject = function (obj, predicate, context) {
          return _.filter(obj, _.negate(cb(predicate)), context);
        };
        // Determine whether all of the elements match a truth test.
        // Aliased as `all`.
        _.every = _.all = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj))
              return false;
          }
          return true;
        };
        // Determine if at least one element in the object matches a truth test.
        // Aliased as `any`.
        _.some = _.any = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj))
              return true;
          }
          return false;
        };
        // Determine if the array or object contains a given item (using `===`).
        // Aliased as `includes` and `include`.
        _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
          if (!isArrayLike(obj))
            obj = _.values(obj);
          if (typeof fromIndex != 'number' || guard)
            fromIndex = 0;
          return _.indexOf(obj, item, fromIndex) >= 0;
        };
        // Invoke a method (with arguments) on every item in a collection.
        _.invoke = function (obj, method) {
          var args = slice.call(arguments, 2);
          var isFunc = _.isFunction(method);
          return _.map(obj, function (value) {
            var func = isFunc ? method : value[method];
            return func == null ? func : func.apply(value, args);
          });
        };
        // Convenience version of a common use case of `map`: fetching a property.
        _.pluck = function (obj, key) {
          return _.map(obj, _.property(key));
        };
        // Convenience version of a common use case of `filter`: selecting only objects
        // containing specific `key:value` pairs.
        _.where = function (obj, attrs) {
          return _.filter(obj, _.matcher(attrs));
        };
        // Convenience version of a common use case of `find`: getting the first object
        // containing specific `key:value` pairs.
        _.findWhere = function (obj, attrs) {
          return _.find(obj, _.matcher(attrs));
        };
        // Return the maximum element (or element-based computation).
        _.max = function (obj, iteratee, context) {
          var result = -Infinity, lastComputed = -Infinity, value, computed;
          if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value > result) {
                result = value;
              }
            }
          } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function (value, index, list) {
              computed = iteratee(value, index, list);
              if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                result = value;
                lastComputed = computed;
              }
            });
          }
          return result;
        };
        // Return the minimum element (or element-based computation).
        _.min = function (obj, iteratee, context) {
          var result = Infinity, lastComputed = Infinity, value, computed;
          if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value < result) {
                result = value;
              }
            }
          } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function (value, index, list) {
              computed = iteratee(value, index, list);
              if (computed < lastComputed || computed === Infinity && result === Infinity) {
                result = value;
                lastComputed = computed;
              }
            });
          }
          return result;
        };
        // Shuffle a collection, using the modern version of the
        // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
        _.shuffle = function (obj) {
          var set = isArrayLike(obj) ? obj : _.values(obj);
          var length = set.length;
          var shuffled = Array(length);
          for (var index = 0, rand; index < length; index++) {
            rand = _.random(0, index);
            if (rand !== index)
              shuffled[index] = shuffled[rand];
            shuffled[rand] = set[index];
          }
          return shuffled;
        };
        // Sample **n** random values from a collection.
        // If **n** is not specified, returns a single random element.
        // The internal `guard` argument allows it to work with `map`.
        _.sample = function (obj, n, guard) {
          if (n == null || guard) {
            if (!isArrayLike(obj))
              obj = _.values(obj);
            return obj[_.random(obj.length - 1)];
          }
          return _.shuffle(obj).slice(0, Math.max(0, n));
        };
        // Sort the object's values by a criterion produced by an iteratee.
        _.sortBy = function (obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          return _.pluck(_.map(obj, function (value, index, list) {
            return {
              value: value,
              index: index,
              criteria: iteratee(value, index, list)
            };
          }).sort(function (left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
              if (a > b || a === void 0)
                return 1;
              if (a < b || b === void 0)
                return -1;
            }
            return left.index - right.index;
          }), 'value');
        };
        // An internal function used for aggregate "group by" operations.
        var group = function (behavior) {
          return function (obj, iteratee, context) {
            var result = {};
            iteratee = cb(iteratee, context);
            _.each(obj, function (value, index) {
              var key = iteratee(value, index, obj);
              behavior(result, value, key);
            });
            return result;
          };
        };
        // Groups the object's values by a criterion. Pass either a string attribute
        // to group by, or a function that returns the criterion.
        _.groupBy = group(function (result, value, key) {
          if (_.has(result, key))
            result[key].push(value);
          else
            result[key] = [value];
        });
        // Indexes the object's values by a criterion, similar to `groupBy`, but for
        // when you know that your index values will be unique.
        _.indexBy = group(function (result, value, key) {
          result[key] = value;
        });
        // Counts instances of an object that group by a certain criterion. Pass
        // either a string attribute to count by, or a function that returns the
        // criterion.
        _.countBy = group(function (result, value, key) {
          if (_.has(result, key))
            result[key]++;
          else
            result[key] = 1;
        });
        // Safely create a real, live array from anything iterable.
        _.toArray = function (obj) {
          if (!obj)
            return [];
          if (_.isArray(obj))
            return slice.call(obj);
          if (isArrayLike(obj))
            return _.map(obj, _.identity);
          return _.values(obj);
        };
        // Return the number of elements in an object.
        _.size = function (obj) {
          if (obj == null)
            return 0;
          return isArrayLike(obj) ? obj.length : _.keys(obj).length;
        };
        // Split a collection into two arrays: one whose elements all satisfy the given
        // predicate, and one whose elements all do not satisfy the predicate.
        _.partition = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var pass = [], fail = [];
          _.each(obj, function (value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
          });
          return [
            pass,
            fail
          ];
        };
        // Array Functions
        // ---------------
        // Get the first element of an array. Passing **n** will return the first N
        // values in the array. Aliased as `head` and `take`. The **guard** check
        // allows it to work with `_.map`.
        _.first = _.head = _.take = function (array, n, guard) {
          if (array == null)
            return void 0;
          if (n == null || guard)
            return array[0];
          return _.initial(array, array.length - n);
        };
        // Returns everything but the last entry of the array. Especially useful on
        // the arguments object. Passing **n** will return all the values in
        // the array, excluding the last N.
        _.initial = function (array, n, guard) {
          return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
        };
        // Get the last element of an array. Passing **n** will return the last N
        // values in the array.
        _.last = function (array, n, guard) {
          if (array == null)
            return void 0;
          if (n == null || guard)
            return array[array.length - 1];
          return _.rest(array, Math.max(0, array.length - n));
        };
        // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
        // Especially useful on the arguments object. Passing an **n** will return
        // the rest N values in the array.
        _.rest = _.tail = _.drop = function (array, n, guard) {
          return slice.call(array, n == null || guard ? 1 : n);
        };
        // Trim out all falsy values from an array.
        _.compact = function (array) {
          return _.filter(array, _.identity);
        };
        // Internal implementation of a recursive `flatten` function.
        var flatten = function (input, shallow, strict, startIndex) {
          var output = [], idx = 0;
          for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
            var value = input[i];
            if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
              //flatten current level of array or arguments object
              if (!shallow)
                value = flatten(value, shallow, strict);
              var j = 0, len = value.length;
              output.length += len;
              while (j < len) {
                output[idx++] = value[j++];
              }
            } else if (!strict) {
              output[idx++] = value;
            }
          }
          return output;
        };
        // Flatten out an array, either recursively (by default), or just one level.
        _.flatten = function (array, shallow) {
          return flatten(array, shallow, false);
        };
        // Return a version of the array that does not contain the specified value(s).
        _.without = function (array) {
          return _.difference(array, slice.call(arguments, 1));
        };
        // Produce a duplicate-free version of the array. If the array has already
        // been sorted, you have the option of using a faster algorithm.
        // Aliased as `unique`.
        _.uniq = _.unique = function (array, isSorted, iteratee, context) {
          if (!_.isBoolean(isSorted)) {
            context = iteratee;
            iteratee = isSorted;
            isSorted = false;
          }
          if (iteratee != null)
            iteratee = cb(iteratee, context);
          var result = [];
          var seen = [];
          for (var i = 0, length = getLength(array); i < length; i++) {
            var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
            if (isSorted) {
              if (!i || seen !== computed)
                result.push(value);
              seen = computed;
            } else if (iteratee) {
              if (!_.contains(seen, computed)) {
                seen.push(computed);
                result.push(value);
              }
            } else if (!_.contains(result, value)) {
              result.push(value);
            }
          }
          return result;
        };
        // Produce an array that contains the union: each distinct element from all of
        // the passed-in arrays.
        _.union = function () {
          return _.uniq(flatten(arguments, true, true));
        };
        // Produce an array that contains every item shared between all the
        // passed-in arrays.
        _.intersection = function (array) {
          var result = [];
          var argsLength = arguments.length;
          for (var i = 0, length = getLength(array); i < length; i++) {
            var item = array[i];
            if (_.contains(result, item))
              continue;
            for (var j = 1; j < argsLength; j++) {
              if (!_.contains(arguments[j], item))
                break;
            }
            if (j === argsLength)
              result.push(item);
          }
          return result;
        };
        // Take the difference between one array and a number of other arrays.
        // Only the elements present in just the first array will remain.
        _.difference = function (array) {
          var rest = flatten(arguments, true, true, 1);
          return _.filter(array, function (value) {
            return !_.contains(rest, value);
          });
        };
        // Zip together multiple lists into a single array -- elements that share
        // an index go together.
        _.zip = function () {
          return _.unzip(arguments);
        };
        // Complement of _.zip. Unzip accepts an array of arrays and groups
        // each array's elements on shared indices
        _.unzip = function (array) {
          var length = array && _.max(array, getLength).length || 0;
          var result = Array(length);
          for (var index = 0; index < length; index++) {
            result[index] = _.pluck(array, index);
          }
          return result;
        };
        // Converts lists into objects. Pass either a single array of `[key, value]`
        // pairs, or two parallel arrays of the same length -- one of keys, and one of
        // the corresponding values.
        _.object = function (list, values) {
          var result = {};
          for (var i = 0, length = getLength(list); i < length; i++) {
            if (values) {
              result[list[i]] = values[i];
            } else {
              result[list[i][0]] = list[i][1];
            }
          }
          return result;
        };
        // Generator function to create the findIndex and findLastIndex functions
        function createPredicateIndexFinder(dir) {
          return function (array, predicate, context) {
            predicate = cb(predicate, context);
            var length = getLength(array);
            var index = dir > 0 ? 0 : length - 1;
            for (; index >= 0 && index < length; index += dir) {
              if (predicate(array[index], index, array))
                return index;
            }
            return -1;
          };
        }
        // Returns the first index on an array-like that passes a predicate test
        _.findIndex = createPredicateIndexFinder(1);
        _.findLastIndex = createPredicateIndexFinder(-1);
        // Use a comparator function to figure out the smallest index at which
        // an object should be inserted so as to maintain order. Uses binary search.
        _.sortedIndex = function (array, obj, iteratee, context) {
          iteratee = cb(iteratee, context, 1);
          var value = iteratee(obj);
          var low = 0, high = getLength(array);
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (iteratee(array[mid]) < value)
              low = mid + 1;
            else
              high = mid;
          }
          return low;
        };
        // Generator function to create the indexOf and lastIndexOf functions
        function createIndexFinder(dir, predicateFind, sortedIndex) {
          return function (array, item, idx) {
            var i = 0, length = getLength(array);
            if (typeof idx == 'number') {
              if (dir > 0) {
                i = idx >= 0 ? idx : Math.max(idx + length, i);
              } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
              }
            } else if (sortedIndex && idx && length) {
              idx = sortedIndex(array, item);
              return array[idx] === item ? idx : -1;
            }
            if (item !== item) {
              idx = predicateFind(slice.call(array, i, length), _.isNaN);
              return idx >= 0 ? idx + i : -1;
            }
            for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
              if (array[idx] === item)
                return idx;
            }
            return -1;
          };
        }
        // Return the position of the first occurrence of an item in an array,
        // or -1 if the item is not included in the array.
        // If the array is large and already in sort order, pass `true`
        // for **isSorted** to use binary search.
        _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
        _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        _.range = function (start, stop, step) {
          if (stop == null) {
            stop = start || 0;
            start = 0;
          }
          step = step || 1;
          var length = Math.max(Math.ceil((stop - start) / step), 0);
          var range = Array(length);
          for (var idx = 0; idx < length; idx++, start += step) {
            range[idx] = start;
          }
          return range;
        };
        // Function (ahem) Functions
        // ------------------
        // Determines whether to execute a function as a constructor
        // or a normal function with the provided arguments
        var executeBound = function (sourceFunc, boundFunc, context, callingContext, args) {
          if (!(callingContext instanceof boundFunc))
            return sourceFunc.apply(context, args);
          var self = baseCreate(sourceFunc.prototype);
          var result = sourceFunc.apply(self, args);
          if (_.isObject(result))
            return result;
          return self;
        };
        // Create a function bound to a given object (assigning `this`, and arguments,
        // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
        // available.
        _.bind = function (func, context) {
          if (nativeBind && func.bind === nativeBind)
            return nativeBind.apply(func, slice.call(arguments, 1));
          if (!_.isFunction(func))
            throw new TypeError('Bind must be called on a function');
          var args = slice.call(arguments, 2);
          var bound = function () {
            return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
          };
          return bound;
        };
        // Partially apply a function by creating a version that has had some of its
        // arguments pre-filled, without changing its dynamic `this` context. _ acts
        // as a placeholder, allowing any combination of arguments to be pre-filled.
        _.partial = function (func) {
          var boundArgs = slice.call(arguments, 1);
          var bound = function () {
            var position = 0, length = boundArgs.length;
            var args = Array(length);
            for (var i = 0; i < length; i++) {
              args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
            }
            while (position < arguments.length)
              args.push(arguments[position++]);
            return executeBound(func, bound, this, this, args);
          };
          return bound;
        };
        // Bind a number of an object's methods to that object. Remaining arguments
        // are the method names to be bound. Useful for ensuring that all callbacks
        // defined on an object belong to it.
        _.bindAll = function (obj) {
          var i, length = arguments.length, key;
          if (length <= 1)
            throw new Error('bindAll must be passed function names');
          for (i = 1; i < length; i++) {
            key = arguments[i];
            obj[key] = _.bind(obj[key], obj);
          }
          return obj;
        };
        // Memoize an expensive function by storing its results.
        _.memoize = function (func, hasher) {
          var memoize = function (key) {
            var cache = memoize.cache;
            var address = '' + (hasher ? hasher.apply(this, arguments) : key);
            if (!_.has(cache, address))
              cache[address] = func.apply(this, arguments);
            return cache[address];
          };
          memoize.cache = {};
          return memoize;
        };
        // Delays a function for the given number of milliseconds, and then calls
        // it with the arguments supplied.
        _.delay = function (func, wait) {
          var args = slice.call(arguments, 2);
          return setTimeout(function () {
            return func.apply(null, args);
          }, wait);
        };
        // Defers a function, scheduling it to run after the current call stack has
        // cleared.
        _.defer = _.partial(_.delay, _, 1);
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time. Normally, the throttled function will run
        // as much as it can, without ever going more than once per `wait` duration;
        // but if you'd like to disable the execution on the leading edge, pass
        // `{leading: false}`. To disable execution on the trailing edge, ditto.
        _.throttle = function (func, wait, options) {
          var context, args, result;
          var timeout = null;
          var previous = 0;
          if (!options)
            options = {};
          var later = function () {
            previous = options.leading === false ? 0 : _.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout)
              context = args = null;
          };
          return function () {
            var now = _.now();
            if (!previous && options.leading === false)
              previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
              previous = now;
              result = func.apply(context, args);
              if (!timeout)
                context = args = null;
            } else if (!timeout && options.trailing !== false) {
              timeout = setTimeout(later, remaining);
            }
            return result;
          };
        };
        // Returns a function, that, as long as it continues to be invoked, will not
        // be triggered. The function will be called after it stops being called for
        // N milliseconds. If `immediate` is passed, trigger the function on the
        // leading edge, instead of the trailing.
        _.debounce = function (func, wait, immediate) {
          var timeout, args, context, timestamp, result;
          var later = function () {
            var last = _.now() - timestamp;
            if (last < wait && last >= 0) {
              timeout = setTimeout(later, wait - last);
            } else {
              timeout = null;
              if (!immediate) {
                result = func.apply(context, args);
                if (!timeout)
                  context = args = null;
              }
            }
          };
          return function () {
            context = this;
            args = arguments;
            timestamp = _.now();
            var callNow = immediate && !timeout;
            if (!timeout)
              timeout = setTimeout(later, wait);
            if (callNow) {
              result = func.apply(context, args);
              context = args = null;
            }
            return result;
          };
        };
        // Returns the first function passed as an argument to the second,
        // allowing you to adjust arguments, run code before and after, and
        // conditionally execute the original function.
        _.wrap = function (func, wrapper) {
          return _.partial(wrapper, func);
        };
        // Returns a negated version of the passed-in predicate.
        _.negate = function (predicate) {
          return function () {
            return !predicate.apply(this, arguments);
          };
        };
        // Returns a function that is the composition of a list of functions, each
        // consuming the return value of the function that follows.
        _.compose = function () {
          var args = arguments;
          var start = args.length - 1;
          return function () {
            var i = start;
            var result = args[start].apply(this, arguments);
            while (i--)
              result = args[i].call(this, result);
            return result;
          };
        };
        // Returns a function that will only be executed on and after the Nth call.
        _.after = function (times, func) {
          return function () {
            if (--times < 1) {
              return func.apply(this, arguments);
            }
          };
        };
        // Returns a function that will only be executed up to (but not including) the Nth call.
        _.before = function (times, func) {
          var memo;
          return function () {
            if (--times > 0) {
              memo = func.apply(this, arguments);
            }
            if (times <= 1)
              func = null;
            return memo;
          };
        };
        // Returns a function that will be executed at most one time, no matter how
        // often you call it. Useful for lazy initialization.
        _.once = _.partial(_.before, 2);
        // Object Functions
        // ----------------
        // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
          ];
        function collectNonEnumProps(obj, keys) {
          var nonEnumIdx = nonEnumerableProps.length;
          var constructor = obj.constructor;
          var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
          // Constructor is a special case.
          var prop = 'constructor';
          if (_.has(obj, prop) && !_.contains(keys, prop))
            keys.push(prop);
          while (nonEnumIdx--) {
            prop = nonEnumerableProps[nonEnumIdx];
            if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
              keys.push(prop);
            }
          }
        }
        // Retrieve the names of an object's own properties.
        // Delegates to **ECMAScript 5**'s native `Object.keys`
        _.keys = function (obj) {
          if (!_.isObject(obj))
            return [];
          if (nativeKeys)
            return nativeKeys(obj);
          var keys = [];
          for (var key in obj)
            if (_.has(obj, key))
              keys.push(key);
          // Ahem, IE < 9.
          if (hasEnumBug)
            collectNonEnumProps(obj, keys);
          return keys;
        };
        // Retrieve all the property names of an object.
        _.allKeys = function (obj) {
          if (!_.isObject(obj))
            return [];
          var keys = [];
          for (var key in obj)
            keys.push(key);
          // Ahem, IE < 9.
          if (hasEnumBug)
            collectNonEnumProps(obj, keys);
          return keys;
        };
        // Retrieve the values of an object's properties.
        _.values = function (obj) {
          var keys = _.keys(obj);
          var length = keys.length;
          var values = Array(length);
          for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
          }
          return values;
        };
        // Returns the results of applying the iteratee to each element of the object
        // In contrast to _.map it returns an object
        _.mapObject = function (obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          var keys = _.keys(obj), length = keys.length, results = {}, currentKey;
          for (var index = 0; index < length; index++) {
            currentKey = keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
        };
        // Convert an object into a list of `[key, value]` pairs.
        _.pairs = function (obj) {
          var keys = _.keys(obj);
          var length = keys.length;
          var pairs = Array(length);
          for (var i = 0; i < length; i++) {
            pairs[i] = [
              keys[i],
              obj[keys[i]]
            ];
          }
          return pairs;
        };
        // Invert the keys and values of an object. The values must be serializable.
        _.invert = function (obj) {
          var result = {};
          var keys = _.keys(obj);
          for (var i = 0, length = keys.length; i < length; i++) {
            result[obj[keys[i]]] = keys[i];
          }
          return result;
        };
        // Return a sorted list of the function names available on the object.
        // Aliased as `methods`
        _.functions = _.methods = function (obj) {
          var names = [];
          for (var key in obj) {
            if (_.isFunction(obj[key]))
              names.push(key);
          }
          return names.sort();
        };
        // Extend a given object with all the properties in passed-in object(s).
        _.extend = createAssigner(_.allKeys);
        // Assigns a given object with all the own properties in the passed-in object(s)
        // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
        _.extendOwn = _.assign = createAssigner(_.keys);
        // Returns the first key on an object that passes a predicate test
        _.findKey = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var keys = _.keys(obj), key;
          for (var i = 0, length = keys.length; i < length; i++) {
            key = keys[i];
            if (predicate(obj[key], key, obj))
              return key;
          }
        };
        // Return a copy of the object only containing the whitelisted properties.
        _.pick = function (object, oiteratee, context) {
          var result = {}, obj = object, iteratee, keys;
          if (obj == null)
            return result;
          if (_.isFunction(oiteratee)) {
            keys = _.allKeys(obj);
            iteratee = optimizeCb(oiteratee, context);
          } else {
            keys = flatten(arguments, false, false, 1);
            iteratee = function (value, key, obj) {
              return key in obj;
            };
            obj = Object(obj);
          }
          for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (iteratee(value, key, obj))
              result[key] = value;
          }
          return result;
        };
        // Return a copy of the object without the blacklisted properties.
        _.omit = function (obj, iteratee, context) {
          if (_.isFunction(iteratee)) {
            iteratee = _.negate(iteratee);
          } else {
            var keys = _.map(flatten(arguments, false, false, 1), String);
            iteratee = function (value, key) {
              return !_.contains(keys, key);
            };
          }
          return _.pick(obj, iteratee, context);
        };
        // Fill in a given object with default properties.
        _.defaults = createAssigner(_.allKeys, true);
        // Creates an object that inherits from the given prototype object.
        // If additional properties are provided then they will be added to the
        // created object.
        _.create = function (prototype, props) {
          var result = baseCreate(prototype);
          if (props)
            _.extendOwn(result, props);
          return result;
        };
        // Create a (shallow-cloned) duplicate of an object.
        _.clone = function (obj) {
          if (!_.isObject(obj))
            return obj;
          return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
        };
        // Invokes interceptor with the obj, and then returns obj.
        // The primary purpose of this method is to "tap into" a method chain, in
        // order to perform operations on intermediate results within the chain.
        _.tap = function (obj, interceptor) {
          interceptor(obj);
          return obj;
        };
        // Returns whether an object has a given set of `key:value` pairs.
        _.isMatch = function (object, attrs) {
          var keys = _.keys(attrs), length = keys.length;
          if (object == null)
            return !length;
          var obj = Object(object);
          for (var i = 0; i < length; i++) {
            var key = keys[i];
            if (attrs[key] !== obj[key] || !(key in obj))
              return false;
          }
          return true;
        };
        // Internal recursive comparison function for `isEqual`.
        var eq = function (a, b, aStack, bStack) {
          // Identical objects are equal. `0 === -0`, but they aren't identical.
          // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
          if (a === b)
            return a !== 0 || 1 / a === 1 / b;
          // A strict comparison is necessary because `null == undefined`.
          if (a == null || b == null)
            return a === b;
          // Unwrap any wrapped objects.
          if (a instanceof _)
            a = a._wrapped;
          if (b instanceof _)
            b = b._wrapped;
          // Compare `[[Class]]` names.
          var className = toString.call(a);
          if (className !== toString.call(b))
            return false;
          switch (className) {
          // Strings, numbers, regular expressions, dates, and booleans are compared by value.
          case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+a !== +a)
              return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
          }
          var areArrays = className === '[object Array]';
          if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object')
              return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
              return false;
            }
          }
          // Assume equality for cyclic structures. The algorithm for detecting cyclic
          // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
          // Initializing stack of traversed objects.
          // It's done here since we only need them for objects and arrays comparison.
          aStack = aStack || [];
          bStack = bStack || [];
          var length = aStack.length;
          while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a)
              return bStack[length] === b;
          }
          // Add the first object to the stack of traversed objects.
          aStack.push(a);
          bStack.push(b);
          // Recursively compare objects and arrays.
          if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length)
              return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
              if (!eq(a[length], b[length], aStack, bStack))
                return false;
            }
          } else {
            // Deep compare objects.
            var keys = _.keys(a), key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (_.keys(b).length !== length)
              return false;
            while (length--) {
              // Deep compare each member
              key = keys[length];
              if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack)))
                return false;
            }
          }
          // Remove the first object from the stack of traversed objects.
          aStack.pop();
          bStack.pop();
          return true;
        };
        // Perform a deep comparison to check if two objects are equal.
        _.isEqual = function (a, b) {
          return eq(a, b);
        };
        // Is a given array, string, or object empty?
        // An "empty" object has no enumerable own-properties.
        _.isEmpty = function (obj) {
          if (obj == null)
            return true;
          if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
            return obj.length === 0;
          return _.keys(obj).length === 0;
        };
        // Is a given value a DOM element?
        _.isElement = function (obj) {
          return !!(obj && obj.nodeType === 1);
        };
        // Is a given value an array?
        // Delegates to ECMA5's native Array.isArray
        _.isArray = nativeIsArray || function (obj) {
          return toString.call(obj) === '[object Array]';
        };
        // Is a given variable an object?
        _.isObject = function (obj) {
          var type = typeof obj;
          return type === 'function' || type === 'object' && !!obj;
        };
        // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
        _.each([
          'Arguments',
          'Function',
          'String',
          'Number',
          'Date',
          'RegExp',
          'Error'
        ], function (name) {
          _['is' + name] = function (obj) {
            return toString.call(obj) === '[object ' + name + ']';
          };
        });
        // Define a fallback version of the method in browsers (ahem, IE < 9), where
        // there isn't any inspectable "Arguments" type.
        if (!_.isArguments(arguments)) {
          _.isArguments = function (obj) {
            return _.has(obj, 'callee');
          };
        }
        // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
        // IE 11 (#1621), and in Safari 8 (#1929).
        if (typeof /./ != 'function' && typeof Int8Array != 'object') {
          _.isFunction = function (obj) {
            return typeof obj == 'function' || false;
          };
        }
        // Is a given object a finite number?
        _.isFinite = function (obj) {
          return isFinite(obj) && !isNaN(parseFloat(obj));
        };
        // Is the given value `NaN`? (NaN is the only number which does not equal itself).
        _.isNaN = function (obj) {
          return _.isNumber(obj) && obj !== +obj;
        };
        // Is a given value a boolean?
        _.isBoolean = function (obj) {
          return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
        };
        // Is a given value equal to null?
        _.isNull = function (obj) {
          return obj === null;
        };
        // Is a given variable undefined?
        _.isUndefined = function (obj) {
          return obj === void 0;
        };
        // Shortcut function for checking if an object has a given property directly
        // on itself (in other words, not on a prototype).
        _.has = function (obj, key) {
          return obj != null && hasOwnProperty.call(obj, key);
        };
        // Utility Functions
        // -----------------
        // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
        // previous owner. Returns a reference to the Underscore object.
        _.noConflict = function () {
          root._ = previousUnderscore;
          return this;
        };
        // Keep the identity function around for default iteratees.
        _.identity = function (value) {
          return value;
        };
        // Predicate-generating functions. Often useful outside of Underscore.
        _.constant = function (value) {
          return function () {
            return value;
          };
        };
        _.noop = function () {
        };
        _.property = property;
        // Generates a function for a given object that returns a given property.
        _.propertyOf = function (obj) {
          return obj == null ? function () {
          } : function (key) {
            return obj[key];
          };
        };
        // Returns a predicate for checking whether an object has a given set of
        // `key:value` pairs.
        _.matcher = _.matches = function (attrs) {
          attrs = _.extendOwn({}, attrs);
          return function (obj) {
            return _.isMatch(obj, attrs);
          };
        };
        // Run a function **n** times.
        _.times = function (n, iteratee, context) {
          var accum = Array(Math.max(0, n));
          iteratee = optimizeCb(iteratee, context, 1);
          for (var i = 0; i < n; i++)
            accum[i] = iteratee(i);
          return accum;
        };
        // Return a random integer between min and max (inclusive).
        _.random = function (min, max) {
          if (max == null) {
            max = min;
            min = 0;
          }
          return min + Math.floor(Math.random() * (max - min + 1));
        };
        // A (possibly faster) way to get the current timestamp as an integer.
        _.now = Date.now || function () {
          return new Date().getTime();
        };
        // List of HTML entities for escaping.
        var escapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#x27;',
            '`': '&#x60;'
          };
        var unescapeMap = _.invert(escapeMap);
        // Functions for escaping and unescaping strings to/from HTML interpolation.
        var createEscaper = function (map) {
          var escaper = function (match) {
            return map[match];
          };
          // Regexes for identifying a key that needs to be escaped
          var source = '(?:' + _.keys(map).join('|') + ')';
          var testRegexp = RegExp(source);
          var replaceRegexp = RegExp(source, 'g');
          return function (string) {
            string = string == null ? '' : '' + string;
            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
          };
        };
        _.escape = createEscaper(escapeMap);
        _.unescape = createEscaper(unescapeMap);
        // If the value of the named `property` is a function then invoke it with the
        // `object` as context; otherwise, return it.
        _.result = function (object, property, fallback) {
          var value = object == null ? void 0 : object[property];
          if (value === void 0) {
            value = fallback;
          }
          return _.isFunction(value) ? value.call(object) : value;
        };
        // Generate a unique integer id (unique within the entire client session).
        // Useful for temporary DOM ids.
        var idCounter = 0;
        _.uniqueId = function (prefix) {
          var id = ++idCounter + '';
          return prefix ? prefix + id : id;
        };
        // By default, Underscore uses ERB-style template delimiters, change the
        // following template settings to use alternative delimiters.
        _.templateSettings = {
          evaluate: /<%([\s\S]+?)%>/g,
          interpolate: /<%=([\s\S]+?)%>/g,
          escape: /<%-([\s\S]+?)%>/g
        };
        // When customizing `templateSettings`, if you don't want to define an
        // interpolation, evaluation or escaping regex, we need one that is
        // guaranteed not to match.
        var noMatch = /(.)^/;
        // Certain characters need to be escaped so that they can be put into a
        // string literal.
        var escapes = {
            '\'': '\'',
            '\\': '\\',
            '\r': 'r',
            '\n': 'n',
            '\u2028': 'u2028',
            '\u2029': 'u2029'
          };
        var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
        var escapeChar = function (match) {
          return '\\' + escapes[match];
        };
        // JavaScript micro-templating, similar to John Resig's implementation.
        // Underscore templating handles arbitrary delimiters, preserves whitespace,
        // and correctly escapes quotes within interpolated code.
        // NB: `oldSettings` only exists for backwards compatibility.
        _.template = function (text, settings, oldSettings) {
          if (!settings && oldSettings)
            settings = oldSettings;
          settings = _.defaults({}, settings, _.templateSettings);
          // Combine delimiters into one regular expression via alternation.
          var matcher = RegExp([
              (settings.escape || noMatch).source,
              (settings.interpolate || noMatch).source,
              (settings.evaluate || noMatch).source
            ].join('|') + '|$', 'g');
          // Compile the template source, escaping string literals appropriately.
          var index = 0;
          var source = '__p+=\'';
          text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escaper, escapeChar);
            index = offset + match.length;
            if (escape) {
              source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
            } else if (interpolate) {
              source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
            } else if (evaluate) {
              source += '\';\n' + evaluate + '\n__p+=\'';
            }
            // Adobe VMs need the match returned to produce the correct offest.
            return match;
          });
          source += '\';\n';
          // If a variable is not specified, place data values in local scope.
          if (!settings.variable)
            source = 'with(obj||{}){\n' + source + '}\n';
          source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
          try {
            var render = new Function(settings.variable || 'obj', '_', source);
          } catch (e) {
            e.source = source;
            throw e;
          }
          var template = function (data) {
            return render.call(this, data, _);
          };
          // Provide the compiled source as a convenience for precompilation.
          var argument = settings.variable || 'obj';
          template.source = 'function(' + argument + '){\n' + source + '}';
          return template;
        };
        // Add a "chain" function. Start chaining a wrapped Underscore object.
        _.chain = function (obj) {
          var instance = _(obj);
          instance._chain = true;
          return instance;
        };
        // OOP
        // ---------------
        // If Underscore is called as a function, it returns a wrapped object that
        // can be used OO-style. This wrapper holds altered versions of all the
        // underscore functions. Wrapped objects may be chained.
        // Helper function to continue chaining intermediate results.
        var result = function (instance, obj) {
          return instance._chain ? _(obj).chain() : obj;
        };
        // Add your own custom functions to the Underscore object.
        _.mixin = function (obj) {
          _.each(_.functions(obj), function (name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function () {
              var args = [this._wrapped];
              push.apply(args, arguments);
              return result(this, func.apply(_, args));
            };
          });
        };
        // Add all of the Underscore functions to the wrapper object.
        _.mixin(_);
        // Add all mutator Array functions to the wrapper.
        _.each([
          'pop',
          'push',
          'reverse',
          'shift',
          'sort',
          'splice',
          'unshift'
        ], function (name) {
          var method = ArrayProto[name];
          _.prototype[name] = function () {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name === 'shift' || name === 'splice') && obj.length === 0)
              delete obj[0];
            return result(this, obj);
          };
        });
        // Add all accessor Array functions to the wrapper.
        _.each([
          'concat',
          'join',
          'slice'
        ], function (name) {
          var method = ArrayProto[name];
          _.prototype[name] = function () {
            return result(this, method.apply(this._wrapped, arguments));
          };
        });
        // Extracts the result from a wrapped and chained object.
        _.prototype.value = function () {
          return this._wrapped;
        };
        // Provide unwrapping proxy for some methods used in engine operations
        // such as arithmetic and JSON stringification.
        _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
        _.prototype.toString = function () {
          return '' + this._wrapped;
        };
        // AMD registration happens at the end for compatibility with AMD loaders
        // that may not enforce next-turn semantics on modules. Even though general
        // practice for AMD registration is to be anonymous, underscore registers
        // as a named module because, like jQuery, it is a base library that is
        // popular enough to be bundled in a third party lib, but not be part of
        // an AMD load request. Those cases could generate an error when an
        // anonymous define() is called outside of a loader request.
        if (typeof define === 'function' && define.amd) {
          define('underscore', [], function () {
            return _;
          });
        }
      }.call(this));
    },
    {}
  ]
}, {}, [8]));
(function (f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f();
  } else if (typeof define === 'function' && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }
    g.apiSpecConverter = f();
  }
}(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == 'function' && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error('Cannot find module \'' + o + '\'');
          throw f.code = 'MODULE_NOT_FOUND', f;
        }
        var l = n[o] = { exports: {} };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == 'function' && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  }({
    1: [
      function (require, module, exports) {
        var converter = require('./lib/converter'), Importer = require('./lib/importers/index'), Exporter = require('./lib/exporters/index'), Formats = require('./lib/formats');
        module.exports = {
          Converter: converter.Converter,
          Formats: Formats,
          Importer: Importer,
          Exporter: Exporter
        };
      },
      {
        './lib/converter': 2,
        './lib/exporters/index': 14,
        './lib/formats': 19,
        './lib/importers/index': 25
      }
    ],
    2: [
      function (require, module, exports) {
        var Importers = require('./importers/index'), Exporters = require('./exporters/index');
        function Converter(fromFormat, toFormat) {
          this.importer = Importers.factory(fromFormat);
          if (!this.importer) {
            throw new Error('from format ' + fromFormat.name + ' not supported');
          }
          this.importer.type = fromFormat;
          this.exporter = Exporters.factory(toFormat);
          if (!this.exporter) {
            throw new Error('to format ' + toFormat.name + ' not supported');
          }
          this.exporter.type = toFormat;
        }
        Converter.prototype.loadFile = function (filePath, cb) {
          return this.importer.loadFile(filePath, cb);
        };
        // todo unify api by returning a Promise like the loadData function
        Converter.prototype.loadFileWithOptions = function (filePath, options, cb) {
          return this.importer.loadFileWithOptions(filePath, options, cb);
        };
        Converter.prototype.loadData = function (rawData, options) {
          var me = this;
          return new Promise(function (resolve, reject) {
            me.importer.loadData(rawData, options).then(resolve).catch(reject);
          });
        };
        Converter.prototype.convert = function (format, cb) {
          var me = this;
          return new Promise(function (resolve, reject) {
            me.exporter.loadProject(me.importer.import());
            me.exporter.export(format).then(function (exportedData) {
              if (cb)
                cb(null, exportedData);
              resolve(exportedData);
            }).catch(function (err) {
              if (cb)
                cb(err, null);
              reject(err);
            });
          });
        };
        exports.Converter = Converter;
      },
      {
        './exporters/index': 14,
        './importers/index': 25
      }
    ],
    3: [
      function (require, module, exports) {
        var jsonHelper = require('../utils/json');
        var stringHelper = require('../utils/strings');
        function Endpoint(name) {
          this._id = null;
          this.name = name;
          this.description = '';
          this.tags = [];
          this.request = {};
          this.request.pathParams = {};
          this.request.bodies = [];
          this.request.headers = '{}';
          this.responses = [];
          this.middlewareBefore = '';
          this.middlewareAfter = '';
          this.mock = {
            enabled: false,
            statusCode: 200
          };
          this.securedBy = { none: true };
          this.public = true;
          this.deprecated = null;
          this.externalDocs = null;
        }
        Endpoint.prototype = {
          SetOperationId: function (operationId, method, path) {
            if (operationId) {
              this.operationId = operationId;
            } else {
              this.operationId = stringHelper.computeOperationId(method, path);
            }
          },
          get Id() {
            return this._id;
          },
          set Id(id) {
            this._id = id;
          },
          get Path() {
            return this.request.path;
          },
          set Path(path) {
            this.request.path = path;
          },
          get Method() {
            return this.request.method;
          },
          set Method(requestMethod) {
            this.request.method = requestMethod.toLowerCase();
          },
          set Name(name) {
            if (!name) {
              return;
            }
            if (name.length > 120) {
              this.name = name.substring(0, 119);
            } else {
              this.name = name;
            }
          },
          get Name() {
            return this.name || '';
          },
          get Headers() {
            return jsonHelper.parse(this.request.headers);
          },
          set Headers(headers) {
            this.request.headers = jsonHelper.stringify(headers, 4);
          },
          get Before() {
            return this.middlewareBefore;
          },
          set Before(before) {
            this.middlewareBefore = before;
          },
          get After() {
            return this.middlewareAfter;
          },
          set After(after) {
            this.middlewareAfter = after;
          },
          set Body(body) {
            body.body = jsonHelper.stringify(body.body, 4);
            this.request.bodies.push(body);
          },
          get Body() {
            if (Array.isArray(this.request.bodies) && this.request.bodies.length > 0) {
              return this.request.bodies[0];
            }
            return {};
          },
          set QueryString(queryString) {
            queryString = jsonHelper.stringify(queryString, 4);
            this.request.queryString = queryString;
          },
          get QueryString() {
            if (!this.request.queryString) {
              this.request.queryString = '{}';
            }
            return jsonHelper.parse(this.request.queryString);
          },
          set PathParams(uriParams) {
            this.request.pathParams = jsonHelper.stringify(uriParams, 4);
          },
          get PathParams() {
            if (!this.request.pathParams) {
              this.request.pathParams = '{}';
            }
            return jsonHelper.parse(this.request.pathParams);
          },
          set Responses(res) {
            this.responses = res;
          },
          get Responses() {
            return this.responses;
          },
          set SLData(data) {
            for (var key in data) {
              this[key] = data[key];
            }
          },
          set Description(desc) {
            this.description = desc;
          },
          get Description() {
            return this.description || '';
          },
          get Tags() {
            return this.tags;
          },
          set Tags(tags) {
            this.tags = tags;
          },
          set Summary(desc) {
            this.summary = desc;
          },
          get Summary() {
            return this.summary || '';
          },
          set SecuredBy(security) {
            this.securedBy = security;
          },
          get SecuredBy() {
            return this.securedBy;
          },
          set Mock(mock) {
            this.mock = mock;
          },
          get Mock() {
            return this.mock;
          },
          get Request() {
            return this.request;
          },
          get Public() {
            return this.public;
          },
          get Deprecated() {
            return this.deprecated;
          },
          set Deprecated(deprecated) {
            this.deprecated = deprecated;
          },
          get ExternalDocs() {
            return this.externalDocs;
          },
          set ExternalDocs(externalDocs) {
            this.externalDocs = externalDocs;
          }
        };
        module.exports = Endpoint;
      },
      {
        '../utils/json': 33,
        '../utils/strings': 34
      }
    ],
    4: [
      function (require, module, exports) {
        function Environment() {
          this.summary = '';
          this.forwardHost = null;
          this.basePath = '';
          this.defaultResponseType = '';
          this.defaultRequestType = '';
          this.protocols = [];
          this.version = '';
          this.middlewareBefore = '';
          this.middlewareAfter = '';
          this.proxy = {};
          this.securitySchemes = {};
          this.resourcesOrder = {
            utilFuncs: [],
            docs: [],
            savedEntries: []
          };
        }
        Environment.prototype = {
          set Host(host) {
            this.forwardHost = host;
          },
          get Host() {
            return this.forwardHost;
          },
          set BasePath(basePath) {
            this.basePath = basePath;
          },
          get BasePath() {
            return this.basePath || '';
          },
          get DefaultResponseType() {
            return this.defaultResponseType;
          },
          set DefaultResponseType(respType) {
            this.defaultResponseType = respType;
          },
          get DefaultRequestType() {
            return this.defaultRequestType;
          },
          set DefaultRequestType(reqType) {
            this.defaultRequestType = reqType;
          },
          get Protocols() {
            return this.protocols;
          },
          set Protocols(protocols) {
            this.protocols = protocols;
          },
          get Version() {
            return this.version || '';
          },
          set Version(version) {
            this.version = version;
          },
          set Proxy(proxy) {
            this.proxy = proxy;
          },
          get Proxy() {
            if (this.proxy) {
              delete this.proxy['sslCert'];
              delete this.proxy['sslKey'];
            }
            return this.proxy;
          },
          set MiddlewareBefore(before) {
            this.middlewareBefore = before;
          },
          get MiddlewareBefore() {
            return this.middlewareBefore;
          },
          set MiddlewareAfter(after) {
            this.middlewareAfter = after;
          },
          get MiddlewareAfter() {
            return this.middlewareAfter;
          },
          set GroupsOrder(eo) {
            this.resourcesOrder = eo;
          },
          get GroupsOrder() {
            return this.resourcesOrder;
          },
          set SecuritySchemes(schemes) {
            this.securitySchemes = schemes;
          },
          get SecuritySchemes() {
            return this.securitySchemes;
          },
          addSecurityScheme: function (key, securityScheme) {
            this.securitySchemes[key] = securityScheme;
          },
          loadSLData: function (envData) {
            for (var key in envData) {
              if (this.hasOwnProperty(key)) {
                //direct map supported keys
                this[key] = envData[key];
              } else {
              }
            }
          }
        };
        //used for stoplightx export only
        Environment.prototype.toJSON = function () {
          return { groups: this.resourcesOrder };
        };
        module.exports = Environment;
      },
      {}
    ],
    5: [
      function (require, module, exports) {
        var Environment = require('./environment');
        function Project(name) {
          this.name = name;
          this.description = '';
          this.environment = new Environment();
          this.endpoints = [];
          this.schemas = [];
          this.utilityFunctions = [];
          this.texts = [];
          this.traits = [];
          this.tests = [];
          this.savedEntries = [];
        }
        Project.prototype = {
          set Description(desc) {
            this.description = desc || '';
          },
          get Name() {
            return this.name;
          },
          get Description() {
            return this.description || '';
          },
          get Endpoints() {
            return this.endpoints;
          },
          set Endpoints(endpoints) {
            this.endpoints = endpoints;
          },
          get Schemas() {
            return this.schemas;
          },
          set Schemas(schemas) {
            this.schemas = schemas;
          },
          get Environment() {
            return this.environment;
          },
          set Environment(env) {
            this.environment = env;
          },
          get UtilityFunctions() {
            return this.utilityFunctions;
          },
          get Texts() {
            return this.texts;
          },
          get Traits() {
            return this.traits;
          },
          get Tests() {
            return this.tests;
          },
          set Tests(tests) {
            this.tests = tests;
          },
          get SavedEntries() {
            return this.savedEntries;
          },
          set SavedEntries(savedEntries) {
            this.savedEntries = savedEntries;
          },
          addEndpoint: function (endpoint) {
            this.endpoints.push(endpoint);
          },
          addSchema: function (schema) {
            this.schemas.push(schema);
          },
          addUtilityFunction: function (uf) {
            this.utilityFunctions.push(uf);
          },
          addText: function (txt) {
            this.texts.push(txt);
          },
          addTrait: function (trait) {
            this.traits.push(trait);
          },
          addTest: function (test) {
            this.tests.push(test);
          },
          addSavedEntry: function (savedEntry) {
            this.savedEntries.push(savedEntry);
          },
          loadSLData: function (slData) {
            this.Description = slData.description;
          }
        };
        module.exports = Project;
      },
      { './environment': 4 }
    ],
    6: [
      function (require, module, exports) {
        var jsonHelper = require('../utils/json');
        function SavedEntry() {
          this._id = null;
          this.request = {
            pathParams: {},
            bodies: [],
            headers: '{}'
          };
        }
        SavedEntry.prototype = {
          get Id() {
            return this._id;
          },
          set Id(id) {
            this._id = id;
          },
          get Path() {
            return this.request.path;
          },
          set Path(path) {
            this.request.path = path;
          },
          get Method() {
            return this.request.method;
          },
          set Method(requestMethod) {
            this.request.method = requestMethod.toLowerCase();
          },
          get Headers() {
            return jsonHelper.parse(this.request.headers);
          },
          set Headers(headers) {
            this.request.headers = jsonHelper.stringify(headers, 4);
          },
          set Body(body) {
            body.body = jsonHelper.stringify(body.body, 4);
            this.request.bodies.push(body);
          },
          get Body() {
            if (Array.isArray(this.request.bodies) && this.request.bodies.length > 0) {
              return this.request.bodies[0];
            }
            return {};
          },
          set QueryString(queryString) {
            queryString = jsonHelper.stringify(queryString, 4);
            this.request.queryString = queryString;
          },
          get QueryString() {
            if (!this.request.queryString) {
              this.request.queryString = '{}';
            }
            return jsonHelper.parse(this.request.queryString);
          },
          set PathParams(uriParams) {
            this.request.pathParams = jsonHelper.stringify(uriParams, 4);
          },
          get PathParams() {
            if (!this.request.pathParams) {
              this.request.pathParams = '{}';
            }
            return jsonHelper.parse(this.request.pathParams);
          },
          get Request() {
            return this.request;
          }
        };
        module.exports = SavedEntry;
      },
      { '../utils/json': 33 }
    ],
    7: [
      function (require, module, exports) {
        function Schema(namespace) {
          this.name = '';
          this.namespace = namespace;
          this.definition = '';
          this.example = '';
          this.summary = '';
          this.description = '';
          this.public = true;
        }
        Schema.prototype = {
          get Id() {
            return this._id;
          },
          set Id(id) {
            this._id = id;
          },
          get Name() {
            return this.name;
          },
          set Name(name) {
            this.name = name;
          },
          get NameSpace() {
            return this.namespace;
          },
          set Definition(definition) {
            this.definition = definition;
          },
          get Definition() {
            return this.definition;
          },
          get Example() {
            return this.example;
          },
          set SLData(schemaData) {
            this.name = schemaData.name || '';
            this.definition = schemaData.definition || {};
            this.example = schemaData.example || {};
            this._id = schemaData._id;
          },
          get Summary() {
            return this.summary || '';
          },
          set Summary(summary) {
            this.summary = summary;
          },
          get Description() {
            return this.description;
          },
          set Description(desc) {
            this.description = desc;
          },
          get Public() {
            return this.public;
          },
          set Public(public) {
            this.public = public;
          }
        };
        module.exports = Schema;
      },
      {}
    ],
    8: [
      function (require, module, exports) {
        function SwaggerDefinition(title, description) {
          this.swagger = '2.0';
          this.schemes = [];
          this.basePath = '';
          this.host = '';
          this.info = {
            'version': '',
            'title': title,
            'description': description
          };
          this.consumes = [];
          this.produces = [];
          this.paths = {};
          this.definitions = {};
        }
        SwaggerDefinition.prototype = {
          set BasePath(basePath) {
            if (basePath && basePath.length > 0) {
              this.basePath = basePath;
            } else {
              delete this.basePath;
            }
          },
          set Host(host) {
            if (host && host.length > 0) {
              this.host = host;
            } else {
              delete this.host;
            }
          }
        };
        module.exports = SwaggerDefinition;
      },
      {}
    ],
    9: [
      function (require, module, exports) {
        var jsonHelper = require('../utils/json');
        function Test(name) {
          this._id = null;
          this.name = name;
          this.summary = '';
          this.initialVariables = '{}';
          this.steps = [];  // TODO map each step to maintain proper structure
        }
        Test.prototype = {
          get Id() {
            return this._id;
          },
          set Id(id) {
            this._id = id;
          },
          get Name() {
            return this.name;
          },
          set Name(name) {
            this.name = name;
          },
          get Summary() {
            return this.summary || '';
          },
          set Summary(summary) {
            this.summary = summary;
          },
          get InitialVariables() {
            return this.initialVariables;
          },
          set InitialVariables(initialVariables) {
            this.initialVariables = jsonHelper.stringify(initialVariables, 4);
          },
          get Steps() {
            return this.steps;
          },
          set Steps(steps) {
            this.steps = steps;
          }
        };
        module.exports = Test;
      },
      { '../utils/json': 33 }
    ],
    10: [
      function (require, module, exports) {
        function Text(name) {
          this._id = null;
          this.name = name;
          this.content = '';
          this.public = '';
        }
        Text.prototype = {
          get Id() {
            return this._id;
          },
          set Id(id) {
            this._id = id;
          },
          get Name() {
            return this.name;
          },
          set Name(name) {
            this.name = name;
          },
          set Content(content) {
            this.content = content;
          },
          get Content() {
            return this.content;
          },
          set Public(public) {
            this.public = public;
          },
          get Public() {
            return this.public;
          }
        };
        //used for stoplightx export only
        Text.prototype.toJSON = function () {
          return {
            id: this.Id,
            name: this.Name,
            content: this.Content,
            public: this.Public
          };
        };
        module.exports = Text;
      },
      {}
    ],
    11: [
      function (require, module, exports) {
        function UtilityFunction(name) {
          this.name = name;
          this.description = '';
          this.script = '';
        }
        UtilityFunction.prototype = {
          get Name() {
            return this.name;
          },
          set Description(description) {
            this.description = description;
          },
          get Description() {
            return this.description;
          },
          set Script(script) {
            this.script = script;
          },
          get Script() {
            return this.script;
          }
        };
        //used for stoplightx export only
        UtilityFunction.prototype.toJSON = function () {
          return {
            name: this.Name,
            description: this.Description,
            script: this.Script
          };
        };
        module.exports = UtilityFunction;
      },
      {}
    ],
    12: [
      function (require, module, exports) {
        var _ = require('lodash'), Exporter = require('./exporter'), ramlHelper = require('../helpers/raml'), jsonHelper = require('../utils/json'), YAML = require('js-yaml');
        function RAMLDefinition(title, env) {
          this.title = title;
          //TODO anyway to know version?
          this.version = env.Version;
          this.baseUri = env.Host + env.BasePath;
          this.mediaType = env.DefaultResponseType || '';
          this.protocols = mapProtocols(env.Protocols);
        }
        RAMLDefinition.prototype.addMethod = function (resource, methodURIs, methodKey, method) {
          if (!methodURIs) {
            return;
          }
          if (methodURIs.length <= 0) {
            //reach the leaf of tree
            //TODO optional: check same method existence
            if (!resource.uriParameters) {
              resource.uriParameters = {};
            }
            for (var attrname in method.uriParameters) {
              if (!method.uriParameters.hasOwnProperty(attrname))
                continue;
              //uri not available, so check with displayName, which is same
              var isURIParamExist = resource.displayName.split(attrname).length - 1;
              if (isURIParamExist) {
                resource.uriParameters[attrname] = method.uriParameters[attrname];
              }
            }
            delete method.uriParameters;
            if (Object.keys(resource.uriParameters).length == 0)
              delete resource.uriParameters;
            resource[methodKey] = method;
          } else {
            var currentURI = '/' + methodURIs[0];
            if (!resource[currentURI]) {
              resource[currentURI] = { displayName: methodURIs[0] };  //TODO uriParams?!?
            }
            methodURIs.splice(0, 1);
            this.addMethod(resource[currentURI], methodURIs, methodKey, method);
          }
        };
        function RAML() {
          this.metadata = null;
          this.hasTags = false;
          this.hasDeprecated = false;
          this.hasExternalDocs = false;
          this.hasInfo = false;
        }
        RAML.prototype = new Exporter();
        RAML.prototype._mapSecurityScheme = function (slSecuritySchemes) {
          var ramlSecuritySchemes = {};
          if (slSecuritySchemes.hasOwnProperty('oauth2')) {
            var name = slSecuritySchemes.oauth2.name || 'oauth2';
            //missing describedBy, description
            ramlSecuritySchemes[name] = {
              type: 'OAuth 2.0',
              settings: {
                authorizationUri: slSecuritySchemes.oauth2.authorizationUrl || undefined,
                accessTokenUri: slSecuritySchemes.oauth2.tokenUrl || undefined,
                authorizationGrants: this.mapAuthorizationGrants(slSecuritySchemes.oauth2.flow)
              }
            };
            var scopes = [];
            if (slSecuritySchemes.oauth2.scopes && !_.isEmpty(slSecuritySchemes.oauth2.scopes)) {
              for (var index in slSecuritySchemes.oauth2.scopes) {
                var scope = slSecuritySchemes.oauth2.scopes[index].name;
                scopes.push(scope);
              }
              ramlSecuritySchemes[name]['settings']['scopes'] = scopes;
            }
          }
          if (slSecuritySchemes.hasOwnProperty('basic')) {
            var basicName = slSecuritySchemes.basic.name;
            if (basicName) {
              ramlSecuritySchemes[basicName] = {
                type: 'Basic Authentication',
                description: slSecuritySchemes.basic.description
              };
            }
          }
          if (slSecuritySchemes.hasOwnProperty('apiKey')) {
            var externalName = null;
            var content = null;
            var description = null;
            if (slSecuritySchemes.apiKey.headers && !_.isEmpty(slSecuritySchemes.apiKey.headers)) {
              externalName = slSecuritySchemes.apiKey.headers[0].externalName;
              var keyName = slSecuritySchemes.apiKey.headers[0].name;
              description = slSecuritySchemes.apiKey.headers[0].description;
              content = { headers: {} };
              content['headers'][keyName] = { type: 'string' };
            } else if (slSecuritySchemes.apiKey.queryString) {
            }
            ramlSecuritySchemes[externalName] = {
              type: 'Pass Through',
              describedBy: content,
              description: description
            };
          }
          return ramlSecuritySchemes;
        };
        RAML.prototype._validateParam = function (params) {
          var acceptedTypes = [
              'string',
              'number',
              'integer',
              'date',
              'boolean',
              'file',
              'array'
            ];
          for (var key in params) {
            if (!params.hasOwnProperty(key))
              continue;
            var param = params[key];
            for (var prop in param) {
              if (!param.hasOwnProperty(prop))
                continue;
              switch (prop) {
              case 'type':
                var type = params[key].type;
                if (acceptedTypes.indexOf(type) < 0) {
                  //not supported type, delete param
                  delete params[key];
                  continue;
                }
                break;
              case 'enum':
              case 'pattern':
              case 'minLength':
              case 'maxLength':
                if (params[key].type !== 'string') {
                  delete params[key][prop];
                }
                break;
              case 'minimum':
              case 'maximum':
                var typeLowercase = params[key].type.toLowerCase();
                if (typeLowercase !== 'integer' && typeLowercase !== 'number') {
                  delete params[key][prop];
                }
                break;
              case 'required':
              case 'displayName':
              case 'description':
              case 'example':
              case 'repeat':
              case 'default':
              case 'items':
                break;
              default:
                //not supported types
                if (params[key]) {
                  delete params[key][prop];
                }
              }
            }
          }
          return params;
        };
        RAML.prototype._mapRequestBody = function (bodyData) {
          var body = {};
          if (bodyData.body) {
            var mimeType = bodyData.mimeType;
            if (!mimeType) {
              return body;
            }
            switch (mimeType) {
            case 'application/json':
              body[mimeType] = this.mapBody(bodyData);
              break;
            case 'multipart/form-data':
            case 'application/x-www-form-urlencoded':
              var parsedBody = jsonHelper.parse(bodyData.body);
              body[mimeType] = this.mapRequestBodyForm(parsedBody);
              break;
            default:  //unsuported format
                      //TODO
            }
            if (bodyData.description) {
              body[mimeType].description = bodyData.description;
            }
          }
          return body;
        };
        RAML.prototype._mapNamedParams = function (params) {
          if (Object.keys(params.properties).length == 0)
            return;
          var newParams = {};
          for (var key in params.properties) {
            if (!params.properties.hasOwnProperty(key))
              continue;
            newParams[key] = ramlHelper.setParameterFields(params.properties[key], {});
            if (params.required && params.required.indexOf(key) > -1) {
              newParams[key].required = true;
            }
            newParams[key] = jsonHelper.orderByKeys(newParams[key], [
              'type',
              'description'
            ]);
          }
          return this._validateParam(newParams);
        };
        RAML.prototype._mapResponseBody = function (responseData) {
          var responses = {};
          for (var i in responseData) {
            if (!responseData.hasOwnProperty(i))
              continue;
            var resBody = responseData[i];
            if (!_.isEmpty(resBody.codes)) {
              var code = resBody.codes[0];
              if (code === 'default' || parseInt(code) == 'NaN') {
                continue;
              }
              responses[code] = { body: {} };
              var type = resBody.mimeType;
              if (resBody.mimeType) {
                responses[code]['body'][type] = this.mapBody(resBody);
              } else {
                responses[code] = {};
              }
              if (resBody.description) {
                responses[code]['description'] = resBody.description;
              }
              if (!jsonHelper.isEmptySchema(resBody.headers)) {
                responses[code]['body'][type].headers = this._mapNamedParams(resBody.headers);
              }
            }
          }
          return responses;
        };
        //TODO: Stoplight doesn't support seperate path params completely yet
        RAML.prototype._mapURIParams = function (pathParamData) {
          if (!pathParamData.properties || Object.keys(pathParamData.properties).length == 0) {
            return;
          }
          var pathParams = {};
          for (var key in pathParamData.properties) {
            if (!pathParamData.properties.hasOwnProperty(key))
              continue;
            var prop = pathParamData.properties[key];
            pathParams[key] = ramlHelper.setParameterFields(prop, {});
            if (prop.description) {
              pathParams[key].displayName = prop.description;
            }
            if (prop.items) {
              pathParams[key].items = prop.items;
            }
            pathParams[key].type = pathParams[key].type || 'string';
          }
          return this._validateParam(pathParams);
        };
        function mapProtocols(protocols) {
          var validProtocols = [];
          for (var i in protocols) {
            if (!protocols.hasOwnProperty(i) || protocols[i].toLowerCase() != 'http' && protocols[i].toLowerCase() != 'https') {
              //RAML incompatible formats( 'ws' etc)
              continue;
            }
            validProtocols.push(protocols[i].toUpperCase());
          }
          return validProtocols;
        }
        RAML.prototype._mapTextSections = function (slTexts) {
          var results = [];
          for (var i in slTexts) {
            if (!slTexts.hasOwnProperty(i))
              continue;
            var text = slTexts[i];
            if (text.divider || _.isEmpty(text.name) || _.isEmpty(text.content)) {
              continue;
            }
            results.push({
              title: text.name,
              content: text.content
            });
          }
          return results;
        };
        // from ref=type1 to type=type1
        RAML.prototype.convertRefFromModel = function (object) {
          for (var id in object) {
            if (object.hasOwnProperty(id)) {
              var val = object[id];
              if (id == 'ref') {
                object.type = val;
                delete object[id];
              } else if (id == 'include') {
                object.type = '!include ' + val;
                delete object[id];
              } else if (typeof val === 'object') {
                if (val.type == 'string') {
                  if (val.format == 'byte' || val.format == 'binary' || val.format == 'password') {
                    object[id] = { type: 'string' };
                  }
                  if (val.format == 'date') {
                    object[id] = { type: 'date-only' };
                  } else if (val.format == 'date-time') {
                    object[id] = {
                      type: 'datetime',
                      format: 'rfc3339'
                    };
                  }
                } else {
                  object[id] = this.convertRefFromModel(val);
                }
              }
            }
          }
          return object;
        };
        RAML.prototype._mapTraits = function (slTraits) {
          var traits = [];
          for (var i in slTraits) {
            if (!slTraits.hasOwnProperty(i))
              continue;
            var slTrait = slTraits[i], trait = {};
            try {
              var queryString = JSON.parse(slTrait.request.queryString);
              if (!jsonHelper.isEmptySchema(queryString)) {
                trait.queryParameters = this._mapNamedParams(queryString);
              }
            } catch (e) {
            }
            try {
              var headers = JSON.parse(slTrait.request.headers);
              if (!jsonHelper.isEmptySchema(headers)) {
                trait.headers = this._mapNamedParams(headers);
              }
            } catch (e) {
            }
            try {
              if (slTrait.responses && slTrait.responses.length) {
                trait.responses = this._mapResponseBody(slTrait.responses);
              }
            } catch (e) {
            }
            var newTrait = {};
            newTrait[_.camelCase(slTrait.name)] = trait;
            traits.push(newTrait);
          }
          return traits;
        };
        RAML.prototype._mapEndpointTraits = function (slTraits, endpoint) {
          var is = [];
          for (var i in endpoint.traits) {
            if (!endpoint.traits.hasOwnProperty(i))
              continue;
            var trait = _.find(slTraits, [
                '_id',
                endpoint.traits[i]
              ]);
            if (!trait) {
              continue;
            }
            is.push(_.camelCase(trait.name));
          }
          return is;
        };
        RAML.prototype._export = function () {
          var env = this.project.Environment;
          var ramlDef = new RAMLDefinition(this.project.Name, env);
          this.description(ramlDef, this.project);
          if (this.project.Environment.ExternalDocs) {
            this.hasExternalDocs = true;
            ramlDef['(externalDocs)'] = {
              'description': this.project.Environment.ExternalDocs.description,
              'url': this.project.Environment.ExternalDocs.url
            };
          }
          if (this.project.Environment.contactInfo || this.project.Environment.termsOfService || this.project.Environment.license) {
            ramlDef['(info)'] = {};
            this.hasInfo = true;
          }
          if (this.project.Environment.contactInfo) {
            ramlDef['(info)'].contact = {};
            if (this.project.Environment.contactInfo.name) {
              ramlDef['(info)'].contact.name = this.project.Environment.contactInfo.name;
            }
            if (this.project.Environment.contactInfo.url) {
              ramlDef['(info)'].contact.url = this.project.Environment.contactInfo.url;
            }
            if (this.project.Environment.contactInfo.email) {
              ramlDef['(info)'].contact.email = this.project.Environment.contactInfo.email;
            }
          }
          if (this.project.Environment.termsOfService) {
            ramlDef['(info)'].termsOfService = this.project.Environment.termsOfService;
          }
          if (this.project.Environment.license) {
            ramlDef['(info)'].license = {};
            if (this.project.Environment.license.name) {
              ramlDef['(info)'].license.name = this.project.Environment.license.name;
            }
            if (this.project.Environment.license.url) {
              ramlDef['(info)'].license.url = this.project.Environment.license.url;
            }
          }
          var docs = this._mapTextSections(this.project.Texts);
          if (docs.length) {
            ramlDef.documentation = ramlDef.documentation.concat(docs);
          }
          var slSecuritySchemes = this.project.Environment.SecuritySchemes;
          var securitySchemes = this._mapSecurityScheme(slSecuritySchemes);
          if (!_.isEmpty(securitySchemes)) {
            ramlDef.securitySchemes = securitySchemes;
          }
          var endpoints = this.project.Endpoints;
          // Collect endpoints ids from environment resourcesOrder
          var orderedIds = env.resourcesOrder.docs.reduce(function (ids, group) {
              return ids.concat(_.map(_.filter(group.items, { type: 'endpoints' }), '_id'));
            }, []);
          // Sort endpoints similar to resourcesOrder items order
          endpoints.sort(function (a, b) {
            return orderedIds.indexOf(a._id) < orderedIds.indexOf(b._id) ? -1 : 1;
          });
          for (var i in endpoints) {
            if (!endpoints.hasOwnProperty(i))
              continue;
            var endpoint = endpoints[i];
            var method = {};
            if (endpoint.operationId || endpoint.Name) {
              method.displayName = endpoint.operationId || endpoint.Name;
            }
            if (endpoint.Description) {
              method.description = endpoint.Description;
            }
            if (endpoint.Summary) {
              method.description = endpoint.Summary + '. ' + method.description;
            }
            var is = this._mapEndpointTraits(this.project.Traits, endpoint);
            if (is.length) {
              method.is = is;
            }
            if (endpoint.Method.toLowerCase() === 'post' || endpoint.Method.toLowerCase() === 'put' || endpoint.Method.toLowerCase() === 'patch') {
              method.body = this._mapRequestBody(endpoint.Body);
            }
            method.headers = this._mapNamedParams(endpoint.Headers);
            method.responses = this._mapResponseBody(endpoint.Responses);
            method.queryParameters = this._mapURIParams(endpoint.QueryString);
            method.uriParameters = this._mapURIParams(endpoint.PathParams);
            if (endpoint.securedBy) {
              var rsecuredBy = [];
              if (endpoint.securedBy.oauth2) {
                var securedName = slSecuritySchemes.oauth2.name || 'oauth2';
                if (!_.isEmpty(endpoint.securedBy.oauth2)) {
                  var scopes = {};
                  scopes[securedName] = { scopes: endpoint.securedBy.oauth2 };
                  rsecuredBy.push(scopes);
                } else {
                  rsecuredBy.push(securedName);
                }
              }
              if (endpoint.securedBy.basic && slSecuritySchemes.basic.name) {
                rsecuredBy.push(slSecuritySchemes.basic.name);
              }
              if (endpoint.securedBy.apiKey) {
                if (slSecuritySchemes.apiKey) {
                  if (!_.isEmpty(slSecuritySchemes.apiKey.headers)) {
                    rsecuredBy.push(slSecuritySchemes.apiKey.headers[0].externalName);
                  } else if (!_.isEmpty(slSecuritySchemes.apiKey.queryString)) {
                    rsecuredBy.push(slSecuritySchemes.apiKey.queryString[0].externalName);
                  }
                }
              }
              if (rsecuredBy.length > 0) {
                method.securedBy = rsecuredBy;
              }
            }
            var uriParts = endpoint.Path.split('/');
            uriParts.splice(0, 1);
            ramlDef.addMethod(ramlDef, uriParts, endpoint.Method, method);
            if (endpoint.Tags && !_.isEmpty(endpoint.Tags)) {
              this.hasTags = true;
              method['(tags)'] = endpoint.Tags;
            }
            if (endpoint.Deprecated) {
              this.hasDeprecated = true;
              method['(deprecated)'] = endpoint.Deprecated;
            }
            if (endpoint.ExternalDocs) {
              this.hasExternalDocs = true;
              method['(externalDocs)'] = {
                'description': endpoint.ExternalDocs.description,
                'url': endpoint.ExternalDocs.url
              };
            }
          }
          if (this.hasTags || this.hasDeprecated || this.hasExternalDocs) {
            ramlDef.annotationTypes = {};
            if (this.hasTags) {
              ramlDef.annotationTypes.tags = 'string[]';
            }
            if (this.hasDeprecated) {
              ramlDef.annotationTypes.deprecated = 'boolean';
            }
            if (this.hasExternalDocs) {
              ramlDef.annotationTypes.externalDocs = {
                'description': 'string',
                'url': 'string'
              };
            }
            if (this.hasInfo) {
              ramlDef.annotationTypes.info = {
                'termsOfService?': 'string',
                'contact?': {
                  'name?': 'string',
                  'url?': 'string',
                  'email?': 'string'
                },
                'license?': {
                  'name?': 'string',
                  'url?': 'string'
                }
              };
            }
          }
          if (this.project.Schemas && this.project.Schemas.length > 0)
            this.addSchema(ramlDef, this.mapSchema(this.project.Schemas));
          if (this.project.Traits && this.project.Traits.length > 0)
            ramlDef.traits = this._mapTraits(this.project.Traits);
          // Clean empty field in definition
          for (var field in ramlDef) {
            if (ramlDef.hasOwnProperty(field) && !ramlDef[field]) {
              delete ramlDef[field];
            }
          }
          this.data = ramlDef;
        };
        RAML.prototype._unescapeYamlIncludes = function (yaml) {
          var start = yaml.indexOf('\'!include ');
          if (start == -1)
            return yaml;
          var end = yaml.indexOf('\'', start + 1);
          if (end == -1)
            return yaml;
          return yaml.substring(0, start) + yaml.substring(start + 1, end) + this._unescapeYamlIncludes(yaml.substring(end + 1));
        };
        RAML.prototype._getData = function (format) {
          switch (format) {
          case 'yaml':
            var yaml = this._unescapeYamlIncludes(YAML.dump(JSON.parse(JSON.stringify(this.Data)), { lineWidth: -1 }));
            return '#%RAML ' + this.version() + '\n' + yaml;
          default:
            throw Error('RAML doesn not support ' + format + ' format');
          }
        };
        RAML.prototype.description = function (ramlDef, project) {
          throw new Error('description method not implemented');
        };
        RAML.prototype.version = function () {
          throw new Error('version method not implemented');
        };
        RAML.prototype.mapAuthorizationGrants = function (flow) {
          throw new Error('mapAuthorizationGrants method not implemented');
        };
        RAML.prototype.mapBody = function (bodyData) {
          throw new Error('mapBody method not implemented');
        };
        RAML.prototype.mapRequestBodyForm = function (bodyData) {
          throw new Error('mapRequestBodyForm method not implemented');
        };
        RAML.prototype.addSchema = function (ramlDef, schema) {
          throw new Error('addSchema method not implemented');
        };
        RAML.prototype.mapSchema = function (schema) {
          throw new Error('mapSchema method not implemented');
        };
        module.exports = RAML;
      },
      {
        '../helpers/raml': 20,
        '../utils/json': 33,
        './exporter': 13,
        'js-yaml': 56,
        'lodash': 109
      }
    ],
    13: [
      function (require, module, exports) {
        var YAML = require('js-yaml'), Importer = require('../importers/index');
        function Exporter() {
          this.data = null;
          this.project = null;
        }
        Exporter.prototype = {
          get Data() {
            return this.data;
          }
        };
        Exporter.prototype.loadSLData = function (rawData, cb) {
          var importer = Importer.factory({
              name: 'StopLight',
              className: 'StopLight'
            });
          var me = this;
          importer.loadData(rawData).then(function () {
            me.project = importer.import();
            cb();
          }).catch(function (err) {
            cb(err);
          });
        };
        Exporter.prototype.loadProject = function (project) {
          this.project = project;
        };
        Exporter.prototype._export = function () {
          throw new Error('_export method not implemented');
        };
        Exporter.prototype.export = function (format) {
          var me = this;
          return new Promise(function (resolve, reject) {
            try {
              me._export();
              var formattedData, exportedData = me._getData(format);
              if (typeof exportedData === 'object') {
                formattedData = JSON.stringify(exportedData);
              } else {
                formattedData = exportedData;
              }
              var importer = Importer.factory({
                  name: 'AUTO',
                  className: 'Auto'
                });
              importer.loadData(formattedData).then(function () {
                try {
                  importer.import();
                  resolve(exportedData);
                } catch (err) {
                  resolve(exportedData, err);
                }
              }).catch(function (err) {
                resolve(exportedData, err);
              });
            } catch (err) {
              reject(err, null);
            }
          });
        };
        Exporter.prototype._getData = function (format) {
          switch (format) {
          case 'yaml':
            return YAML.dump(JSON.parse(JSON.stringify(this.Data)), { lineWidth: -1 });
          default:
            return this.Data;
          }
        };
        Exporter.prototype._mapEndpoint = function () {
          throw new Error('_mapEndpoint method not implemented');
        };
        Exporter.prototype._mapSchema = function () {
          throw new Error('_mapSchema method not implemented');
        };
        Exporter.prototype._mapQueryString = function () {
          throw new Error('_mapQueryString method not implemented');
        };
        Exporter.prototype._mapURIParams = function () {
          throw new Error('_mapURIParams method not implemented');
        };
        Exporter.prototype._mapRequestBody = function () {
          throw new Error('_mapRequestBody method not implemented');
        };
        Exporter.prototype._mapResponseBody = function () {
          throw new Error('_mapResponseBody method not implemented');
        };
        Exporter.prototype._mapRequestHeaders = function () {
          throw new Error('_mapRequestHeaders method not implemented');
        };
        module.exports = Exporter;
      },
      {
        '../importers/index': 25,
        'js-yaml': 56
      }
    ],
    14: [
      function (require, module, exports) {
        var exporters = {
            Swagger: require('./swagger'),
            StopLightX: require('./stoplightx'),
            RAML08: require('./raml08'),
            RAML10: require('./raml10')
          };
        function hasFormatSupport(format) {
          if (!format || !format.name || !exporters.hasOwnProperty(format.className)) {
            return false;
          }
          return true;
        }
        module.exports = {
          hasSupport: hasFormatSupport,
          factory: function (format) {
            if (!hasFormatSupport(format)) {
              return null;
            }
            return new exporters[format.className]();
          }
        };
      },
      {
        './raml08': 15,
        './raml10': 16,
        './stoplightx': 17,
        './swagger': 18
      }
    ],
    15: [
      function (require, module, exports) {
        var RAML = require('./baseraml'), jsonHelper = require('../utils/json');
        function RAML08() {
        }
        RAML08.prototype = new RAML();
        RAML08.prototype.version = function () {
          return '0.8';
        };
        RAML08.prototype.mapAuthorizationGrants = function (flow) {
          var ag = [];
          switch (flow) {
          case 'implicit':
            ag = ['token'];
            break;
          case 'password':
            ag = ['credentials'];
            break;
          case 'application':
            ag = ['owner'];
            break;
          case 'accessCode':
            ag = ['code'];
            break;
          }
          return ag;
        };
        RAML08.prototype.mapRequestBodyForm = function (bodyData) {
          var body = { formParameters: bodyData.properties };
          if (bodyData.required && bodyData.required.length > 0) {
            for (var i in bodyData.required) {
              if (!bodyData.required.hasOwnProperty(i))
                continue;
              var requiredParam = bodyData.required[i];
              if (body['formParameters'][requiredParam]) {
                body['formParameters'][requiredParam].required = true;
              }
            }
          }
          return body;
        };
        RAML08.prototype.mapBody = function (bodyData) {
          return {
            schema: jsonHelper.format(bodyData.body),
            example: jsonHelper.format(bodyData.example)
          };
        };
        RAML08.prototype.addSchema = function (ramlDef, schema) {
          ramlDef.schemas = schema;
        };
        RAML08.prototype.mapSchema = function (slSchemas) {
          var results = [];
          for (var i in slSchemas) {
            if (!slSchemas.hasOwnProperty(i))
              continue;
            var schema = slSchemas[i];
            var resultSchema = {};
            resultSchema[schema.NameSpace] = this.convertRefFromModel(schema.Definition);
            results.push(resultSchema);
          }
          return results;
        };
        RAML08.prototype.description = function (ramlDef, project) {
          ramlDef.documentation = [{
              title: project.Name,
              content: project.Description
            }];
        };
        module.exports = RAML08;
      },
      {
        '../utils/json': 33,
        './baseraml': 12
      }
    ],
    16: [
      function (require, module, exports) {
        var RAML = require('./baseraml'), jsonHelper = require('../utils/json');
        function RAML10() {
        }
        RAML10.prototype = new RAML();
        RAML10.prototype.version = function () {
          return '1.0';
        };
        RAML10.prototype.mapAuthorizationGrants = function (flow) {
          var ag = [];
          switch (flow) {
          case 'implicit':
            ag = ['implicit'];
            break;
          case 'password':
            ag = ['password'];
            break;
          case 'application':
            ag = ['client_credentials'];
            break;
          case 'accessCode':
            ag = ['authorization_code'];
            break;
          }
          return ag;
        };
        RAML10.prototype.mapBody = function (bodyData) {
          var result = this.convertRefFromModel(jsonHelper.parse(bodyData.body));
          if (bodyData.example) {
            result.example = jsonHelper.format(bodyData.example);
          }
          return result;
        };
        RAML10.prototype.mapRequestBodyForm = function (bodyData) {
          var body = { properties: bodyData.properties };
          /**
     * Two different approaches to declare an optional parameter.
     * source https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#property-declarations
     * a) appending '?' to property name (without declaring required parameter).
     * b) set required = false
     */
          for (var i in body.properties) {
            if (!body.properties.hasOwnProperty(i))
              continue;
            var property = body.properties[i];
            property.required = false;
          }
          if (bodyData.required && bodyData.required.length > 0) {
            for (var j in bodyData.required) {
              if (!bodyData.required.hasOwnProperty(j))
                continue;
              var requiredParam = bodyData.required[j];
              if (body['properties'][requiredParam]) {
                body['properties'][requiredParam].required = true;
              }
            }
          }
          return body;
        };
        RAML10.prototype.addSchema = function (ramlDef, schema) {
          ramlDef.types = schema;
        };
        RAML10.prototype.mapSchema = function (slSchemas) {
          var results = {};
          for (var i in slSchemas) {
            if (!slSchemas.hasOwnProperty(i))
              continue;
            var schema = slSchemas[i];
            var definition = this.convertRefFromModel(schema.Definition);
            for (var i in definition.properties) {
              var property = definition.properties[i];
              property.required = false;
            }
            if (definition.required && definition.required.length > 0) {
              for (var j in definition.required) {
                var requiredParam = definition.required[j];
                if (definition['properties'][requiredParam]) {
                  delete definition['properties'][requiredParam].required;  // definition['properties'][requiredParam].required = true;
                }
              }
              delete definition.required;
            }
            if (definition.additionalProperties) {
              definition.properties['//'] = definition.additionalProperties;
              delete definition.additionalProperties;
            }
            if (definition.properties && definition.type == 'object') {
              delete definition.type;
            }
            if (schema.example) {
              definition.example = jsonHelper.parse(schema.example);
            }
            results[schema.NameSpace] = definition;
          }
          return results;
        };
        RAML10.prototype.description = function (ramlDef, project) {
          ramlDef.description = project.Description;
        };
        module.exports = RAML10;
      },
      {
        '../utils/json': 33,
        './baseraml': 12
      }
    ],
    17: [
      function (require, module, exports) {
        var Exporter = require('./exporter'), SwaggerExporter = require('./swagger'), _ = require('lodash');
        function StopLightX() {
        }
        var prefix = 'x-stoplight';
        var testsPrefix = 'x-tests';
        StopLightX.prototype = new Exporter();
        StopLightX.prototype._mapEndpoints = function () {
          var self = this;
          self.project.Endpoints.forEach(function (endpoint) {
            self.data.paths[endpoint.Path][endpoint.Method][prefix] = {
              id: endpoint.Id,
              beforeScript: endpoint.Before || null,
              afterScript: endpoint.After || null,
              public: endpoint.Public,
              mock: endpoint.Mock
            };
          });
        };
        StopLightX.prototype._mapSchemas = function () {
          var self = this;
          self.project.Schemas.forEach(function (schema) {
            self.data.definitions[schema.namespace][prefix] = {
              id: schema.Id,
              name: schema.Name,
              summary: schema.Summary,
              description: schema.Description,
              public: schema.Public
            };
          });
        };
        StopLightX.prototype._mapTests = function (tests, namespace) {
          return tests.reduce(function (res, test) {
            var exportTest = {
                id: test._id,
                name: test.name,
                initialVariables: {}
              };
            try {
              exportTest.initialVariables = JSON.parse(test.initialVariables);
            } catch (e) {
            }
            exportTest.steps = test.steps.map(function (step) {
              if (step.test) {
                return { $ref: '#/' + namespace + '/' + step.test };
              }
              var request = step.request;
              delete request.endpoint;
              if (_.get(request, 'authentication.authType') === 'none') {
                request.authentication = {};
              }
              if (!_.get(request, 'postData.params.length') && !_.get(request, 'postData.text.length')) {
                request.postData = {};
              } else {
                delete request.postData.stored;
              }
              var assertions = step.assertions.map(function (a) {
                  if (a.op && a.op.match(/validate/) && a.value) {
                    try {
                      a.value = JSON.parse(a.value);
                    } catch (e) {
                    }
                  }
                  return a;
                });
              return {
                id: step._id || step.id,
                name: step.name,
                beforeScript: step.middlewareBefore || step.beforeScript,
                afterScript: step.middlewareAfter || step.afterScript,
                capture: step.capture,
                request: request,
                assertions: assertions
              };
            });
            res[test._id] = exportTest;
            return res;
          }, {});
        };
        StopLightX.prototype._export = function () {
          var swaggerExporter = new SwaggerExporter();
          swaggerExporter.loadProject(this.project);
          swaggerExporter._export();
          this.data = swaggerExporter.data;
          var env = this.project.Environment;
          this._mapEndpoints();
          this._mapSchemas();
          this.data[prefix] = {
            beforeScript: env.MiddlewareBefore,
            afterScript: env.MiddlewareAfter,
            version: env.toJSON(),
            functions: this.project.UtilityFunctions.reduce(function (res, item) {
              res[item.name] = item.toJSON();
              return res;
            }, {}),
            textSections: this.project.Texts.reduce(function (res, item) {
              res[item.Id] = item.toJSON();
              return res;
            }, {})
          };
          this.data[testsPrefix] = this._mapTests(this.project.Tests, testsPrefix);
          if (env.proxy.mock) {
            this.data[prefix].mock = env.proxy.mock;
          }
        };
        module.exports = StopLightX;
      },
      {
        './exporter': 13,
        './swagger': 18,
        'lodash': 109
      }
    ],
    18: [
      function (require, module, exports) {
        var Endpoint = require('../entities/endpoint'), Exporter = require('./exporter'), SwaggerParser = require('swagger-parser'), jsonHelper = require('../utils/json.js'), stringHelper = require('../utils/strings.js'), SwaggerDefinition = require('../entities/swagger/definition'), swaggerHelper = require('../helpers/swagger'), _ = require('lodash'), url = require('url');
        function Swagger() {
          this.metadata = null;
        }
        function mapExample(data, target) {
          if (!_.isEmpty(data.example)) {
            var example = jsonHelper.parse(data.example);
            if (!_.isEmpty(example)) {
              target.example = example;
            }
          }
        }
        Swagger.prototype = new Exporter();
        Swagger.prototype._getResponseTypes = function (responses, defaultResponseType) {
          return responses.reduce(function (result, res) {
            if ((res.mimeType || _.isNull(res.mimeType)) && result.indexOf(res.mimeType) === -1 && res.mimeType !== defaultResponseType) {
              result.push(res.mimeType);
            }
            return result;
          }, []);
        };
        Swagger.prototype._getRequestTypes = function (endpoint, parameters, defaultRequestType) {
          var result = [], typesToInclude = [
              'multipart/form-data',
              'application/x-www-form-urlencoded'
            ], reqBody = endpoint.Body;
          for (var i in parameters) {
            if (parameters[i].type && parameters[i].type === 'file') {
              //consumes must have 'multipart/form-data' or 'application/x-www-form-urlencoded'
              if (reqBody && typesToInclude.indexOf(reqBody.mimeType) >= 0) {
                result.push(reqBody.mimeType);
              } else if (typesToInclude.indexOf(defaultRequestType) >= 0) {
                result.push(defaultRequestType);
              } else {
                //as swagger spec validation must want one of these, add one
                result.push(typesToInclude[0]);
              }
              //no need for the further iterations
              break;
            }
          }
          if (!_.isEmpty(endpoint.request.bodies)) {
            endpoint.request.bodies.forEach(function (request) {
              if ((request.mimeType || _.isNull(request.mimeType)) && request.mimeType !== defaultRequestType) {
                result.push(request.mimeType);
              }
            });
          }
          return _.uniq(result);
        };
        Swagger.prototype._validateParameters = function (parameters) {
          parameters = jsonHelper.orderByKeys(parameters, [
            '$ref',
            'name',
            'in',
            'description',
            'required',
            'schema',
            'type'
          ]);
          var validTypes = [
              'string',
              'number',
              'integer',
              'boolean',
              'array',
              'file'
            ], defaultType = 'string';
          for (var i in parameters) {
            if (parameters[i].in && parameters[i].in != 'body') {
              if (Array.isArray(parameters[i].type)) {
                if (parameters[i].type.length > 0) {
                  parameters[i].type = parameters[i].type[0];
                } else {
                  parameters[i].type = defaultType;
                }
              }
              if (validTypes.indexOf(parameters[i].type) < 0) {
                //type not valid
                parameters[i].type = defaultType;
              }
            }
          }
          return parameters;
        };
        Swagger.prototype._constructTags = function (endpoint, env) {
          var tags = endpoint.tags || [];
          var group = _.find(env.GroupsOrder.docs, function (g) {
              return _.find(g.items, [
                '_id',
                endpoint._id
              ]);
            });
          if (group) {
            tags.push(group.name);
          }
          return _.uniq(tags);
        };
        Swagger.prototype._constructSwaggerMethod = function (endpoint, parameters, responses, env) {
          var consumes = this._getRequestTypes(endpoint, parameters, env.DefaultRequestType);
          var produces = this._getResponseTypes(endpoint.Responses, env.defaultResponseType);
          endpoint.SetOperationId(endpoint.operationId, endpoint.Method, endpoint.Path);
          var resultSwaggerMethod = {
              tags: this._constructTags(endpoint, env),
              summary: endpoint.Name,
              description: endpoint.Description,
              operationId: endpoint.operationId,
              responses: responses
            };
          if (!_.isEmpty(consumes)) {
            resultSwaggerMethod.consumes = _.every(consumes, _.isNull) ? [] : consumes.filter(_.isString);
          }
          if (!_.isEmpty(produces)) {
            resultSwaggerMethod.produces = _.every(produces, _.isNull) ? [] : produces.filter(_.isString);
          }
          if (!_.isEmpty(parameters)) {
            resultSwaggerMethod.parameters = parameters;
          }
          if (_.isEmpty(resultSwaggerMethod.tags)) {
            delete resultSwaggerMethod.tags;
          }
          if (resultSwaggerMethod.operationId.length === 0) {
            //don't keep empty operationId in exported definition
            delete resultSwaggerMethod.operationId;
          }
          return resultSwaggerMethod;
        };
        Swagger.prototype._mapEndpointSecurity = function (securedByTypes, securityDefinitions) {
          var security = [];
          for (var type in securedByTypes) {
            var scheme = securityDefinitions[type];
            if (!scheme) {
              //definition error
              continue;
            }
            switch (type) {
            case 'basic':
              var result = {};
              if (scheme.name) {
                result[scheme.name] = [];
                security.push(result);
              }
              break;
            case 'apiKey':
              if (scheme.headers && scheme.headers.length > 0) {
                for (var i in scheme.headers) {
                  var result = {};
                  result[scheme.headers[i].name] = [];
                  security.push(result);
                }
              }
              if (scheme.queryString && scheme.queryString.length > 0) {
                for (var i in scheme.queryString) {
                  var result = {};
                  result[scheme.queryString[i].name] = [];
                  security.push(result);
                }
              }
              break;
            case 'oauth2':
              var result = {};
              result[type] = securedByTypes[type];
              security.push(result);
              break;
            }
          }
          return security;
        };
        Swagger.prototype._mapSecurityDefinitions = function (securityDefinitions) {
          var result = {};
          for (var type in securityDefinitions) {
            var sd = securityDefinitions[type];
            switch (type) {
            case 'apiKey':
              if (sd.hasOwnProperty('headers') && sd.headers.length > 0) {
                for (var i in sd.headers) {
                  var header = sd.headers[i];
                  result[header.name] = {
                    name: header.name,
                    type: type,
                    in: 'header'
                  };
                }
              }
              if (sd.hasOwnProperty('queryString') && sd.queryString.length > 0) {
                for (var i in sd.queryString) {
                  var header = sd.queryString[i];
                  result[header.name] = {
                    name: header.name,
                    type: type,
                    in: 'query'
                  };
                }
              }
              break;
            case 'oauth2':
              var slScopes = sd.scopes, swaggerScopes = {};
              for (var i in slScopes) {
                var scope = slScopes[i];
                swaggerScopes[scope.name] = scope.value;
              }
              result[type] = {
                type: type,
                flow: sd.flow,
                scopes: swaggerScopes
              };
              if ([
                  'implicit',
                  'accessCode'
                ].indexOf(sd.flow) >= 0) {
                result[type]['authorizationUrl'] = sd.authorizationUrl;
              }
              if ([
                  'password',
                  'application',
                  'accessCode'
                ].indexOf(sd.flow) >= 0) {
                result[type]['tokenUrl'] = sd.tokenUrl;
              }
              break;
            case 'basic':
              if (sd.name) {
                result[sd.name] = {
                  type: type,
                  description: sd.description || ''
                };
              }
              break;
            }
          }
          return result;
        };
        Swagger.prototype._mapURIParams = function (pathParams) {
          var parameters = [];
          if (!pathParams.properties || Object.keys(pathParams).length == 0) {
            return parameters;
          }
          for (var paramName in pathParams.properties) {
            var prop = pathParams.properties[paramName];
            var param = swaggerHelper.setParameterFields(prop, {});
            param.name = paramName;
            param.in = 'path';
            param.required = true;
            param.type = param.type || 'string';
            if (prop.description) {
              param.description = prop.description;
            }
            parameters.push(param);
          }
          return parameters;
        };
        Swagger.prototype._mapQueryString = function (queryStringParams) {
          var parameters = [];
          if (!queryStringParams.properties) {
            return parameters;
          }
          for (var paramName in queryStringParams.properties) {
            var param = swaggerHelper.setParameterFields(queryStringParams.properties[paramName], {});
            param.name = paramName;
            param.in = 'query';
            param.required = queryStringParams.required && queryStringParams.required.indexOf(param.name) >= 0;
            parameters.push(param);
          }
          return parameters;
        };
        function mapResponseBody(res) {
          var item = { description: res.description || '' };
          // if response body mimeType is null, do not include schema in swagger export
          if (!res.mimeType) {
            return item;
          }
          var body = jsonHelper.parse(res.body);
          if (body && Object.keys(body).length !== 0) {
            item.schema = convertRefFromModel(body);
          }
          if (res.example && res.example !== '{}' && res.example.length > 2) {
            item.examples = {};
            item.examples[res.mimeType] = jsonHelper.parse(res.example);
          }
          return item;
        }
        Swagger.prototype._mapResponseBody = function (slResponses) {
          var result = {};
          for (var i in slResponses) {
            var res = slResponses[i], item = mapResponseBody(res);
            result[res.codes && res.codes.length > 0 && parseInt(res.codes[0]) ? res.codes[0] : 'default'] = item;
          }
          if (Object.keys(result).length == 0) {
            //empty schema for swagger spec validation
            result['default'] = {
              description: '',
              schema: {}
            };
          }
          return result;
        };
        Swagger.prototype._mapRequestBody = function (slRequestBody, requestTypes) {
          if (!slRequestBody.body) {
            return [];
          }
          var result = [], body = jsonHelper.parse(slRequestBody.body) || {};
          var param = {};
          if (slRequestBody.description) {
            param.description = slRequestBody.description;
          }
          if (!jsonHelper.isEmptySchema(body)) {
            //make sure body isn't empty
            var regex = /\"type\":[ ]*\"file\"|\"type\":[ ]*\"binary\"/;
            //export as formData only if schema includes file type property
            if (slRequestBody.body.match(regex) || [
                'multipart/form-data',
                'application/x-www-form-urlencoded'
              ].indexOf(requestTypes[0]) !== -1) {
              for (var prop in body.properties) {
                param = body.properties[prop];
                param.in = 'formData';
                param.name = prop;
                if (body.required && body.required.indexOf(prop) >= 0) {
                  param.required = true;
                }
                result.push(param);
              }
            } else {
              if (body.required && body.required.length <= 0) {
                delete body.required;
              }
              mapExample(slRequestBody, body);
              param.name = 'body';
              param.in = 'body';
              param.schema = convertRefFromModel(body);
              result.push(param);
            }
          }
          return result;
        };
        Swagger.prototype._mapRequestHeaders = function (slHeaders) {
          var result = [];
          for (var property in slHeaders.properties) {
            var param = swaggerHelper.setParameterFields(slHeaders.properties[property], {});
            param.name = property;
            param.in = 'header';
            param.required = slHeaders.required && slHeaders.required.indexOf(property) >= 0;
            param.description = slHeaders.properties[property].description || '';
            result.push(param);
          }
          return result;
        };
        Swagger.prototype._mapSchema = function (slSchemas) {
          var result = {};
          for (var i in slSchemas) {
            var schema = slSchemas[i];
            var definition = convertRefFromModel(jsonHelper.parse(schema.Definition));
            mapExample(schema, definition);
            result[schema.NameSpace] = definition;
          }
          return result;
        };
        // from ref=type1 to $ref=#/definitions/type1
        function convertRefFromModel(object) {
          for (var id in object) {
            if (object.hasOwnProperty(id)) {
              var val = object[id];
              if (id == 'ref') {
                object.$ref = '#/definitions/' + val;
                delete object[id];
              } else if (id == 'include') {
                object.$ref = val;
                delete object[id];
              } else if (typeof val === 'object') {
                object[id] = convertRefFromModel(val);
              }
            }
          }
          return object;
        }
        Swagger.prototype._mapEndpointTraitParameters = function (endpoint, existingParams) {
          if (!endpoint.traits || !endpoint.traits.length) {
            return [];
          }
          var params = [];
          for (var i in endpoint.traits) {
            var trait = _.find(this.project.Traits, [
                '_id',
                endpoint.traits[i]
              ]);
            if (!trait) {
              continue;
            }
            try {
              var schema = JSON.parse(trait.request.queryString);
              for (var p in schema.properties) {
                // only add it if we didn't already explicitly define it in the operation
                if (!_.find(existingParams, {
                    name: p,
                    in: 'query'
                  })) {
                  params.push({ $ref: '#/parameters/' + stringHelper.computeTraitName(trait.name, p) });
                }
              }
            } catch (e) {
            }
            try {
              var schema = JSON.parse(trait.request.headers);
              for (var p in schema.properties) {
                // only add it if we didn't already explicitly define it in the operation
                if (!_.find(existingParams, {
                    name: p,
                    in: 'header'
                  })) {
                  params.push({ $ref: '#/parameters/' + stringHelper.computeTraitName(trait.name, p) });
                }
              }
            } catch (e) {
            }
          }
          return params;
        };
        Swagger.prototype._mapEndpointTraitResponses = function (endpoint) {
          if (!endpoint.traits || !endpoint.traits.length) {
            return [];
          }
          var result = {};
          for (var i in endpoint.traits) {
            var trait = _.find(this.project.Traits, [
                '_id',
                endpoint.traits[i]
              ]);
            if (!trait) {
              continue;
            }
            for (var i in trait.responses) {
              var res = trait.responses[i], code = res.codes && res.codes.length > 0 && parseInt(res.codes[0]) ? res.codes[0] : 'default';
              result[code] = { $ref: '#/responses/' + stringHelper.computeTraitName(trait.name, code) };
            }
          }
          return result;
        };
        Swagger.prototype._mapEndpoints = function (swaggerDef, env) {
          var endpoints = this.project.Endpoints;
          // Collect endpoints ids from environment resourcesOrder
          var orderedIds = env.resourcesOrder.docs.reduce(function (ids, group) {
              return ids.concat(_.map(_.filter(group.items, { type: 'endpoints' }), '_id'));
            }, []);
          // Sort endpoints similar to resourcesOrder items order
          endpoints.sort(function (a, b) {
            return orderedIds.indexOf(a._id) < orderedIds.indexOf(b._id) ? -1 : 1;
          });
          for (var i in endpoints) {
            var endpoint = endpoints[i], parameters = [];
            var requestTypes = this._getRequestTypes(endpoint, parameters, env.DefaultRequestType);
            // To build parameters we need to grab data from body for supported mimeTypes
            requestTypes = _.isEmpty(requestTypes) ? [env.DefaultRequestType] : requestTypes;
            if (!swaggerDef.paths[endpoint.Path]) {
              var params = this._validateParameters(this._mapURIParams(endpoint.PathParams));
              swaggerDef.paths[endpoint.Path] = params.length ? { parameters: params } : {};
            }
            parameters = parameters.concat(this._mapQueryString(endpoint.QueryString));
            if (!_.isEmpty(requestTypes)) {
              parameters = parameters.concat(this._mapRequestBody(endpoint.Body, requestTypes));
            }
            parameters = parameters.concat(this._mapRequestHeaders(endpoint.Headers));
            parameters = parameters.concat(this._mapEndpointTraitParameters(endpoint, parameters));
            parameters = this._validateParameters(parameters);
            var responses = _.assign({}, this._mapEndpointTraitResponses(endpoint), this._mapResponseBody(endpoint.Responses));
            if (_.isEmpty(this._getResponseTypes(endpoint.Responses))) {
              for (var statusCode in responses) {
                var response = responses[statusCode];
                delete response.schema;
              }
            }
            swaggerDef.paths[endpoint.Path][endpoint.Method] = this._constructSwaggerMethod(endpoint, parameters, responses, env);
            //Is it OK to include produces/consumes in all cases?
            var security = [];
            if (endpoint.SecuredBy) {
              var security = this._mapEndpointSecurity(endpoint.SecuredBy, this.project.Environment.SecuritySchemes);
              if (!_.isEmpty(security)) {
                swaggerDef.paths[endpoint.Path][endpoint.Method]['security'] = security;
              }
            }
          }
        };
        Swagger.prototype._mapTraitParameters = function (traits) {
          var parameters = {};
          for (var i in traits) {
            var trait = traits[i], params = [];
            try {
              var schema = JSON.parse(trait.request.queryString);
              if (!jsonHelper.isEmptySchema(schema)) {
                params = params.concat(this._validateParameters(this._mapQueryString(schema)));
              }
            } catch (e) {
            }
            try {
              var schema = JSON.parse(trait.request.headers);
              if (!jsonHelper.isEmptySchema(schema)) {
                params = params.concat(this._validateParameters(this._mapRequestHeaders(schema)));
              }
            } catch (e) {
            }
            for (var p in params) {
              var param = params[p];
              parameters[stringHelper.computeTraitName(trait.name, param.name)] = param;
            }
          }
          return parameters;
        };
        Swagger.prototype._mapTraitResponses = function (traits) {
          var responses = {};
          for (var i in traits) {
            var trait = traits[i];
            for (var i in trait.responses) {
              var res = trait.responses[i], item = mapResponseBody(res), responseName = stringHelper.computeTraitName(trait.name, res.codes && res.codes.length > 0 && parseInt(res.codes[0]) ? res.codes[0] : 'default');
              responses[responseName] = item;
            }
          }
          return responses;
        };
        Swagger.prototype._mapHostAndProtocol = function (env, swaggerDef) {
          var acceptedSchemes = [
              'http',
              'https',
              'ws',
              'wss'
            ];
          var hostUrl = url.parse(env.Host || '');
          var swaggerHost = hostUrl.hostname || '';
          if (swaggerHost && hostUrl.port) {
            swaggerHost = swaggerHost + ':' + hostUrl.port;
          }
          swaggerDef.Host = swaggerHost;
          if (!_.isEmpty(env.Protocols)) {
            var filteredSchemes = [];
            env.Protocols.map(function (p) {
              if (acceptedSchemes.indexOf(p.toLowerCase()) >= 0) {
                filteredSchemes.push(p.toLowerCase());
              }
            });
            swaggerDef.schemes = filteredSchemes;
          } else if (hostUrl.protocol) {
            swaggerDef.schemes = [hostUrl.protocol.split(':')[0]];
          } else {
            delete swaggerDef.schemes;
          }
        };
        Swagger.prototype._export = function () {
          //TODO
          var swaggerDef = new SwaggerDefinition(this.project.Name, this.project.Description);
          var env = this.project.Environment;
          swaggerDef.info.version = env.Version;
          swaggerDef.BasePath = env.BasePath || '';
          this._mapHostAndProtocol(env, swaggerDef);
          if (env.DefaultResponseType) {
            swaggerDef.produces = [env.DefaultResponseType];
          } else {
            delete swaggerDef.produces;
          }
          if (env.DefaultRequestType) {
            swaggerDef.consumes = [env.DefaultRequestType];
          } else {
            delete swaggerDef.consumes;
          }
          swaggerDef.definitions = this._mapSchema(this.project.Schemas);
          var parameters = this._mapTraitParameters(this.project.Traits);
          if (!_.isEmpty(parameters)) {
            swaggerDef.parameters = parameters;
          }
          var responses = this._mapTraitResponses(this.project.Traits);
          if (!_.isEmpty(responses)) {
            swaggerDef.responses = responses;
          }
          swaggerDef.securityDefinitions = this._mapSecurityDefinitions(this.project.Environment.SecuritySchemes);
          this._mapEndpoints(swaggerDef, env);
          //if not security definition added, then don't keep the field anymore
          if (swaggerDef.securityDefinitions && Object.keys(swaggerDef.securityDefinitions).length <= 0) {
            delete swaggerDef['securityDefinitions'];
          }
          this.data = jsonHelper.toJSON(swaggerDef);
        };
        module.exports = Swagger;
      },
      {
        '../entities/endpoint': 3,
        '../entities/swagger/definition': 8,
        '../helpers/swagger': 21,
        '../utils/json.js': 33,
        '../utils/strings.js': 34,
        './exporter': 13,
        'lodash': 109,
        'swagger-parser': 139,
        'url': 146
      }
    ],
    19: [
      function (require, module, exports) {
        var supportedFormats = {
            'POSTMAN': {
              name: 'Postman',
              className: 'Postman'
            },
            'RAML08': {
              name: 'RAML08',
              className: 'RAML08'
            },
            'RAML10': {
              name: 'RAML10',
              className: 'RAML10'
            },
            'SWAGGER': {
              name: 'Swagger',
              className: 'Swagger'
            },
            'STOPLIGHT': {
              name: 'StopLight',
              className: 'StopLight'
            },
            'STOPLIGHTX': {
              name: 'StopLightX',
              className: 'StopLightX'
            },
            'AUTO': {
              name: 'Auto',
              className: 'Auto'
            }
          };
        module.exports = supportedFormats;
      },
      {}
    ],
    20: [
      function (require, module, exports) {
        module.exports = {
          getScalarTypes: [
            'string',
            'number',
            'integer',
            'boolean',
            'date',
            'datetime',
            'date-only',
            'file',
            'array',
            'nilValue'
          ],
          parameterMappings: {},
          getSupportedParameterFields: [
            'displayName',
            'type',
            'description',
            'default',
            'maximum',
            'minimum',
            'maxLength',
            'minLength',
            'pattern',
            'enum'
          ],
          setParameterFields: function (source, target) {
            for (var prop in source) {
              if (this.getSupportedParameterFields.indexOf(prop) >= 0) {
                target[this.parameterMappings[prop] ? this.parameterMappings[prop] : prop] = typeof source[prop] === 'function' ? source[prop]() : source[prop];
                // call function if needed
                if (typeof target[prop] === 'function') {
                  target[prop] = target[prop]();
                }
                // transform Text nodes
                if (typeof target[prop] !== 'string' && target[prop] && target[prop].value) {
                  target[prop] = target[prop].value();
                }  // enums must be arrays
                else if (prop === 'enum' && typeof target[prop] === 'string') {
                  try {
                    target[prop] = JSON.parse(target[prop].replace(/\'/g, '"'));
                  } catch (e) {
                  }
                }
              }
            }
            return target;
          }
        };
      },
      {}
    ],
    21: [
      function (require, module, exports) {
        module.exports = {
          parameterMappings: {},
          getSupportedParameterFields: [
            'type',
            'description',
            'default',
            'maximum',
            'exclusiveMaximum',
            'minimum',
            'exclusiveMinimum',
            'maxLength',
            'minLength',
            'pattern',
            'maxItems',
            'minItems',
            'uniqueItems',
            'enum',
            'multipleOf',
            'items',
            'format'
          ],
          setParameterFields: function (source, target) {
            for (var prop in source) {
              if (this.getSupportedParameterFields.indexOf(prop) >= 0) {
                if (this.parameterMappings[prop]) {
                  target[this.parameterMappings[prop]] = source[prop];
                } else {
                  target[prop] = source[prop];
                }
                // description must be a string
                if (prop === 'description') {
                  target[prop] = String(target[prop]);
                }
                // enums must be arrays
                if (prop === 'enum' && typeof target[prop] === 'string') {
                  try {
                    target[prop] = JSON.parse(target[prop].replace(/\'/g, '"'));
                  } catch (e) {
                  }
                }
              }
            }
            return target;
          }
        };
      },
      {}
    ],
    22: [
      function (require, module, exports) {
        var fs = require('fs'), _ = require('lodash'), Importer = require('./importer'), Swagger = require('./swagger'), RAML08 = require('./raml08'), RAML10 = require('./raml10'), Postman = require('./postman'), StopLightX = require('./stoplightx'), urlHelper = require('../utils/url');
        // Detect input format automatically
        function Auto() {
          this.importer = null;
          this.detectedFormat = null;
        }
        Auto.prototype = new Importer();
        Auto.prototype.getDetectedFormat = function () {
          return this.detectedFormat;
        };
        Auto.prototype._parseStopLightX = function (data, resolve, reject) {
          var self = this, stopLightX = new StopLightX();
          stopLightX.loadData(data).then(function () {
            self.detectedFormat = 'STOPLIGHTX';
            self.data = stopLightX.data;
            self.importer = stopLightX;
            resolve();
          }).catch(reject);
        };
        Auto.prototype._parsePostman = function (data, resolve, reject) {
          var self = this, postman = new Postman();
          postman.loadData(data).then(function () {
            self.detectedFormat = 'POSTMAN';
            self.data = postman.data;
            self.importer = postman;
            resolve();
          }).catch(reject);
        };
        Auto.prototype._parseRAML = function (data, resolve, reject) {
          var self = this;
          var raml;
          var detectedFormat;
          if (/#%RAML[\s]*0\.?8?/.test(data)) {
            raml = new RAML08();
            detectedFormat = RAML08.name;
          } else if (/#%RAML[\s]*1\.?0?/.test(data)) {
            raml = new RAML10();
            detectedFormat = RAML10.name;
          }
          raml.loadData(data).then(function () {
            self.detectedFormat = detectedFormat;
            self.data = raml.data;
            self.importer = raml;
            resolve();
          }).catch(reject);
        };
        Auto.prototype._parseSwagger = function (data, resolve, reject) {
          var self = this, swagger = new Swagger();
          swagger.loadData(data).then(function () {
            self.detectedFormat = 'SWAGGER';
            self.data = swagger.data;
            self.importer = swagger;
            resolve();
          }).catch(reject);
        };
        Auto.prototype.detectFormat = function (data) {
          if (!data) {
            return;
          }
          var parsedData = _.trim(data);
          var type;
          try {
            parsedData = JSON.parse(data);
            type = 'json';
          } catch (err) {
            parsedData = data;
            type = 'yaml';
          }
          if (type === 'json') {
            if (parsedData.swagger) {
              return 'STOPLIGHTX';
            } else {
              return 'POSTMAN';
            }
          }
          if (type === 'yaml') {
            if (/#%RAML[\s]*0\.?8?/.test(parsedData)) {
              return RAML08.name;
            } else if (/#%RAML[\s]*1\.?0?/.test(parsedData)) {
              return RAML10.name;
            }
            if (/swagger:[\s'"]*\d\.?\d?/.test(parsedData)) {
              return 'SWAGGER';
            }
          }
          return 'UNKNOWN';
        };
        Auto.prototype.loadData = function (data) {
          var self = this, format = this.detectFormat(data);
          return new Promise(function (resolve, reject) {
            switch (format) {
            case 'STOPLIGHTX':
              return self._parseStopLightX(data, resolve, reject);
            case 'POSTMAN':
              return self._parsePostman(data, resolve, reject);
            case 'RAML08':
            case 'RAML10':
              return self._parseRAML(data, resolve, reject);
            case 'SWAGGER':
              return self._parseSwagger(data, resolve, reject);
            case 'UNKNOWN':
              return reject(new Error('Unable to parse file. Invalid or unsupported syntax.'));
            default:
              return reject(new Error('No data provided'));
            }
          });
        };
        Auto.prototype.loadFile = function (filePath, cb) {
          var self = this;
          if (urlHelper.isURL(filePath)) {
            // Remote file
            urlHelper.get(filePath).then(function (body) {
              self.loadData(body).then(cb).catch(cb);
            }).catch(cb);
          } else {
            // Local file
            var fileContent = fs.readFileSync(filePath, 'utf8');
            self.loadData(fileContent).then(cb).catch(cb);
          }
        };
        Auto.prototype._import = function () {
          this.importer._import();
          this.project = this.importer.project;
        };
        module.exports = Auto;
      },
      {
        '../utils/url': 35,
        './importer': 24,
        './postman': 26,
        './raml08': 27,
        './raml10': 28,
        './stoplightx': 30,
        './swagger': 31,
        'fs': 39,
        'lodash': 109
      }
    ],
    23: [
      function (require, module, exports) {
        var parser = window.RAML.Parser, Endpoint = require('../entities/endpoint'), Importer = require('./importer'), Project = require('../entities/project'), jsonHelper = require('../utils/json'), ramlHelper = require('../helpers/raml'), url = require('url'), _ = require('lodash');
        //TODO multi file support isn't justified
        function RAML() {
          this.schemas = [];
        }
        RAML.prototype = new Importer();
        RAML.prototype._getSecuritySchemeSettingsByName = function (schemeName) {
          var securitySchemes = this.data.securitySchemes();
          for (var i in securitySchemes) {
            if (schemeName === securitySchemes[i].name()) {
              return securitySchemes[i];
            }
          }
        };
        RAML.prototype._mapSecuritySchemes = function (securitySchemes) {
          var slSecurityScheme = {};
          for (var i in securitySchemes) {
            if (!securitySchemes.hasOwnProperty(i))
              continue;
            var securityScheme = securitySchemes[i];
            for (var name in securityScheme) {
              if (!securityScheme.hasOwnProperty(name))
                continue;
              var scheme = securityScheme[name];
              switch (scheme.type) {
              case 'OAuth 2.0':
                var oauth = {
                    name: name,
                    authorizationUrl: scheme.settings.authorizationUri || '',
                    tokenUrl: scheme.settings.accessTokenUri || '',
                    scopes: []
                  };
                if (Array.isArray(scheme.scopes)) {
                  for (var scopeIndex in scheme.scopes) {
                    if (!scheme.scopes.hasOwnProperty(scopeIndex))
                      continue;
                    oauth.scopes.push({
                      name: scheme.scopes[scopeIndex],
                      value: ''
                    });
                  }
                }
                //authorizationGrants are flow, only one supported in stoplight
                var flow = !_.isEmpty(scheme.settings.authorizationGrants) ? scheme.settings.authorizationGrants[0] : 'code';
                switch (flow) {
                case 'code':
                  oauth.flow = 'accessCode';
                  break;
                case 'token':
                  oauth.flow = 'implicit';
                  break;
                case 'owner':
                  oauth.flow = 'application';
                  break;
                case 'credentials':
                  oauth.flow = 'password';
                  break;
                }
                slSecurityScheme['oauth2'] = oauth;
                break;
              case 'Basic Authentication':
                slSecurityScheme['basic'] = {
                  name: name,
                  value: '',
                  description: scheme.description || ''
                };
                break;
              default:  //TODO not supported
              }
            }
          }
          return slSecurityScheme;
        };
        RAML.prototype._mapRequestBody = function (methodBody) {
          return this.mapRequestBody(methodBody);
        };
        RAML.prototype._mapQueryString = function (queryParameters) {
          var queryString = {
              type: 'object',
              properties: {},
              required: []
            };
          for (var key in queryParameters) {
            if (!queryParameters.hasOwnProperty(key))
              continue;
            var qp = queryParameters[key];
            queryString.properties[key] = ramlHelper.setParameterFields(qp, {});
            if (qp.required()) {
              queryString.required.push(key);
            }
          }
          return queryString;
        };
        RAML.prototype._mapRequestHeaders = function (data) {
          return this._mapQueryString(data);
        };
        RAML.prototype._mapURIParams = function (uriParams) {
          var pathParams = {
              type: 'object',
              properties: {},
              required: []
            };
          for (var i in uriParams) {
            if (!uriParams.hasOwnProperty(i))
              continue;
            var key = uriParams[i];
            pathParams.properties[key.name()] = {
              description: key.displayName() || key.description() || '',
              type: key.type() || 'string'
            };
          }
          return pathParams;
        };
        RAML.prototype._mapResponseBody = function (responses) {
          var data = [];
          for (var code in responses) {
            if (!responses.hasOwnProperty(code))
              continue;
            var response = responses[code];
            if (!response || !response.body || !response.body()) {
              continue;
            }
            var result = this._mapRequestBody(response.body());
            result.codes = [response.code().value()];
            if (result.body) {
              result.body = jsonHelper.cleanSchema(result.body);
            }
            if (result.example) {
              result.example = jsonHelper.stringify(result.example, 4);
            }
            if (response.description() && response.description().value) {
              result.description = response.description().value();
            }
            data.push(result);
          }
          return data;
        };
        RAML.prototype._mapSchema = function (schemData) {
          return this.mapSchema(schemData);
        };
        // from type=type1 to ref=type1
        RAML.prototype.convertRefToModel = function (object) {
          for (var id in object) {
            if (object.hasOwnProperty(id)) {
              var val = object[id];
              if (id == 'type' && typeof val === 'string' && ramlHelper.getScalarTypes.indexOf(val) < 0 && val !== 'object') {
                object.ref = val;
                delete object[id];
              } else if (typeof val === 'object') {
                if (val.type == 'date-only') {
                  object[id] = {
                    type: 'string',
                    format: 'date'
                  };
                } else if (val.type == 'datetime') {
                  object[id] = {
                    type: 'string',
                    format: 'date-time'
                  };
                } else {
                  object[id] = this.convertRefToModel(val);
                }
              }
            }
          }
          return object;
        };
        RAML.prototype._mapEndpoint = function (resource, baseURI, pathParams) {
          if (resource.uriParameters().length > 0) {
            pathParams = _.merge(pathParams, this._mapURIParams(resource.uriParameters()));
          }
          var methods = resource.methods();
          for (var i in methods) {
            if (!methods.hasOwnProperty(i))
              continue;
            var method = methods[i];
            var summary = method.name ? method.name() : '';
            // do we ever have a name or summary?
            var endpoint = new Endpoint(summary);
            endpoint.Method = method.method();
            endpoint.Path = baseURI + resource.relativeUri().value();
            endpoint.Description = method.description() ? method.description().value() : '';
            endpoint.SetOperationId(method.displayName ? method.displayName() : method.displayName, endpoint.Method, endpoint.Path);
            if (method.body()) {
              endpoint.Body = this._mapRequestBody(method.body());
            }
            if (method.queryParameters()) {
              endpoint.QueryString = this._mapQueryString(method.queryParameters());
            }
            if (method.headers()) {
              endpoint.Headers = this._mapRequestHeaders(method.headers());
            }
            if (method.responses()) {
              endpoint.Responses = this._mapResponseBody(method.responses());
            }
            endpoint.traits = [];
            var isMethod = method.is();
            if (isMethod) {
              if (isMethod instanceof Array) {
                endpoint.traits = isMethod;
              } else if (isMethod instanceof Object) {
                endpoint.traits = Object.keys(isMethod);
              }
            }
            endpoint.PathParams = pathParams;
            //endpoint security
            var securedBy = method.securedBy();
            if (Array.isArray(securedBy)) {
              endpoint.securedBy = {};
              for (var si in securedBy) {
                if (!securedBy.hasOwnProperty(si))
                  continue;
                var schemeSettings = this._getSecuritySchemeSettingsByName(securedBy[si].name());
                switch (schemeSettings.type()) {
                case 'OAuth 2.0':
                  endpoint.securedBy['oauth2'] = true;
                  break;
                case 'Basic Authentication':
                  endpoint.securedBy['basic'] = true;
                  break;
                default:
                  //TODO not supported
                  break;
                }
              }
            }
            //TODO endpoint security
            this.project.addEndpoint(endpoint);
          }
          var resources = resource.resources();
          if (resources && resources.length > 0) {
            for (var j = 0; j < resources.length; j++) {
              this._mapEndpoint(resources[j], baseURI + resource.relativeUri().value(), pathParams);
            }
          }
        };
        RAML.prototype.loadFile = function (filePath, cb) {
          var me = this;
          parser.loadApi(filePath).then(function (api) {
            me.data = parser.expander.expandTraitsAndResourceTypes(api);
            cb();
          }, function (error) {
            cb(error);
          });
        };
        RAML.prototype.loadFileWithOptions = function (filePath, options, cb) {
          var me = this;
          parser.loadApi(filePath, options).then(function (api) {
            me.data = parser.expander.expandTraitsAndResourceTypes(api);
            cb();
          }, function (error) {
            cb(error);
          });
        };
        RAML.prototype.loadData = function (data, options) {
          var me = this;
          return new Promise(function (resolve, reject) {
            var parsedData = parser.parseRAMLSync(data, options);
            if (parsedData.name === 'Error') {
              reject(error);
            } else {
              me.data = parser.expander.expandTraitsAndResourceTypes(parsedData);
              //me.data = parsedData.expand(true);
              resolve();
            }
          });
        };
        RAML.prototype._mapHost = function () {
          var parsedURL = url.parse(this.data.baseUri ? this.data.baseUri().value() : '');
          this.project.Environment.Host = parsedURL.protocol && parsedURL.host ? parsedURL.protocol + '//' + parsedURL.host : null;
          this.project.Environment.BasePath = parsedURL.path;
        };
        RAML.prototype._mapTraits = function (traitGroups) {
          var slTraits = [];
          for (var i in traitGroups) {
            if (!traitGroups.hasOwnProperty(i))
              continue;
            var traitGroup = traitGroups[i];
            for (var k in traitGroup) {
              if (!traitGroup.hasOwnProperty(k))
                continue;
              var trait = traitGroup[k], slTrait = {
                  _id: k,
                  name: k,
                  request: {},
                  responses: []
                };
              if (trait.queryParameters) {
                slTrait.request.queryString = this._mapQueryString(trait.queryParameters);
              }
              if (trait.headers) {
                slTrait.request.headers = this._mapRequestHeaders(trait.headers);
              }
              if (trait.responses) {
                slTrait.responses = this._mapResponse(trait.responses);
              }
              slTraits.push(slTrait);
            }
          }
          return slTraits;
        };
        RAML.prototype._import = function () {
          this.project = new Project(this.data.title());
          //TODO set project description from documentation
          //How to know which documentation describes the project briefly?
          this.description(this.project, this.data);
          this._mapHost();
          var mediaType = this.data.mediaType();
          if (!_.isEmpty(this.data.protocols())) {
            this.project.Environment.Protocols = this.data.protocols();
          }
          this.project.Environment.DefaultResponseType = '';
          if (mediaType) {
            if (Array.isArray(mediaType)) {
              if (mediaType.length > 0) {
                this.project.Environment.DefaultResponseType = mediaType[0].value();
              }
            } else {
              this.project.Environment.DefaultResponseType = mediaType.value();
            }
          }
          this.project.Environment.DefaultRequestType = this.project.Environment.DefaultResponseType;
          this.project.Environment.Version = this.data.version();
          this.project.Environment.SecuritySchemes = this._mapSecuritySchemes(this.data.securitySchemes());
          var resources = this.data.resources();
          for (var i = 0; i < resources.length; i++) {
            this._mapEndpoint(resources[i], '', {});
          }
          var schemas = this._mapSchema(this.getSchema(this.data));
          for (var s in schemas) {
            if (!schemas.hasOwnProperty(s))
              continue;
            this.project.addSchema(schemas[s]);
          }
          this.project.traits = this._mapTraits(this.data.traits());
        };
        RAML.prototype.description = function (project, data) {
          throw new Error('description method not implemented');
        };
        RAML.prototype.mapRequestBody = function (methodBody) {
          throw new Error('mapRequestBody method not implemented');
        };
        RAML.prototype.mapSchema = function (schema) {
          throw new Error('mapSchema method not implemented');
        };
        RAML.prototype.getSchema = function (data) {
          throw new Error('getSchema method not implemented');
        };
        module.exports = RAML;
      },
      {
        '../entities/endpoint': 3,
        '../entities/project': 5,
        '../helpers/raml': 20,
        '../utils/json': 33,
        './importer': 24,
        'lodash': 109,
        'url': 146
      }
    ],
    24: [
      function (require, module, exports) {
        function Importer() {
          this.data = null;
          this.project = null;
          this.mapped = false;
        }
        Importer.prototype = {
          get Mapped() {
            return this.mapped;
          },
          get IsDataLoaded() {
            return this.data !== null;
          }
        };
        Importer.prototype.loadFile = function (path) {
          throw new Error('loadFile method not implemented');
        };
        // todo unify api by returning a Promise like the loadData function
        Importer.prototype.loadFileWithOptions = function (path, options) {
          throw new Error('loadFile method not implemented');
        };
        Importer.prototype.loadData = function (data) {
          //TODO validation of the data
          this.data = data;
          return new Promise(function (resolve) {
            resolve();
          });
        };
        Importer.prototype._import = function () {
          throw new Error('_import method not implemented');
        };
        Importer.prototype.import = function () {
          if (!this.IsDataLoaded) {
            throw new Error('data not loaded for ' + this.constructor.name.toString());
          }
          if (!this.Mapped) {
            this._import();
            this.mapped = true;
          }
          return this.project;
        };
        Importer.prototype._mapEndpoint = function () {
          throw new Error('_mapEndpoint method not implemented');
        };
        Importer.prototype._mapSchema = function () {
          throw new Error('_mapSchema method not implemented');
        };
        Importer.prototype._mapQueryString = function () {
          throw new Error('_mapQueryString method not implemented');
        };
        Importer.prototype._mapURIParams = function () {
          throw new Error('_mapURIParams method not implemented');
        };
        Importer.prototype._mapRequestBody = function () {
          throw new Error('_mapRequestBody method not implemented');
        };
        Importer.prototype._mapResponseBody = function () {
          throw new Error('_mapResponseBody method not implemented');
        };
        Importer.prototype._mapRequestHeaders = function () {
          throw new Error('_mapRequestHeaders method not implemented');
        };
        module.exports = Importer;
      },
      {}
    ],
    25: [
      function (require, module, exports) {
        var importers = {
            Postman: require('./postman'),
            RAML08: require('./raml08'),
            RAML10: require('./raml10'),
            Swagger: require('./swagger'),
            StopLight: require('./stoplight'),
            StopLightX: require('./stoplightx'),
            Auto: require('./auto')
          };
        function doesSupportFormat(format) {
          if (!format || !format.name || !importers.hasOwnProperty(format.className)) {
            return false;
          }
          return true;
        }
        module.exports = {
          hasSupport: doesSupportFormat,
          factory: function (format) {
            if (!doesSupportFormat(format)) {
              return null;
            }
            return new importers[format.className]();
          }
        };
      },
      {
        './auto': 22,
        './postman': 26,
        './raml08': 27,
        './raml10': 28,
        './stoplight': 29,
        './stoplightx': 30,
        './swagger': 31
      }
    ],
    26: [
      function (require, module, exports) {
        var fs = require('fs'), Endpoint = require('../entities/endpoint'), SavedEntry = require('../entities/savedEntry'), Importer = require('./importer'), Project = require('../entities/project'), urlHelper = require('../utils/url'), jsonHelper = require('../utils/json'), arrayHelper = require('../utils/array'), _ = require('lodash');
        function Postman() {
        }
        Postman.prototype = new Importer();
        function transformVariableFormat(val) {
          if (!val)
            return null;
          return val.replace(/\{\{(.*)\}\}/i, '<<$1>>');
        }
        function parseQuery(qstr) {
          var query = {};
          if (qstr && qstr.length > 0) {
            var a = qstr.split('&');
            for (var i in a) {
              var b = a[i].split('=');
              if (!Array.isArray(b) || b.length <= 0)
                continue;
              query[decodeURIComponent(b[0])] = {
                type: 'string',
                default: transformVariableFormat(decodeURIComponent(b[1] || ''))
              };
            }
          }
          return {
            type: 'object',
            properties: query,
            required: []
          };
        }
        Postman.prototype._mapURIParams = function (data) {
          var pathParams = {};
          for (var key in data) {
            pathParams[key] = transformVariableFormat(data[key]);
          }
          return pathParams;
        };
        Postman.prototype._mapRequestHeaders = function (data) {
          var headerObj = {
              type: 'object',
              properties: {},
              required: []
            }, headers;
          headers = data.split('\n');
          for (var j in headers) {
            var header = headers[j];
            if (!header) {
              continue;
            }
            var keyValueParts = header.split(':');
            headerObj['properties'][keyValueParts[0]] = {
              type: 'string',
              default: transformVariableFormat(keyValueParts[1])
            };
          }
          return headerObj;
        };
        Postman.prototype._mapRequestBody = function (mode, requestData) {
          var data = {
              body: {
                type: 'object',
                properties: {},
                required: []
              }
            };
          //TODO map Body
          switch (mode) {
          case 'urlencoded':
            data.mimeType = 'application/x-www-form-urlencoded';
            break;
          case 'params':
            //check for best suitability
            data.mimeType = 'multipart/form-data';
            break;
          default:
            data.mimeType = 'text/plain';
            break;
          }
          for (var j in requestData) {
            var type = null;
            switch (requestData[j].type) {
            case 'text':
              type = 'string';
              break;
            default:
              type = 'binary';
            }
            data.body.properties[requestData[j].key] = {
              'type': type,
              'default': transformVariableFormat(requestData[j].value)
            };
          }
          return data;
        };
        Postman.prototype._mapEndpoint = function (pmr) {
          var endpoint, headers, v, queryString, urlParts;
          endpoint = new Endpoint(pmr.name);
          endpoint.Id = pmr.id;
          urlParts = pmr.url.split('?');
          endpoint.QueryString = parseQuery(urlParts[1]);
          endpoint.Path = transformVariableFormat(urlParts[0]);
          endpoint.Method = pmr.method;
          endpoint.Before = pmr.preRequestScript;
          endpoint.PathParams = this._mapURIParams(pmr.pathVariables);
          //parse headers
          endpoint.Headers = this._mapRequestHeaders(pmr.headers);
          endpoint.Body = this._mapRequestBody(pmr.dataMode, pmr.data);
          return endpoint;
        };
        function mapEndpointGroup(folder) {
          return {
            name: folder.name,
            items: folder.order
          };
        }
        Postman.prototype.loadData = function (data) {
          var me = this;
          return new Promise(function (resolve, reject) {
            me._parseData(data, function (err) {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          });
        };
        Postman.prototype._parseData = function (data, cb) {
          try {
            this.data = JSON.parse(data);
            cb();
          } catch (err) {
            cb(err);
          }
        };
        Postman.prototype.loadFile = function (filePath, cb) {
          var me = this;
          if (urlHelper.isURL(filePath)) {
            urlHelper.get(filePath).then(function (body) {
              me._parseData(body, cb);
            }).catch(cb);
          } else {
            var data = fs.readFileSync(filePath, 'utf8');
            me._parseData(data, cb);
          }
        };
        Postman.prototype._mergeEndpointHeaders = function (endpoints) {
          return jsonHelper.stringify({
            type: 'object',
            properties: endpoints.reduce(function (result, endpoint) {
              return _.merge(result, jsonHelper.parse(endpoint.Headers).properties);
            }, {}),
            required: []
          }, 4);
        };
        Postman.prototype._mergeEndpointQueryString = function (endpoints) {
          return jsonHelper.stringify({
            type: 'object',
            properties: endpoints.reduce(function (result, endpoint) {
              return _.merge(result, jsonHelper.parse(endpoint.QueryString).properties);
            }, {}),
            required: []
          }, 4);
        };
        Postman.prototype._mergeEndpointGroups = function (endpoints) {
          var endpoint = endpoints[0];
          if (endpoints.length <= 1) {
            return endpoint;
          }
          var headers = this._mergeEndpointHeaders(endpoints);
          var queryString = this._mergeEndpointQueryString(endpoints);
          endpoint.Name = endpoint.Path;
          endpoint.Headers = headers;
          endpoint.QueryString = queryString;
          // TODO maybe we should also merge pathParams and body
          return endpoint;
        };
        Postman.prototype._mergeEndpoints = function (endpoints) {
          var self = this;
          var groups = arrayHelper.groupBy(endpoints, function (endpoint) {
              return [
                endpoint.Path,
                endpoint.Method
              ];
            });
          return groups.map(function (group) {
            return self._mergeEndpointGroups(group);
          });
        };
        Postman.prototype._mapSavedEntry = function (pmr) {
          var savedEntry = new SavedEntry(pmr.name);
          var urlParts = pmr.url.split('?');
          savedEntry.Id = pmr.id;
          savedEntry.QueryString = parseQuery(urlParts[1]);
          savedEntry.Path = transformVariableFormat(urlParts[0]);
          savedEntry.Method = pmr.method;
          savedEntry.PathParams = this._mapURIParams(pmr.pathVariables);
          savedEntry.Headers = this._mapRequestHeaders(pmr.headers);
          if (savedEntry.Method.toLowerCase() !== 'get' && savedEntry.Method.toLowerCase() !== 'head') {
            savedEntry.Body = this._mapRequestBody(pmr.dataMode, pmr.data);
          }
          return savedEntry;
        };
        Postman.prototype._import = function () {
          var self = this;
          this.project = new Project(this.data.name || '');
          this.project.Description = this.data.description || '';
          var requests = this.data.requests || [];
          var folders = this.data.folders || [];
          // TODO process only unique requests
          var endpoints = requests.map(function (request) {
              return self._mapEndpoint(request);
            });
          this._mergeEndpoints(endpoints).forEach(function (endpoint) {
            self.project.addEndpoint(endpoint);
          });
          requests.map(function (request) {
            self.project.addSavedEntry(self._mapSavedEntry(request));
          });
          folders.forEach(function (folder) {
            self.project.environment.resourcesOrder.savedEntries.push({
              _id: folder.id,
              name: folder.name,
              items: folder.order.map(function (item) {
                return {
                  type: 'savedEntries',
                  _id: item
                };
              })
            });
          });  //disable temporarily
               //TODO
               /*for (var i = 0; i < this.data.folders.length; i++) {
   this.project.addEndpointGroup(mapEndpointGroup(this.data.folders[i]));
   }*/
        };
        module.exports = Postman;
      },
      {
        '../entities/endpoint': 3,
        '../entities/project': 5,
        '../entities/savedEntry': 6,
        '../utils/array': 32,
        '../utils/json': 33,
        '../utils/url': 35,
        './importer': 24,
        'fs': 39,
        'lodash': 109
      }
    ],
    27: [
      function (require, module, exports) {
        var RAML = require('./baseraml'), Schema = require('../entities/schema'), jsonHelper = require('../utils/json'), YAML = require('js-yaml'), Text = require('../entities/text');
        function RAML08() {
        }
        RAML08.prototype = new RAML();
        RAML08.prototype.mapRequestBody = function (methodBody) {
          var data = {
              mimeType: '',
              body: {},
              example: ''
            };
          //TODO: only one, the latest is in effect in stoplight!
          for (var i in methodBody) {
            if (!methodBody.hasOwnProperty(i))
              continue;
            var mimeType = methodBody[i];
            data.mimeType = mimeType.name();
            if (mimeType.example()) {
              data.example = mimeType.example().value();
            }
            if (mimeType.formParameters()) {
              data.body = {
                type: 'object',
                'properties': {},
                'required': []
              };
              var formParams = mimeType.formParameters();
              for (var j in formParams) {
                if (!formParams.hasOwnProperty(j))
                  continue;
                var param = formParams[j];
                var definition = jsonHelper.parse(YAML.load(param.dump()));
                for (var paramId in definition) {
                  if (!definition.hasOwnProperty(paramId))
                    continue;
                  var paramValue = definition[paramId];
                  data.body.properties[paramId] = paramValue;
                  if (paramValue.required && paramValue.required) {
                    data.body.required.push(paramId);
                  }
                }
              }
            }
            if (mimeType.schema && mimeType.schema()) {
              data.body = jsonHelper.parse(YAML.load(mimeType.dump())[mimeType.name()].schema);
            }
          }
          return data;
        };
        RAML08.prototype.mapSchema = function (schemData) {
          var schemas = [];
          for (var i in schemData) {
            if (!schemData.hasOwnProperty(i))
              continue;
            var schema = schemData[i];
            var schemaName = schema.key();
            var sd = new Schema(schemaName);
            sd.Name = schemaName;
            sd.Definition = this.convertRefToModel(jsonHelper.parse(YAML.load(schema.dump())[schemaName]));
            schemas.push(sd);
          }
          return schemas;
        };
        RAML08.prototype.getSchema = function (data) {
          return data.schemas();
        };
        RAML08.prototype.description = function (project, data) {
          var documentation = data.documentation();
          if (documentation && documentation.length > 0) {
            project.Description = documentation[0].content().value();
            project.Environment.summary = documentation[0].content().value();
          }
          // text sections
          if (documentation) {
            for (var d in documentation) {
              if (!documentation.hasOwnProperty(d))
                continue;
              var txt = new Text(documentation[d].title());
              txt.Public = true;
              txt.Content = documentation[d].content().value();
              this.project.addText(txt);
            }
          }
        };
        module.exports = RAML08;
      },
      {
        '../entities/schema': 7,
        '../entities/text': 10,
        '../utils/json': 33,
        './baseraml': 23,
        'js-yaml': 56
      }
    ],
    28: [
      function (require, module, exports) {
        var RAML = require('./baseraml'), Schema = require('../entities/schema'), jsonHelper = require('../utils/json'), YAML = require('js-yaml'), _ = require('lodash');
        function RAML10() {
        }
        RAML10.prototype = new RAML();
        RAML10.prototype.mapRequestBody = function (methodBody) {
          var data = { mimeType: '' };
          //TODO: only one, the latest is in effect in stoplight!
          for (var i in methodBody) {
            if (!methodBody.hasOwnProperty(i))
              continue;
            var mimeType = methodBody[i];
            data.mimeType = mimeType.name();
            if (mimeType.example()) {
              data.example = mimeType.example().value();
            }
            if (mimeType.description()) {
              data.description = mimeType.description().value();
            }
            if (mimeType.properties && !_.isEmpty(mimeType.properties())) {
              switch (data.mimeType) {
              case 'application/json':
                data.body = YAML.load(mimeType.dump())[data.mimeType];
                break;
              case 'multipart/form-data':
              case 'application/x-www-form-urlencoded':
                data.body = {
                  type: 'object',
                  'properties': {},
                  'required': []
                };
                var formParams = mimeType.properties();
                for (var j in formParams) {
                  if (!formParams.hasOwnProperty(j))
                    continue;
                  var param = formParams[j];
                  var bodyType = !_.isEmpty(param.type()) ? param.type()[0] : param.type();
                  data.body.properties[param.name()] = { type: bodyType };
                  if (param.description()) {
                    data.body.properties[param.name()].description = param.description().value();
                  }
                  if (param.format) {
                    data.body.properties[param.name()].format = param.format();
                  }
                  if (param.required() == true) {
                    data.body.required.push(param.name());
                  }
                }
                break;
              default:
              }
            } else if (mimeType.schema && !_.isEmpty(mimeType.schema())) {
              data.body = this.convertRefToModel({ type: jsonHelper.parse(mimeType.schema()[0]) });
            } else if (mimeType.type && !_.isEmpty(mimeType.type()) && mimeType.type()[0] !== 'object') {
              data.body = this.convertRefToModel({ type: jsonHelper.parse(mimeType.type()[0]) });
            }
          }
          return data;
        };
        RAML10.prototype.mapSchema = function (schemData) {
          var schemas = [];
          for (var i in schemData) {
            if (!schemData.hasOwnProperty(i))
              continue;
            var schema = schemData[i];
            var schemaName = schema.name();
            var sd = new Schema(schemaName);
            sd.Name = schemaName;
            var definition;
            if (jsonHelper.isEmptySchema(schema)) {
              definition = YAML.load(schema.dump())[schemaName];
            } else {
              if (schema.type && !_.isEmpty(schema.type())) {
                definition = jsonHelper.parse(schema.type()[0]);
              }
            }
            if (definition.properties && !_.isEmpty(definition.properties)) {
              var data = {
                  properties: {},
                  type: 'object',
                  required: []
                };
              if (definition.description) {
                data.description = definition.description;
              }
              for (var paramName in definition.properties) {
                var param = definition.properties[paramName];
                data.properties[paramName] = param;
                if (param.hasOwnProperty('required')) {
                  if (param.required == true) {
                    data['required'].push(paramName);
                  }
                  delete param.required;
                } else {
                  //required true by default.
                  data['required'].push(paramName);
                }
              }
              definition = data;
            }
            if (data.required.length == 0) {
              delete data.required;
            }
            sd.Definition = this.convertRefToModel(definition);
            schemas.push(sd);
          }
          return schemas;
        };
        RAML10.prototype.getSchema = function (data) {
          return data.types();
        };
        RAML10.prototype.description = function (project, data) {
          if (data.description && data.description()) {
            project.Description = data.description().value();
          }
        };
        module.exports = RAML10;
      },
      {
        '../entities/schema': 7,
        '../utils/json': 33,
        './baseraml': 23,
        'js-yaml': 56,
        'lodash': 109
      }
    ],
    29: [
      function (require, module, exports) {
        var Endpoint = require('../entities/endpoint'), Project = require('../entities/project'), Schema = require('../entities/schema'), UtilityFunction = require('../entities/utilityFunction'), Text = require('../entities/text'), Importer = require('./importer'), jsonHelper = require('../utils/json'), fs = require('fs');
        function StopLight() {
          this.metadata = null;
        }
        StopLight.prototype = new Importer();
        StopLight.prototype.loadFile = function (path, cb) {
          try {
            this.data = JSON.parse(fs.readFileSync(path, 'utf8'));
            cb();
          } catch (err) {
            cb(err);
          }
        };
        StopLight.prototype._mapSchema = function () {
          for (var i in this.data.project.schemas) {
            var schemaData = this.data.project.schemas[i];
            schemaData.namespace = schemaData.namespace.replace('#/definitions/', '');
            var schema = new Schema(schemaData.namespace);
            schema.SLData = schemaData;
            this.project.addSchema(schema);
          }
        };
        StopLight.prototype.mapEndpoint = function () {
          //all formats are going throught stoplight endpoint, no need to map itself
          for (var i in this.data.project.endpoints) {
            var endpointData = this.data.project.endpoints[i];
            var endpoint = new Endpoint('');
            endpoint.SLData = endpointData;
            this.project.addEndpoint(endpoint);
          }
        };
        StopLight.prototype.mapUtilityFunctions = function () {
          for (var i in this.data.project.utilityFunctions) {
            var ufData = this.data.project.utilityFunctions[i];
            var uf = new UtilityFunction(ufData.name);
            uf.Description = ufData.description;
            uf.Script = ufData.script;
            this.project.addUtilityFunction(uf);
          }
        };
        StopLight.prototype.mapTexts = function () {
          for (var i in this.data.project.texts) {
            var txt = this.data.project.texts[i];
            var text = new Text(txt.name);
            text.Id = txt._id;
            text.Name = txt.name;
            text.Content = txt.content;
            text.Public = txt.public;
            this.project.addText(text);
          }
        };
        StopLight.prototype.mapTraits = function () {
          this.project.traits = this.data.project.traits;
        };
        StopLight.prototype.mapSecuritySchemes = function () {
          this.project.SecuritySchemes = this.data.project.securitySchemes;
        };
        StopLight.prototype._import = function () {
          var projectName, projectDesc;
          if (!this.data.project) {
            throw new Error('Invalid formatted stoplight data');
          }
          this.project = new Project(this.data.project.name);
          this.project.loadSLData(this.data.project);
          this.project.Environment.loadSLData(this.data.project.environment);
          this.mapEndpoint();
          this._mapSchema();
          this.mapUtilityFunctions();
          this.mapSecuritySchemes();
          this.mapTexts();
          this.mapTraits();
          if (this.data.project.resourcesOrder) {
            this.project.GroupsOrder = this.data.project.resourcesOrder;
          }
        };
        module.exports = StopLight;
      },
      {
        '../entities/endpoint': 3,
        '../entities/project': 5,
        '../entities/schema': 7,
        '../entities/text': 10,
        '../entities/utilityFunction': 11,
        '../utils/json': 33,
        './importer': 24,
        'fs': 39
      }
    ],
    30: [
      function (require, module, exports) {
        var Swagger = require('./swagger'), Importer = require('./importer'), UtilityFunction = require('../entities/utilityFunction'), Text = require('../entities/text'), Test = require('../entities/test'), fs = require('fs'), _ = require('lodash');
        var prefix = 'x-stoplight';
        var testsPrefix = 'x-tests';
        function StopLightX() {
          this.metadata = null;
          this.importer = new Swagger();
        }
        StopLightX.prototype = new Importer();
        StopLightX.prototype.loadFile = function (path, cb) {
          var me = this;
          return this.importer.loadFile(path, function (err) {
            me.data = me.importer.data;
            cb(err);
          });
        };
        StopLightX.prototype.loadData = function (path) {
          var me = this;
          return new Promise(function (resolve, reject) {
            me.importer.loadData(path).then(function () {
              me.data = me.importer.data;
              resolve();
            }).catch(function (err) {
              reject(err);
            });
          });
        };
        StopLightX.prototype._import = function () {
          this.project = this.importer.import();
          var data = this.importer.data;
          if (!data.hasOwnProperty(prefix)) {
            return;
          }
          var environment = this.project.Environment;
          var stoplightData = data[prefix];
          if (stoplightData.hasOwnProperty('version')) {
            environment.loadSLData(data[prefix].version);
            //property names are different from db name
            environment.GroupsOrder = data[prefix].version.groups;
            environment.MiddlewareBefore = data[prefix].beforeScript;
            environment.MiddlewareAfter = data[prefix].afterScript;
            this.project.Environment = environment;
          }
          for (var name in data[prefix].functions) {
            var ufData = data[prefix].functions[name];
            var uf = new UtilityFunction(ufData.name);
            uf.Description = ufData.description;
            uf.Script = ufData.script;
            this.project.addUtilityFunction(uf);
          }
          for (var name in data[prefix].textSections) {
            var txtData = data[prefix].textSections[name];
            var txt = new Text(txtData.name);
            txt.Id = txtData.id;
            txt.Content = txtData.content;
            txt.Public = txtData.public;
            this.project.addText(txt);
          }
          for (var i in this.project.Endpoints) {
            var endpoint = this.project.Endpoints[i];
            var method = data.paths[endpoint.Path][endpoint.Method][prefix];
            if (method) {
              endpoint.Before = method['beforeScript'];
              endpoint.After = method['afterScript'];
              endpoint.Mock = method['mock'];
              endpoint.Id = method['id'];
            }
          }
          for (var i in this.project.Schemas) {
            var schema = this.project.Schemas[i];
            var schemaData = data.definitions[schema.NameSpace][prefix];
            if (schemaData) {
              schema.Id = schemaData.id;
              schema.Name = schemaData.name;
              schema.Summary = schemaData.summary;
              schema.Description = schemaData.description;
              schema.Public = schemaData.public;
            }
          }
          if (data.hasOwnProperty(testsPrefix)) {
            for (var id in data[testsPrefix]) {
              var testData = data[testsPrefix][id];
              var test = new Test(testData.name);
              test.Id = testData.id;
              test.Summary = testData.summary;
              test.InitialVariables = testData.initialVariables;
              test.Steps = testData.steps.map(function (step) {
                if (step.$ref) {
                  var parts = step.$ref.split('/');
                  var stepId = _.last(parts);
                  return { test: stepId };
                }
                return step;
              });
              this.project.addTest(test);
            }
          }
        };
        module.exports = StopLightX;
      },
      {
        '../entities/test': 9,
        '../entities/text': 10,
        '../entities/utilityFunction': 11,
        './importer': 24,
        './swagger': 31,
        'fs': 39,
        'lodash': 109
      }
    ],
    31: [
      function (require, module, exports) {
        var parser = require('swagger-parser'), Endpoint = require('../entities/endpoint'), Schema = require('../entities/schema'), Importer = require('./importer'), Project = require('../entities/project'), jsonHelper = require('../utils/json'), swaggerHelper = require('../helpers/swagger'), YAML = require('js-yaml'), _ = require('lodash');
        function Swagger() {
          this.dereferencedAPI = null;
        }
        var referenceRegex = /\/(parameters|responses)\//i;
        function needDeReferenced(param) {
          if (!param || !param.$ref) {
            return false;
          }
          return param.$ref.match(referenceRegex);
        }
        function mapExample(data, target) {
          if (data.example) {
            target.example = jsonHelper.stringify(data.example, 4);
            delete data.example;
          }
        }
        Swagger.prototype = new Importer();
        Swagger.prototype._mapSecurityDefinitions = function (securityDefinitions) {
          var result = {};
          for (var name in securityDefinitions) {
            if (!securityDefinitions.hasOwnProperty(name))
              continue;
            var type = securityDefinitions[name].type;
            if (!result.hasOwnProperty(type)) {
              result[type] = {};
            }
            var sd = securityDefinitions[name];
            switch (type) {
            case 'apiKey':
              var keyPlaceHolder = sd.in === 'header' ? 'headers' : 'queryString';
              if (!result[type].hasOwnProperty(keyPlaceHolder)) {
                result[type][keyPlaceHolder] = [];
              }
              result[type][keyPlaceHolder].push({
                externalName: name,
                name: sd.name,
                value: '',
                description: sd.description
              });
              break;
            case 'oauth2':
              result[type] = {
                name: name,
                authorizationUrl: sd.authorizationUrl || '',
                tokenUrl: sd.tokenUrl || ''
              };
              var slScopes = [], swaggerScopes = sd.scopes;
              if (swaggerScopes) {
                for (var key in swaggerScopes) {
                  if (!swaggerScopes.hasOwnProperty(key))
                    continue;
                  var scope = {};
                  scope['name'] = key;
                  scope['value'] = swaggerScopes[key];
                  slScopes.push(scope);
                }
              }
              if (sd.flow) {
                result[type]['flow'] = sd.flow;
              }
              if (!_.isEmpty(slScopes)) {
                result[type]['scopes'] = slScopes;
              }
              break;
            case 'basic':
              result[type] = {
                name: name,
                value: '',
                description: sd.description || ''
              };
              break;
            }
          }
          return result;
        };
        Swagger.prototype._mapSchema = function (schemaDefinitions) {
          var result = [];
          for (var schemaName in schemaDefinitions) {
            if (!schemaDefinitions.hasOwnProperty(schemaName))
              continue;
            var sd = new Schema(schemaName);
            sd.Name = schemaName;
            //create a close to remove extension properties
            var schemaDataClone = _.clone(schemaDefinitions[schemaName]);
            var re = /^x-/;
            //properties to avoid
            for (var prop in schemaDataClone) {
              if (schemaDataClone.hasOwnProperty(prop) && prop.match(re)) {
                delete schemaDataClone[prop];
              }
            }
            mapExample(schemaDataClone, sd);
            if (schemaDataClone['allOf']) {
              schemaDataClone = schemaDataClone['allOf'];
            }
            sd.Definition = convertRefToModel(schemaDataClone);
            result.push(sd);
          }
          return result;
        };
        // from $ref=#/definitions/type1 to ref=type1
        function convertRefToModel(object) {
          for (var id in object) {
            if (object.hasOwnProperty(id)) {
              var val = object[id];
              if (id == '$ref') {
                if (val.indexOf('#/') == 0) {
                  object.ref = val.replace('#/definitions/', '');
                } else {
                  object.include = val;
                }
                delete object[id];
              } else if (typeof val === 'object') {
                object[id] = convertRefToModel(val);
              }
            }
          }
          return object;
        }
        Swagger.prototype._mapQueryString = function (params, skipParameterRefs) {
          var queryString = {
              type: 'object',
              properties: {},
              required: []
            };
          for (var i in params) {
            if (!params.hasOwnProperty(i))
              continue;
            var param = params[i];
            if (skipParameterRefs && needDeReferenced(param)) {
              continue;
            }
            if (param.in && param.in !== 'query') {
              //skip other type of params
              continue;
            }
            queryString.properties[param.name] = swaggerHelper.setParameterFields(param, {});
            if (param.required) {
              queryString.required.push(param.name);
            }
          }
          return queryString;
        };
        Swagger.prototype._mapURIParams = function (params, resolvedParameters) {
          var pathParams = {
              type: 'object',
              properties: {},
              required: []
            };
          for (var i in params) {
            if (!params.hasOwnProperty(i))
              continue;
            var param = params[i];
            if (needDeReferenced(param) && resolvedParameters) {
              param = resolvedParameters[i];
            }
            if (param.in && param.in !== 'path') {
              //skip other type of params
              continue;
            }
            pathParams.properties[param.name] = swaggerHelper.setParameterFields(param, {});
            pathParams.required.push(param.name);
          }
          return pathParams;
        };
        Swagger.prototype._mapRequestBody = function (params, reqType, resolvedParams) {
          if (_.isEmpty(params) || !_.some(params, { 'in': 'body' }) && !_.some(params, { 'in': 'formData' })) {
            return;
          }
          var data = {
              mimeType: reqType || null,
              body: {
                properties: {},
                required: []
              },
              example: ''
            };
          for (var i in params) {
            if (!params.hasOwnProperty(i))
              continue;
            var param = params[i];
            if (needDeReferenced(param)) {
              param = resolvedParams[i];
            }
            if (param.in && param.in !== 'body' && param.in !== 'formData') {
              continue;
            }
            switch (param.in) {
            case 'body':
              data.mimeType = data.mimeTypes || 'application/json';
              mapExample(param.schema, data);
              data.body = convertRefToModel(param.schema);
              break;
            case 'formData':
              data.mimeType = data.mimeTypes || 'multipart/form-data';
            default:
              var prop = {};
              prop = swaggerHelper.setParameterFields(param, prop);
              if (param.required) {
                data.body.required.push(param.name);
              }
              data.body.properties[param.name] = prop;
            }
            if (param.description) {
              data.description = param.description;
            }
          }
          //remove required field if doesn't have anything inside it
          if (data.body.required && data.body.required.length == 0) {
            delete data.body.required;
          }
          return data;
        };
        Swagger.prototype._mapResponseBody = function (responseBody, resType, skipParameterRefs, resolvedResponses) {
          var data = [];
          for (var code in responseBody) {
            if (!responseBody.hasOwnProperty(code))
              continue;
            var res = {
                mimeType: resType,
                body: {},
                example: '',
                codes: []
              }, description = '';
            if (skipParameterRefs && needDeReferenced(responseBody[code]) && responseBody[code].$ref.match(/trait/)) {
              continue;
            }
            // TODO: Once we support headers, then support headers from swagger spec in responses.
            if (needDeReferenced(responseBody[code]) && resolvedResponses) {
              schema = resolvedResponses[code].schema;
              description = resolvedResponses[code].description || '';
              res.body = schema;
            } else if (responseBody[code].schema) {
              var schema = responseBody[code].schema;
              if (needDeReferenced(responseBody[code].schema)) {
                description = resolvedResponses[code].description || '';
                schema = resolvedResponses[code].schema;
              }
              res.body = schema;
            }
            if (responseBody[code].hasOwnProperty('examples')) {
              var examples = responseBody[code].examples;
              for (var t in examples) {
                if (!examples.hasOwnProperty(t))
                  continue;
                if (t === resType) {
                  res.example = jsonHelper.stringify(examples[t], 4);
                }
              }
            }
            res.description = description || responseBody[code].description || '';
            res.body = convertRefToModel(res.body);
            res.codes.push(String(code));
            data.push(res);
          }
          return data;
        };
        Swagger.prototype._mapRequestHeaders = function (params, skipParameterRefs) {
          var data = {
              type: 'object',
              properties: {},
              required: []
            };
          for (var i in params) {
            if (!params.hasOwnProperty(i))
              continue;
            var param = params[i];
            if (skipParameterRefs && needDeReferenced(param)) {
              continue;
            }
            if (param.in !== 'header') {
              //skip other type of params
              continue;
            }
            data.properties[param.name] = swaggerHelper.setParameterFields(param, {});
            if (param.required) {
              data.required.push(param.name);
            }
          }
          return data;
        };
        Swagger.prototype._parseData = function (dataOrPath, cb, options) {
          var me = this;
          var validateOptions = _.cloneDeep(options || {});
          validateOptions.validate = {
            schema: false,
            spec: false
          };
          // with validation
          //in case of data, if not cloned, referenced to resolved data
          var dataCopy = _.cloneDeep(dataOrPath);
          parser.validate(dataCopy, validateOptions).then(function () {
            me._doParseData(dataOrPath, cb, options || {});
          }).catch(cb);
        };
        Swagger.prototype._doParseData = function (dataOrPath, cb, options) {
          var me = this;
          // without validation
          parser.parse(dataOrPath, options, function (err, api) {
            if (err) {
              cb(err);
            } else {
              me.data = api;
              if (typeof dataOrPath === 'string') {
                var parseFn = parser.dereference(dataOrPath, JSON.parse(JSON.stringify(api)), options);
              } else {
                parseFn = parser.dereference(JSON.parse(JSON.stringify(api)), options);
              }
              parseFn.then(function (dereferencedAPI) {
                if (options && options.expand) {
                  me.data = dereferencedAPI;
                } else {
                  me.dereferencedAPI = dereferencedAPI;
                }
                cb();
              }).catch(cb);
            }
          });
        };
        // Load a swagger spec by local or remote file path
        Swagger.prototype.loadFile = function (path, cb) {
          return this._parseData(path, cb);
        };
        // Load a swagger spec by local or remote file path with given swagger parser options
        Swagger.prototype.loadFileWithOptions = function (path, options, cb) {
          return this._parseData(path, cb, options);
        };
        // Load a swagger spec by string data
        Swagger.prototype.loadData = function (data, options) {
          var self = this, parsedData;
          return new Promise(function (resolve, reject) {
            try {
              parsedData = JSON.parse(data);
            } catch (err) {
              // Possibly YAML Data
              try {
                parsedData = YAML.safeLoad(data, { json: true });
              } catch (err) {
                return reject(err);
              }
            }
            self._parseData(parsedData, function (err) {
              if (err) {
                return reject(err);
              }
              resolve();
            }, options);
          });
        };
        //for now, if 'application/json' exist in supported type, use that
        Swagger.prototype.findDefaultMimeType = function (mimeTypes) {
          if (!mimeTypes || mimeTypes.length <= 0) {
            return null;
          }
          for (var i in mimeTypes) {
            if (!mimeTypes.hasOwnProperty(i))
              continue;
            if (mimeTypes[i] === 'application/json') {
              return mimeTypes[i];
            }
          }
          return mimeTypes[0];
        };
        Swagger.prototype._mapEndpointTrait = function (params) {
          var traits = [];
          for (var i in params) {
            if (!params.hasOwnProperty(i))
              continue;
            var param = params[i];
            if (!needDeReferenced(param)) {
              continue;
            }
            var parts = param.$ref.split('/'), traitParts = parts[parts.length - 1].split(':'), name = traitParts[0];
            if (traitParts[0] === 'trait') {
              name = traitParts[1];
            }
            traits.push(name);
          }
          return traits;
        };
        Swagger.prototype._mapEndpointTraits = function (params, responses) {
          var traits = [];
          traits = traits.concat(this._mapEndpointTrait(params));
          traits = traits.concat(this._mapEndpointTrait(responses));
          return _.uniq(traits);
        };
        Swagger.prototype._mapEndpoints = function (defaultReqContentType, defaultResContentType) {
          for (var path in this.data.paths) {
            if (!this.data.paths.hasOwnProperty(path))
              continue;
            var methods = this.data.paths[path];
            var pathParams = {};
            if (methods.parameters) {
              var resolvedPathParames = this.dereferencedAPI ? this.dereferencedAPI.paths[path].parameters : methods.parameters;
              pathParams = this._mapURIParams(methods.parameters, resolvedPathParames);
            }
            for (var method in methods) {
              if (!methods.hasOwnProperty(method))
                continue;
              var currentMethod = methods[method];
              var currentMethodResolved = this.dereferencedAPI ? this.dereferencedAPI.paths[path][method] : currentMethod;
              if (method === 'parameters') {
                continue;
              }
              var endpoint = new Endpoint(currentMethod.summary || ''), reqType = defaultReqContentType, resType = defaultResContentType;
              endpoint.Method = method;
              endpoint.Path = path;
              endpoint.Tags = currentMethod.tags || [];
              endpoint.Summary = (currentMethod.summary || '').substring(0, 139);
              endpoint.Description = currentMethod.description || currentMethod.summary;
              endpoint.Deprecated = currentMethod.deprecated;
              endpoint.SetOperationId(currentMethod.operationId, method, path);
              endpoint.ExternalDocs = currentMethod.externalDocs;
              //map request body
              if (_.isArray(currentMethod.consumes)) {
                if (_.isEmpty(currentMethod.consumes)) {
                  reqType = null;
                } else {
                  reqType = this.findDefaultMimeType(currentMethod.consumes);
                }
              }
              if (endpoint.Method.toLowerCase() !== 'get' && endpoint.Method.toLowerCase() !== 'head') {
                var body = this._mapRequestBody(currentMethod.parameters, reqType, currentMethodResolved.parameters);
                if (body) {
                  endpoint.Body = body;
                }
              }
              // this needs to happen before the mappings below, because param/response $refs will be removed after those mappings
              endpoint.traits = this._mapEndpointTraits(currentMethod.parameters, currentMethod.responses);
              //if path params are defined in this level
              pathParams = _.merge(pathParams, this._mapURIParams(currentMethod.parameters, currentMethodResolved.parameters));
              //map path params
              endpoint.PathParams = pathParams;
              //map headers
              endpoint.Headers = this._mapRequestHeaders(currentMethod.parameters, true);
              //map query string
              // endpoint.QueryString = this._mapQueryString(currentMethod.parameters, true);
              endpoint.QueryString = this._mapQueryString(currentMethodResolved.parameters, true);
              //map response body
              if (_.isArray(currentMethod.produces)) {
                if (_.isEmpty(currentMethod.produces)) {
                  resType = null;
                } else {
                  resType = this.findDefaultMimeType(currentMethod.produces);
                }
              }
              var responses = this._mapResponseBody(currentMethod.responses, resType, true, currentMethodResolved.responses);
              if (responses) {
                endpoint.Responses = responses;
              }
              //map security
              if (currentMethod.security) {
                var securities = currentMethod.security;
                for (var securityIndex in securities) {
                  if (!securities.hasOwnProperty(securityIndex))
                    continue;
                  var keys = Object.keys(securities[securityIndex]);
                  var securityName = keys[0];
                  var scheme = _.get(this, [
                      'data',
                      'securityDefinitions',
                      securityName
                    ]);
                  if (!scheme) {
                    //definition error
                    continue;
                  }
                  switch (scheme.type) {
                  case 'apiKey':
                  case 'basic':
                    if (endpoint.SecuredBy.none) {
                      endpoint.SecuredBy = {};
                    }
                    endpoint.SecuredBy[scheme.type] = true;
                    break;
                  case 'oauth2':
                    if (endpoint.SecuredBy.none) {
                      endpoint.SecuredBy = {};
                    }
                    endpoint.SecuredBy[scheme.type] = securities[securityIndex][securityName];
                    break;
                  }
                }
              }
              this.project.addEndpoint(endpoint);
            }
          }
        };
        Swagger.prototype._mapTraits = function (parameters, responses) {
          var traits = {}, queryParams = {}, headerParams = {}, traitResponses = {};
          for (var k in parameters) {
            if (!parameters.hasOwnProperty(k))
              continue;
            var param = parameters[k], parts = k.split(':'), name = k;
            if (parts[0] === 'trait') {
              name = parts[1];
            }
            switch (param.in) {
            case 'query':
              queryParams[name] = queryParams[name] || [];
              queryParams[name].push(param);
              break;
            case 'header':
              headerParams[name] = headerParams[name] || [];
              headerParams[name].push(param);
              break;
            }
          }
          for (var k in responses) {
            if (!responses.hasOwnProperty(k))
              continue;
            var response = responses[k], parts = k.split(':'), name = k, code = k;
            if (parts[0] === 'trait') {
              isTrait = true;
              name = parts[1];
              code = parts[2];
            } else {
              continue;
            }
            traitResponses[name] = traitResponses[name] || {};
            traitResponses[name][code] = response;
          }
          for (var k in queryParams) {
            if (!queryParams.hasOwnProperty(k))
              continue;
            var trait = traits[k] || {
                _id: k,
                name: k,
                request: {},
                responses: []
              };
            trait.request.queryString = this._mapQueryString(queryParams[k]);
            traits[k] = trait;
          }
          for (var k in headerParams) {
            if (!headerParams.hasOwnProperty(k))
              continue;
            var trait = traits[k] || {
                _id: k,
                name: k,
                request: {},
                responses: []
              };
            trait.request.headers = this._mapRequestHeaders(headerParams[k]);
            traits[k] = trait;
          }
          for (var k in traitResponses) {
            if (!traitResponses.hasOwnProperty(k))
              continue;
            var trait = traits[k] || {
                _id: k,
                name: k,
                request: {},
                responses: []
              };
            trait.responses = this._mapResponseBody(traitResponses[k], 'application/json');
            traits[k] = trait;
          }
          return _.values(traits);
        };
        Swagger.prototype._import = function () {
          var defaultReqContentType = this.findDefaultMimeType(this.data.consumes), defaultResContentType = this.findDefaultMimeType(this.data.produces);
          this.project = new Project(this.data.info.title);
          this.project.Description = this.data.info.description || '';
          var protocol = 'http';
          if (this.data.schemes && this.data.schemes.length > 0) {
            this.project.Environment.Protocols = this.data.schemes;
            protocol = this.data.schemes[0];
          }
          this._mapEndpoints(defaultReqContentType, defaultResContentType);
          this.project.Environment.summary = this.data.info.description || '';
          this.project.Environment.BasePath = this.data.basePath || '';
          this.project.Environment.Host = this.data.host ? protocol + '://' + this.data.host : null;
          this.project.Environment.Version = this.data.info.version;
          if (this.data.externalDocs) {
            this.project.Environment.ExternalDocs = {
              description: this.data.externalDocs.description,
              url: this.data.externalDocs.url
            };
          }
          if (this.data.info.contact) {
            this.project.Environment.contactInfo = {};
            if (this.data.info.contact.name) {
              this.project.Environment.contactInfo.name = this.data.info.contact.name;
            }
            if (this.data.info.contact.url) {
              this.project.Environment.contactInfo.url = this.data.info.contact.url;
            }
            if (this.data.info.contact.email) {
              this.project.Environment.contactInfo.email = this.data.info.contact.email;
            }
          }
          if (this.data.info.termsOfService) {
            this.project.Environment.termsOfService = this.data.info.termsOfService;
          }
          if (this.data.info.license) {
            this.project.Environment.license = {};
            if (this.data.info.license.name) {
              this.project.Environment.license.name = this.data.info.license.name;
            }
            if (this.data.info.license.url) {
              this.project.Environment.license.url = this.data.info.license.url;
            }
          }
          if (this.data.produces) {
            //taking the first as default one
            this.project.Environment.DefaultResponseType = defaultResContentType;
          }
          if (this.data.consumes) {
            //taking the first as default one
            this.project.Environment.DefaultRequestType = defaultReqContentType;
          }
          if (this.data.securityDefinitions) {
            this.project.Environment.SecuritySchemes = this._mapSecurityDefinitions(this.data.securityDefinitions);
          }
          this.project.traits = this._mapTraits(this.data.parameters, this.data.responses);
          var schemas = this._mapSchema(this.data.definitions);
          for (var i in schemas) {
            if (!schemas.hasOwnProperty(i))
              continue;
            this.project.addSchema(schemas[i]);
          }
        };
        module.exports = Swagger;
      },
      {
        '../entities/endpoint': 3,
        '../entities/project': 5,
        '../entities/schema': 7,
        '../helpers/swagger': 21,
        '../utils/json': 33,
        './importer': 24,
        'js-yaml': 56,
        'lodash': 109,
        'swagger-parser': 139
      }
    ],
    32: [
      function (require, module, exports) {
        module.exports = {
          groupBy: function groupBy(array, f) {
            var groups = {};
            array.forEach(function (o) {
              var group = JSON.stringify(f(o));
              groups[group] = groups[group] || [];
              groups[group].push(o);
            });
            return Object.keys(groups).map(function (group) {
              return groups[group];
            });
          }
        };
      },
      {}
    ],
    33: [
      function (require, module, exports) {
        var _ = require('lodash'), jsonSchemaConverter = require('json-schema-compatibility');
        module.exports = {
          parse: function (data) {
            if (typeof data !== 'string') {
              return data;
            }
            try {
              var result = JSON.parse(data);
              if (typeof result === 'string') {
                return this.parse(result);
              }
              return result;
            } catch (err) {
              //can't parse, use as it is
              return data;
            }
          },
          stringify: function (jsonObj, spacing) {
            if (typeof jsonObj === 'string') {
              return jsonObj;
            }
            if (!spacing) {
              spacing = 0;
            }
            return JSON.stringify(jsonObj, null, spacing);
          },
          format: function (data) {
            if (typeof data !== 'string') {
              if (typeof data === 'object') {
                return this.stringify(data, 4);
              }
              return data;
            }
            //try parse
            var result = this.parse(data);
            if (typeof result === 'string') {
              //not parsable, no formatting possible
              return data;
            }
            return this.stringify(result, 4);
          },
          toJSON: function (obj) {
            var def = {};
            for (var property in obj) {
              var propType = typeof obj[property];
              if (propType !== 'function' && propType !== 'undefined') {
                def[property] = obj[property];
              }
            }
            return def;
          },
          orderByKeys: function (obj, propertiesOrder) {
            //if array recursive call to all items
            if (Array.isArray(obj)) {
              var me = this;
              return obj.map(function (item) {
                return me.orderByKeys(item, propertiesOrder);
              });
            }
            var orderedObj = {};
            //place the ordered key items first
            for (var i in propertiesOrder) {
              var key = propertiesOrder[i];
              if (obj.hasOwnProperty(key)) {
                orderedObj[key] = obj[key];
              }
            }
            //add if something missing from the given orders
            for (var key in obj) {
              if (!orderedObj.hasOwnProperty(key)) {
                orderedObj[key] = obj[key];
              }
            }
            return orderedObj;
          },
          isEmptySchema: function (schema) {
            if (_.isEmpty(schema)) {
              return true;
            }
            var parsed = schema;
            if (typeof parsed === 'string') {
              try {
                parsed = JSON.parse(parsed);
              } catch (e) {
                return true;
              }
            }
            if (!parsed || !Object.keys(parsed).length || parsed.properties && !Object.keys(parsed.properties).length) {
              return true;
            }
            if (parsed.type === 'object' && _.isEmpty(parsed.properties)) {
              return true;
            }
            if (parsed.type === 'array' && _.isEmpty(parsed.items)) {
              return true;
            }
            return false;
          },
          cleanSchema: function (schema) {
            var parsed = this.parse(schema);
            try {
              jsonSchemaConverter.v4(parsed);
            } catch (e) {
            }
            return this.stringify(parsed, 4);
          }
        };
      },
      {
        'json-schema-compatibility': 86,
        'lodash': 109
      }
    ],
    34: [
      function (require, module, exports) {
        var _ = require('lodash');
        module.exports = {
          computeOperationId: function (method, path) {
            method = _.trim(method).toUpperCase();
            path = _.trim(path);
            if (path === '/' || path === '') {
              return method + '_root';
            }
            return method + '_' + _.trim(path, '/').replace(/\{|\}/g, '').replace(/\/|\./g, '-');
          },
          computeTraitName: function (name, key) {
            var traitName = 'trait:' + _.camelCase(name);
            if (key) {
              traitName += ':' + key;
            }
            return traitName;
          }
        };
      },
      { 'lodash': 109 }
    ],
    35: [
      function (require, module, exports) {
        var request = require('request');
        module.exports = {
          isURL: function (path) {
            if (!path) {
              throw new Error('Invalid path/url string given.');
            }
            var expression = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%_\+.~#?&\/\/=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&\/\/=]*)?/gi;
            var regexp = new RegExp(expression);
            return path.match(regexp);
          },
          get: function (url) {
            return new Promise(function (resolve, reject) {
              request(url, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                  resolve(body);
                } else {
                  reject(error || new Error('Could not fetch remote URL.'));
                }
              });
            });
          }
        };
      },
      { 'request': 37 }
    ],
    36: [
      function (require, module, exports) {
        var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        ;
        (function (exports) {
          'use strict';
          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
          var PLUS = '+'.charCodeAt(0);
          var SLASH = '/'.charCodeAt(0);
          var NUMBER = '0'.charCodeAt(0);
          var LOWER = 'a'.charCodeAt(0);
          var UPPER = 'A'.charCodeAt(0);
          var PLUS_URL_SAFE = '-'.charCodeAt(0);
          var SLASH_URL_SAFE = '_'.charCodeAt(0);
          function decode(elt) {
            var code = elt.charCodeAt(0);
            if (code === PLUS || code === PLUS_URL_SAFE)
              return 62;
            // '+'
            if (code === SLASH || code === SLASH_URL_SAFE)
              return 63;
            // '/'
            if (code < NUMBER)
              return -1;
            //no match
            if (code < NUMBER + 10)
              return code - NUMBER + 26 + 26;
            if (code < UPPER + 26)
              return code - UPPER;
            if (code < LOWER + 26)
              return code - LOWER + 26;
          }
          function b64ToByteArray(b64) {
            var i, j, l, tmp, placeHolders, arr;
            if (b64.length % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4');
            }
            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            var len = b64.length;
            placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
            // base64 is 4/3 + up to two characters of the original data
            arr = new Arr(b64.length * 3 / 4 - placeHolders);
            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? b64.length - 4 : b64.length;
            var L = 0;
            function push(v) {
              arr[L++] = v;
            }
            for (i = 0, j = 0; i < l; i += 4, j += 3) {
              tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
              push((tmp & 16711680) >> 16);
              push((tmp & 65280) >> 8);
              push(tmp & 255);
            }
            if (placeHolders === 2) {
              tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
              push(tmp & 255);
            } else if (placeHolders === 1) {
              tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
              push(tmp >> 8 & 255);
              push(tmp & 255);
            }
            return arr;
          }
          function uint8ToBase64(uint8) {
            var i, extraBytes = uint8.length % 3,
              // if we have 1 byte left, pad 2 bytes
              output = '', temp, length;
            function encode(num) {
              return lookup.charAt(num);
            }
            function tripletToBase64(num) {
              return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
            }
            // go through the array every three bytes, we'll deal with trailing stuff later
            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
              temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
              output += tripletToBase64(temp);
            }
            // pad the end with zeros, but make sure to not forget the extra bytes
            switch (extraBytes) {
            case 1:
              temp = uint8[uint8.length - 1];
              output += encode(temp >> 2);
              output += encode(temp << 4 & 63);
              output += '==';
              break;
            case 2:
              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
              output += encode(temp >> 10);
              output += encode(temp >> 4 & 63);
              output += encode(temp << 2 & 63);
              output += '=';
              break;
            }
            return output;
          }
          exports.toByteArray = b64ToByteArray;
          exports.fromByteArray = uint8ToBase64;
        }(typeof exports === 'undefined' ? this.base64js = {} : exports));
      },
      {}
    ],
    37: [
      function (require, module, exports) {
        // Browser Request
        //
        // Licensed under the Apache License, Version 2.0 (the "License");
        // you may not use this file except in compliance with the License.
        // You may obtain a copy of the License at
        //
        //     http://www.apache.org/licenses/LICENSE-2.0
        //
        // Unless required by applicable law or agreed to in writing, software
        // distributed under the License is distributed on an "AS IS" BASIS,
        // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        // See the License for the specific language governing permissions and
        // limitations under the License.
        // UMD HEADER START 
        (function (root, factory) {
          if (typeof define === 'function' && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
          } else if (typeof exports === 'object') {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like enviroments that support module.exports,
            // like Node.
            module.exports = factory();
          } else {
            // Browser globals (root is window)
            root.returnExports = factory();
          }
        }(this, function () {
          // UMD HEADER END
          var XHR = XMLHttpRequest;
          if (!XHR)
            throw new Error('missing XMLHttpRequest');
          request.log = {
            'trace': noop,
            'debug': noop,
            'info': noop,
            'warn': noop,
            'error': noop
          };
          var DEFAULT_TIMEOUT = 3 * 60 * 1000;
          // 3 minutes
          //
          // request
          //
          function request(options, callback) {
            // The entry-point to the API: prep the options object and pass the real work to run_xhr.
            if (typeof callback !== 'function')
              throw new Error('Bad callback given: ' + callback);
            if (!options)
              throw new Error('No options given');
            var options_onResponse = options.onResponse;
            // Save this for later.
            if (typeof options === 'string')
              options = { 'uri': options };
            else
              options = JSON.parse(JSON.stringify(options));
            // Use a duplicate for mutating.
            options.onResponse = options_onResponse;
            // And put it back.
            if (options.verbose)
              request.log = getLogger();
            if (options.url) {
              options.uri = options.url;
              delete options.url;
            }
            if (!options.uri && options.uri !== '')
              throw new Error('options.uri is a required argument');
            if (typeof options.uri != 'string')
              throw new Error('options.uri must be a string');
            var unsupported_options = [
                'proxy',
                '_redirectsFollowed',
                'maxRedirects',
                'followRedirect'
              ];
            for (var i = 0; i < unsupported_options.length; i++)
              if (options[unsupported_options[i]])
                throw new Error('options.' + unsupported_options[i] + ' is not supported');
            options.callback = callback;
            options.method = options.method || 'GET';
            options.headers = options.headers || {};
            options.body = options.body || null;
            options.timeout = options.timeout || request.DEFAULT_TIMEOUT;
            if (options.headers.host)
              throw new Error('Options.headers.host is not supported');
            if (options.json) {
              options.headers.accept = options.headers.accept || 'application/json';
              if (options.method !== 'GET')
                options.headers['content-type'] = 'application/json';
              if (typeof options.json !== 'boolean')
                options.body = JSON.stringify(options.json);
              else if (typeof options.body !== 'string')
                options.body = JSON.stringify(options.body);
            }
            //BEGIN QS Hack
            var serialize = function (obj) {
              var str = [];
              for (var p in obj)
                if (obj.hasOwnProperty(p)) {
                  str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
                }
              return str.join('&');
            };
            if (options.qs) {
              var qs = typeof options.qs == 'string' ? options.qs : serialize(options.qs);
              if (options.uri.indexOf('?') !== -1) {
                //no get params
                options.uri = options.uri + '&' + qs;
              } else {
                //existing get params
                options.uri = options.uri + '?' + qs;
              }
            }
            //END QS Hack
            //BEGIN FORM Hack
            var multipart = function (obj) {
              //todo: support file type (useful?)
              var result = {};
              result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);
              var lines = [];
              for (var p in obj) {
                if (obj.hasOwnProperty(p)) {
                  lines.push('--' + result.boundry + '\n' + 'Content-Disposition: form-data; name="' + p + '"' + '\n' + '\n' + obj[p] + '\n');
                }
              }
              lines.push('--' + result.boundry + '--');
              result.body = lines.join('');
              result.length = result.body.length;
              result.type = 'multipart/form-data; boundary=' + result.boundry;
              return result;
            };
            if (options.form) {
              if (typeof options.form == 'string')
                throw 'form name unsupported';
              if (options.method === 'POST') {
                var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
                options.headers['content-type'] = encoding;
                switch (encoding) {
                case 'application/x-www-form-urlencoded':
                  options.body = serialize(options.form).replace(/%20/g, '+');
                  break;
                case 'multipart/form-data':
                  var multi = multipart(options.form);
                  //options.headers['content-length'] = multi.length;
                  options.body = multi.body;
                  options.headers['content-type'] = multi.type;
                  break;
                default:
                  throw new Error('unsupported encoding:' + encoding);
                }
              }
            }
            //END FORM Hack
            // If onResponse is boolean true, call back immediately when the response is known,
            // not when the full request is complete.
            options.onResponse = options.onResponse || noop;
            if (options.onResponse === true) {
              options.onResponse = callback;
              options.callback = noop;
            }
            // XXX Browsers do not like this.
            //if(options.body)
            //  options.headers['content-length'] = options.body.length;
            // HTTP basic authentication
            if (!options.headers.authorization && options.auth)
              options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);
            return run_xhr(options);
          }
          var req_seq = 0;
          function run_xhr(options) {
            var xhr = new XHR(), timed_out = false, is_cors = is_crossDomain(options.uri), supports_cors = 'withCredentials' in xhr;
            req_seq += 1;
            xhr.seq_id = req_seq;
            xhr.id = req_seq + ': ' + options.method + ' ' + options.uri;
            xhr._id = xhr.id;
            // I know I will type "_id" from habit all the time.
            if (is_cors && !supports_cors) {
              var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri);
              cors_err.cors = 'unsupported';
              return options.callback(cors_err, xhr);
            }
            xhr.timeoutTimer = setTimeout(too_late, options.timeout);
            function too_late() {
              timed_out = true;
              var er = new Error('ETIMEDOUT');
              er.code = 'ETIMEDOUT';
              er.duration = options.timeout;
              request.log.error('Timeout', {
                'id': xhr._id,
                'milliseconds': options.timeout
              });
              return options.callback(er, xhr);
            }
            // Some states can be skipped over, so remember what is still incomplete.
            var did = {
                'response': false,
                'loading': false,
                'end': false
              };
            xhr.onreadystatechange = on_state_change;
            xhr.open(options.method, options.uri, true);
            // asynchronous
            if (is_cors)
              xhr.withCredentials = !!options.withCredentials;
            xhr.send(options.body);
            return xhr;
            function on_state_change(event) {
              if (timed_out)
                return request.log.debug('Ignoring timed out state change', {
                  'state': xhr.readyState,
                  'id': xhr.id
                });
              request.log.debug('State change', {
                'state': xhr.readyState,
                'id': xhr.id,
                'timed_out': timed_out
              });
              if (xhr.readyState === XHR.OPENED) {
                request.log.debug('Request started', { 'id': xhr.id });
                for (var key in options.headers)
                  xhr.setRequestHeader(key, options.headers[key]);
              } else if (xhr.readyState === XHR.HEADERS_RECEIVED)
                on_response();
              else if (xhr.readyState === XHR.LOADING) {
                on_response();
                on_loading();
              } else if (xhr.readyState === XHR.DONE) {
                on_response();
                on_loading();
                on_end();
              }
            }
            function on_response() {
              if (did.response)
                return;
              did.response = true;
              request.log.debug('Got response', {
                'id': xhr.id,
                'status': xhr.status
              });
              clearTimeout(xhr.timeoutTimer);
              xhr.statusCode = xhr.status;
              // Node request compatibility
              // Detect failed CORS requests.
              if (is_cors && xhr.statusCode == 0) {
                var cors_err = new Error('CORS request rejected: ' + options.uri);
                cors_err.cors = 'rejected';
                // Do not process this request further.
                did.loading = true;
                did.end = true;
                return options.callback(cors_err, xhr);
              }
              options.onResponse(null, xhr);
            }
            function on_loading() {
              if (did.loading)
                return;
              did.loading = true;
              request.log.debug('Response body loading', { 'id': xhr.id });
            }
            function on_end() {
              if (did.end)
                return;
              did.end = true;
              request.log.debug('Request done', { 'id': xhr.id });
              xhr.body = xhr.responseText;
              if (options.json) {
                try {
                  xhr.body = JSON.parse(xhr.responseText);
                } catch (er) {
                  return options.callback(er, xhr);
                }
              }
              options.callback(null, xhr, xhr.body);
            }
          }
          // request
          request.withCredentials = false;
          request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
          //
          // defaults
          //
          request.defaults = function (options, requester) {
            var def = function (method) {
              var d = function (params, callback) {
                if (typeof params === 'string')
                  params = { 'uri': params };
                else {
                  params = JSON.parse(JSON.stringify(params));
                }
                for (var i in options) {
                  if (params[i] === undefined)
                    params[i] = options[i];
                }
                return method(params, callback);
              };
              return d;
            };
            var de = def(request);
            de.get = def(request.get);
            de.post = def(request.post);
            de.put = def(request.put);
            de.head = def(request.head);
            return de;
          };
          //
          // HTTP method shortcuts
          //
          var shortcuts = [
              'get',
              'put',
              'post',
              'head'
            ];
          shortcuts.forEach(function (shortcut) {
            var method = shortcut.toUpperCase();
            var func = shortcut.toLowerCase();
            request[func] = function (opts) {
              if (typeof opts === 'string')
                opts = {
                  'method': method,
                  'uri': opts
                };
              else {
                opts = JSON.parse(JSON.stringify(opts));
                opts.method = method;
              }
              var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
              return request.apply(this, args);
            };
          });
          //
          // CouchDB shortcut
          //
          request.couch = function (options, callback) {
            if (typeof options === 'string')
              options = { 'uri': options };
            // Just use the request API to do JSON.
            options.json = true;
            if (options.body)
              options.json = options.body;
            delete options.body;
            callback = callback || noop;
            var xhr = request(options, couch_handler);
            return xhr;
            function couch_handler(er, resp, body) {
              if (er)
                return callback(er, resp, body);
              if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
                // The body is a Couch JSON object indicating the error.
                er = new Error('CouchDB error: ' + (body.error.reason || body.error.error));
                for (var key in body)
                  er[key] = body[key];
                return callback(er, resp, body);
              }
              return callback(er, resp, body);
            }
          };
          //
          // Utility
          //
          function noop() {
          }
          function getLogger() {
            var logger = {}, levels = [
                'trace',
                'debug',
                'info',
                'warn',
                'error'
              ], level, i;
            for (i = 0; i < levels.length; i++) {
              level = levels[i];
              logger[level] = noop;
              if (typeof console !== 'undefined' && console && console[level])
                logger[level] = formatted(console, level);
            }
            return logger;
          }
          function formatted(obj, method) {
            return formatted_logger;
            function formatted_logger(str, context) {
              if (typeof context === 'object')
                str += ' ' + JSON.stringify(context);
              return obj[method].call(obj, str);
            }
          }
          // Return whether a URL is a cross-domain request.
          function is_crossDomain(url) {
            var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/;
            // jQuery #8138, IE may throw an exception when accessing
            // a field from window.location if document.domain has been set
            var ajaxLocation;
            try {
              ajaxLocation = location.href;
            } catch (e) {
              // Use the href attribute of an A element since IE will modify it given document.location
              ajaxLocation = document.createElement('a');
              ajaxLocation.href = '';
              ajaxLocation = ajaxLocation.href;
            }
            var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], parts = rurl.exec(url.toLowerCase());
            var result = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? 80 : 443))));
            //console.debug('is_crossDomain('+url+') -> ' + result)
            return result;
          }
          // MIT License from http://phpjs.org/functions/base64_encode:358
          function b64_enc(data) {
            // Encodes string using MIME base64 algorithm
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = '', tmp_arr = [];
            if (!data) {
              return data;
            }
            // assume utf8 data
            // data = this.utf8_encode(data+'');
            do {
              // pack three octets into four hexets
              o1 = data.charCodeAt(i++);
              o2 = data.charCodeAt(i++);
              o3 = data.charCodeAt(i++);
              bits = o1 << 16 | o2 << 8 | o3;
              h1 = bits >> 18 & 63;
              h2 = bits >> 12 & 63;
              h3 = bits >> 6 & 63;
              h4 = bits & 63;
              // use hexets to index into b64, and append result to encoded string
              tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);
            enc = tmp_arr.join('');
            switch (data.length % 3) {
            case 1:
              enc = enc.slice(0, -2) + '==';
              break;
            case 2:
              enc = enc.slice(0, -1) + '=';
              break;
            }
            return enc;
          }
          return request;  //UMD FOOTER START
        }));  //UMD FOOTER END
      },
      {}
    ],
    38: [
      function (require, module, exports) {
      },
      {}
    ],
    39: [
      function (require, module, exports) {
        arguments[4][38][0].apply(exports, arguments);
      },
      { 'dup': 38 }
    ],
    40: [
      function (require, module, exports) {
        (function (global) {
          'use strict';
          var buffer = require('buffer');
          var Buffer = buffer.Buffer;
          var SlowBuffer = buffer.SlowBuffer;
          var MAX_LEN = buffer.kMaxLength || 2147483647;
          exports.alloc = function alloc(size, fill, encoding) {
            if (typeof Buffer.alloc === 'function') {
              return Buffer.alloc(size, fill, encoding);
            }
            if (typeof encoding === 'number') {
              throw new TypeError('encoding must not be number');
            }
            if (typeof size !== 'number') {
              throw new TypeError('size must be a number');
            }
            if (size > MAX_LEN) {
              throw new RangeError('size is too large');
            }
            var enc = encoding;
            var _fill = fill;
            if (_fill === undefined) {
              enc = undefined;
              _fill = 0;
            }
            var buf = new Buffer(size);
            if (typeof _fill === 'string') {
              var fillBuf = new Buffer(_fill, enc);
              var flen = fillBuf.length;
              var i = -1;
              while (++i < size) {
                buf[i] = fillBuf[i % flen];
              }
            } else {
              buf.fill(_fill);
            }
            return buf;
          };
          exports.allocUnsafe = function allocUnsafe(size) {
            if (typeof Buffer.allocUnsafe === 'function') {
              return Buffer.allocUnsafe(size);
            }
            if (typeof size !== 'number') {
              throw new TypeError('size must be a number');
            }
            if (size > MAX_LEN) {
              throw new RangeError('size is too large');
            }
            return new Buffer(size);
          };
          exports.from = function from(value, encodingOrOffset, length) {
            if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
              return Buffer.from(value, encodingOrOffset, length);
            }
            if (typeof value === 'number') {
              throw new TypeError('"value" argument must not be a number');
            }
            if (typeof value === 'string') {
              return new Buffer(value, encodingOrOffset);
            }
            if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
              var offset = encodingOrOffset;
              if (arguments.length === 1) {
                return new Buffer(value);
              }
              if (typeof offset === 'undefined') {
                offset = 0;
              }
              var len = length;
              if (typeof len === 'undefined') {
                len = value.byteLength - offset;
              }
              if (offset >= value.byteLength) {
                throw new RangeError('\'offset\' is out of bounds');
              }
              if (len > value.byteLength - offset) {
                throw new RangeError('\'length\' is out of bounds');
              }
              return new Buffer(value.slice(offset, offset + len));
            }
            if (Buffer.isBuffer(value)) {
              var out = new Buffer(value.length);
              value.copy(out, 0, 0, value.length);
              return out;
            }
            if (value) {
              if (Array.isArray(value) || typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer || 'length' in value) {
                return new Buffer(value);
              }
              if (value.type === 'Buffer' && Array.isArray(value.data)) {
                return new Buffer(value.data);
              }
            }
            throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
          };
          exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
            if (typeof Buffer.allocUnsafeSlow === 'function') {
              return Buffer.allocUnsafeSlow(size);
            }
            if (typeof size !== 'number') {
              throw new TypeError('size must be a number');
            }
            if (size >= MAX_LEN) {
              throw new RangeError('size is too large');
            }
            return new SlowBuffer(size);
          };
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      { 'buffer': 41 }
    ],
    41: [
      function (require, module, exports) {
        (function (global) {
          /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
          /* eslint-disable no-proto */
          'use strict';
          var base64 = require('base64-js');
          var ieee754 = require('ieee754');
          var isArray = require('isarray');
          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;
          Buffer.poolSize = 8192;
          // not used by this implementation
          var rootParent = {};
          /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
          Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
          function typedArraySupport() {
            function Bar() {
            }
            try {
              var arr = new Uint8Array(1);
              arr.foo = function () {
                return 42;
              };
              arr.constructor = Bar;
              return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
            } catch (e) {
              return false;
            }
          }
          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          /**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
          function Buffer(arg) {
            if (!(this instanceof Buffer)) {
              // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
              if (arguments.length > 1)
                return new Buffer(arg, arguments[1]);
              return new Buffer(arg);
            }
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              this.length = 0;
              this.parent = undefined;
            }
            // Common case.
            if (typeof arg === 'number') {
              return fromNumber(this, arg);
            }
            // Slightly less common case.
            if (typeof arg === 'string') {
              return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
            }
            // Unusual.
            return fromObject(this, arg);
          }
          function fromNumber(that, length) {
            that = allocate(that, length < 0 ? 0 : checked(length) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < length; i++) {
                that[i] = 0;
              }
            }
            return that;
          }
          function fromString(that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '')
              encoding = 'utf8';
            // Assumption: byteLength() return value is always < kMaxLength.
            var length = byteLength(string, encoding) | 0;
            that = allocate(that, length);
            that.write(string, encoding);
            return that;
          }
          function fromObject(that, object) {
            if (Buffer.isBuffer(object))
              return fromBuffer(that, object);
            if (isArray(object))
              return fromArray(that, object);
            if (object == null) {
              throw new TypeError('must start with number, buffer, array or string');
            }
            if (typeof ArrayBuffer !== 'undefined') {
              if (object.buffer instanceof ArrayBuffer) {
                return fromTypedArray(that, object);
              }
              if (object instanceof ArrayBuffer) {
                return fromArrayBuffer(that, object);
              }
            }
            if (object.length)
              return fromArrayLike(that, object);
            return fromJsonObject(that, object);
          }
          function fromBuffer(that, buffer) {
            var length = checked(buffer.length) | 0;
            that = allocate(that, length);
            buffer.copy(that, 0, 0, length);
            return that;
          }
          function fromArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          // Duplicate of fromArray() to keep fromArray() monomorphic.
          function fromTypedArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            // Truncating the elements is probably not what people expect from typed
            // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
            // of the old Buffer constructor.
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromArrayBuffer(that, array) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              array.byteLength;
              that = Buffer._augment(new Uint8Array(array));
            } else {
              // Fallback: Return an object instance of the Buffer class
              that = fromTypedArray(that, new Uint8Array(array));
            }
            return that;
          }
          function fromArrayLike(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
          // Returns a zero-length buffer for inputs that don't conform to the spec.
          function fromJsonObject(that, object) {
            var array;
            var length = 0;
            if (object.type === 'Buffer' && isArray(object.data)) {
              array = object.data;
              length = checked(array.length) | 0;
            }
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;
          } else {
            // pre-set for values that may exist in the future
            Buffer.prototype.length = undefined;
            Buffer.prototype.parent = undefined;
          }
          function allocate(that, length) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = Buffer._augment(new Uint8Array(length));
              that.__proto__ = Buffer.prototype;
            } else {
              // Fallback: Return an object instance of the Buffer class
              that.length = length;
              that._isBuffer = true;
            }
            var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
            if (fromPool)
              that.parent = rootParent;
            return that;
          }
          function checked(length) {
            // Note: cannot use `length < kMaxLength` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= kMaxLength()) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
            }
            return length | 0;
          }
          function SlowBuffer(subject, encoding) {
            if (!(this instanceof SlowBuffer))
              return new SlowBuffer(subject, encoding);
            var buf = new Buffer(subject, encoding);
            delete buf.parent;
            return buf;
          }
          Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };
          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers');
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            var i = 0;
            var len = Math.min(x, y);
            while (i < len) {
              if (a[i] !== b[i])
                break;
              ++i;
            }
            if (i !== len) {
              x = a[i];
              y = b[i];
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'raw':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;
            default:
              return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!isArray(list))
              throw new TypeError('list argument must be an Array of Buffers.');
            if (list.length === 0) {
              return new Buffer(0);
            }
            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; i++) {
                length += list[i].length;
              }
            }
            var buf = new Buffer(length);
            var pos = 0;
            for (i = 0; i < list.length; i++) {
              var item = list[i];
              item.copy(buf, pos);
              pos += item.length;
            }
            return buf;
          };
          function byteLength(string, encoding) {
            if (typeof string !== 'string')
              string = '' + string;
            var len = string.length;
            if (len === 0)
              return 0;
            // Use a for loop to avoid recursion
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
              case 'ascii':
              case 'binary':
              // Deprecated
              case 'raw':
              case 'raws':
                return len;
              case 'utf8':
              case 'utf-8':
                return utf8ToBytes(string).length;
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2;
              case 'hex':
                return len >>> 1;
              case 'base64':
                return base64ToBytes(string).length;
              default:
                if (loweredCase)
                  return utf8ToBytes(string).length;
                // assume utf8
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            start = start | 0;
            end = end === undefined || end === Infinity ? this.length : end | 0;
            if (!encoding)
              encoding = 'utf8';
            if (start < 0)
              start = 0;
            if (end > this.length)
              end = this.length;
            if (end <= start)
              return '';
            while (true) {
              switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end);
              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end);
              case 'ascii':
                return asciiSlice(this, start, end);
              case 'binary':
                return binarySlice(this, start, end);
              case 'base64':
                return base64Slice(this, start, end);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase)
                  throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
              }
            }
          }
          Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0)
              return '';
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError('Argument must be a Buffer');
            if (this === b)
              return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
              if (this.length > max)
                str += ' ... ';
            }
            return '<Buffer ' + str + '>';
          };
          Buffer.prototype.compare = function compare(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError('Argument must be a Buffer');
            if (this === b)
              return 0;
            return Buffer.compare(this, b);
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
            if (byteOffset > 2147483647)
              byteOffset = 2147483647;
            else if (byteOffset < -2147483648)
              byteOffset = -2147483648;
            byteOffset >>= 0;
            if (this.length === 0)
              return -1;
            if (byteOffset >= this.length)
              return -1;
            // Negative offsets start from the end of the buffer
            if (byteOffset < 0)
              byteOffset = Math.max(this.length + byteOffset, 0);
            if (typeof val === 'string') {
              if (val.length === 0)
                return -1;
              // special case: looking for empty string always fails
              return String.prototype.indexOf.call(this, val, byteOffset);
            }
            if (Buffer.isBuffer(val)) {
              return arrayIndexOf(this, val, byteOffset);
            }
            if (typeof val === 'number') {
              if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
              }
              return arrayIndexOf(this, [val], byteOffset);
            }
            function arrayIndexOf(arr, val, byteOffset) {
              var foundIndex = -1;
              for (var i = 0; byteOffset + i < arr.length; i++) {
                if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === val.length)
                    return byteOffset + foundIndex;
                } else {
                  foundIndex = -1;
                }
              }
              return -1;
            }
            throw new TypeError('val must be string, number or Buffer');
          };
          // `get` is deprecated
          Buffer.prototype.get = function get(offset) {
            console.log('.get() is deprecated. Access using array indexes instead.');
            return this.readUInt8(offset);
          };
          // `set` is deprecated
          Buffer.prototype.set = function set(v, offset) {
            console.log('.set() is deprecated. Access using array indexes instead.');
            return this.writeUInt8(v, offset);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            // must be an even number of digits
            var strLen = string.length;
            if (strLen % 2 !== 0)
              throw new Error('Invalid hex string');
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed))
                throw new Error('Invalid hex string');
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset | 0;
              if (isFinite(length)) {
                length = length | 0;
                if (encoding === undefined)
                  encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }  // legacy write(string, encoding, offset, length) - remove in v0.13
            } else {
              var swap = encoding;
              encoding = offset;
              offset = length | 0;
              length = swap;
            }
            var remaining = this.length - offset;
            if (length === undefined || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('attempt to write outside buffer bounds');
            }
            if (!encoding)
              encoding = 'utf8';
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length);
              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length);
              case 'ascii':
                return asciiWrite(this, string, offset, length);
              case 'binary':
                return binaryWrite(this, string, offset, length);
              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase)
                  throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
                }
              }
              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            // Decode in chunks to avoid "call stack size exceeded".
            var res = '';
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function binarySlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = '';
            for (var i = start; i < end; i++) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = Buffer._augment(this.subarray(start, end));
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer(sliceLen, undefined);
              for (var i = 0; i < sliceLen; i++) {
                newBuf[i] = this[i + start];
              }
            }
            if (newBuf.length)
              newBuf.parent = this.parent || this;
            return newBuf;
          };
          /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError('offset is not uint');
            if (offset + ext > length)
              throw new RangeError('Trying to access beyond buffer length');
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 256)) {
              val += this[offset + --byteLength] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError('buffer must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('value is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError('index out of range');
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            this[offset] = value & 255;
            return offset + 1;
          };
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
              buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
              buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
          }
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (value > max || value < min)
              throw new RangeError('value is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError('index out of range');
            if (offset < 0)
              throw new RangeError('index out of range');
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157e+308, -1.7976931348623157e+308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            // Copy 0 bytes; we're done
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length)
              throw new RangeError('sourceStart out of bounds');
            if (end < 0)
              throw new RangeError('sourceEnd out of bounds');
            // Are we oob?
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (i = len - 1; i >= 0; i--) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
              // ascending copy from start
              for (i = 0; i < len; i++) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              target._set(this.subarray(start, start + len), targetStart);
            }
            return len;
          };
          // fill(value, start=0, end=buffer.length)
          Buffer.prototype.fill = function fill(value, start, end) {
            if (!value)
              value = 0;
            if (!start)
              start = 0;
            if (!end)
              end = this.length;
            if (end < start)
              throw new RangeError('end < start');
            // Fill 0 bytes; we're done
            if (end === start)
              return;
            if (this.length === 0)
              return;
            if (start < 0 || start >= this.length)
              throw new RangeError('start out of bounds');
            if (end < 0 || end > this.length)
              throw new RangeError('end out of bounds');
            var i;
            if (typeof value === 'number') {
              for (i = start; i < end; i++) {
                this[i] = value;
              }
            } else {
              var bytes = utf8ToBytes(value.toString());
              var len = bytes.length;
              for (i = start; i < end; i++) {
                this[i] = bytes[i % len];
              }
            }
            return this;
          };
          /**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
          Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
            if (typeof Uint8Array !== 'undefined') {
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                return new Buffer(this).buffer;
              } else {
                var buf = new Uint8Array(this.length);
                for (var i = 0, len = buf.length; i < len; i += 1) {
                  buf[i] = this[i];
                }
                return buf.buffer;
              }
            } else {
              throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
            }
          };
          // HELPER FUNCTIONS
          // ================
          var BP = Buffer.prototype;
          /**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
          Buffer._augment = function _augment(arr) {
            arr.constructor = Buffer;
            arr._isBuffer = true;
            // save reference to original Uint8Array set method before overwriting
            arr._set = arr.set;
            // deprecated
            arr.get = BP.get;
            arr.set = BP.set;
            arr.write = BP.write;
            arr.toString = BP.toString;
            arr.toLocaleString = BP.toString;
            arr.toJSON = BP.toJSON;
            arr.equals = BP.equals;
            arr.compare = BP.compare;
            arr.indexOf = BP.indexOf;
            arr.copy = BP.copy;
            arr.slice = BP.slice;
            arr.readUIntLE = BP.readUIntLE;
            arr.readUIntBE = BP.readUIntBE;
            arr.readUInt8 = BP.readUInt8;
            arr.readUInt16LE = BP.readUInt16LE;
            arr.readUInt16BE = BP.readUInt16BE;
            arr.readUInt32LE = BP.readUInt32LE;
            arr.readUInt32BE = BP.readUInt32BE;
            arr.readIntLE = BP.readIntLE;
            arr.readIntBE = BP.readIntBE;
            arr.readInt8 = BP.readInt8;
            arr.readInt16LE = BP.readInt16LE;
            arr.readInt16BE = BP.readInt16BE;
            arr.readInt32LE = BP.readInt32LE;
            arr.readInt32BE = BP.readInt32BE;
            arr.readFloatLE = BP.readFloatLE;
            arr.readFloatBE = BP.readFloatBE;
            arr.readDoubleLE = BP.readDoubleLE;
            arr.readDoubleBE = BP.readDoubleBE;
            arr.writeUInt8 = BP.writeUInt8;
            arr.writeUIntLE = BP.writeUIntLE;
            arr.writeUIntBE = BP.writeUIntBE;
            arr.writeUInt16LE = BP.writeUInt16LE;
            arr.writeUInt16BE = BP.writeUInt16BE;
            arr.writeUInt32LE = BP.writeUInt32LE;
            arr.writeUInt32BE = BP.writeUInt32BE;
            arr.writeIntLE = BP.writeIntLE;
            arr.writeIntBE = BP.writeIntBE;
            arr.writeInt8 = BP.writeInt8;
            arr.writeInt16LE = BP.writeInt16LE;
            arr.writeInt16BE = BP.writeInt16BE;
            arr.writeInt32LE = BP.writeInt32LE;
            arr.writeInt32BE = BP.writeInt32BE;
            arr.writeFloatLE = BP.writeFloatLE;
            arr.writeFloatBE = BP.writeFloatBE;
            arr.writeDoubleLE = BP.writeDoubleLE;
            arr.writeDoubleBE = BP.writeDoubleBE;
            arr.fill = BP.fill;
            arr.inspect = BP.inspect;
            arr.toArrayBuffer = BP.toArrayBuffer;
            return arr;
          };
          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, '');
            // Node converts strings with length < 2 to ''
            if (str.length < 2)
              return '';
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '=';
            }
            return str;
          }
          function stringtrim(str) {
            if (str.trim)
              return str.trim();
            return str.replace(/^\s+|\s+$/g, '');
          }
          function toHex(n) {
            if (n < 16)
              return '0' + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; i++) {
              codePoint = string.charCodeAt(i);
              // is surrogate component
              if (codePoint > 55295 && codePoint < 57344) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  // valid lead
                  leadSurrogate = codePoint;
                  continue;
                }
                // 2 leads in a row
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                // valid surrogate pair
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              // encode utf8
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else {
                throw new Error('Invalid code point');
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {
        'base64-js': 36,
        'ieee754': 52,
        'isarray': 42
      }
    ],
    42: [
      function (require, module, exports) {
        var toString = {}.toString;
        module.exports = Array.isArray || function (arr) {
          return toString.call(arr) == '[object Array]';
        };
      },
      {}
    ],
    43: [
      function (require, module, exports) {
        module.exports = {
          '100': 'Continue',
          '101': 'Switching Protocols',
          '102': 'Processing',
          '200': 'OK',
          '201': 'Created',
          '202': 'Accepted',
          '203': 'Non-Authoritative Information',
          '204': 'No Content',
          '205': 'Reset Content',
          '206': 'Partial Content',
          '207': 'Multi-Status',
          '300': 'Multiple Choices',
          '301': 'Moved Permanently',
          '302': 'Moved Temporarily',
          '303': 'See Other',
          '304': 'Not Modified',
          '305': 'Use Proxy',
          '307': 'Temporary Redirect',
          '308': 'Permanent Redirect',
          '400': 'Bad Request',
          '401': 'Unauthorized',
          '402': 'Payment Required',
          '403': 'Forbidden',
          '404': 'Not Found',
          '405': 'Method Not Allowed',
          '406': 'Not Acceptable',
          '407': 'Proxy Authentication Required',
          '408': 'Request Time-out',
          '409': 'Conflict',
          '410': 'Gone',
          '411': 'Length Required',
          '412': 'Precondition Failed',
          '413': 'Request Entity Too Large',
          '414': 'Request-URI Too Large',
          '415': 'Unsupported Media Type',
          '416': 'Requested Range Not Satisfiable',
          '417': 'Expectation Failed',
          '418': 'I\'m a teapot',
          '422': 'Unprocessable Entity',
          '423': 'Locked',
          '424': 'Failed Dependency',
          '425': 'Unordered Collection',
          '426': 'Upgrade Required',
          '428': 'Precondition Required',
          '429': 'Too Many Requests',
          '431': 'Request Header Fields Too Large',
          '500': 'Internal Server Error',
          '501': 'Not Implemented',
          '502': 'Bad Gateway',
          '503': 'Service Unavailable',
          '504': 'Gateway Time-out',
          '505': 'HTTP Version Not Supported',
          '506': 'Variant Also Negotiates',
          '507': 'Insufficient Storage',
          '509': 'Bandwidth Limit Exceeded',
          '510': 'Not Extended',
          '511': 'Network Authentication Required'
        };
      },
      {}
    ],
    44: [
      function (require, module, exports) {
        (function (process, global) {
          'use strict';
          var next = global.process && process.nextTick || global.setImmediate || function (f) {
              setTimeout(f, 0);
            };
          module.exports = function maybe(cb, promise) {
            if (cb) {
              promise.then(function (result) {
                next(function () {
                  cb(null, result);
                });
              }, function (err) {
                next(function () {
                  cb(err);
                });
              });
              return undefined;
            } else {
              return promise;
            }
          };
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      { '_process': 115 }
    ],
    45: [
      function (require, module, exports) {
        (function (Buffer) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg);
            }
            return objectToString(arg) === '[object Array]';
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return objectToString(e) === '[object Error]' || e instanceof Error;
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          exports.isBuffer = Buffer.isBuffer;
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }.call(this, { 'isBuffer': require('../../is-buffer/index.js') }));
      },
      { '../../is-buffer/index.js': 55 }
    ],
    46: [
      function (require, module, exports) {
        /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = require('./debug');
        exports.log = log;
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
        /**
 * Colors.
 */
        exports.colors = [
          'lightseagreen',
          'forestgreen',
          'goldenrod',
          'dodgerblue',
          'darkorchid',
          'crimson'
        ];
        /**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
        function useColors() {
          // is webkit? http://stackoverflow.com/a/16459606/376773
          return 'WebkitAppearance' in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
        }
        /**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */
        exports.formatters.j = function (v) {
          return JSON.stringify(v);
        };
        /**
 * Colorize log arguments if enabled.
 *
 * @api public
 */
        function formatArgs() {
          var args = arguments;
          var useColors = this.useColors;
          args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
          if (!useColors)
            return args;
          var c = 'color: ' + this.color;
          args = [
            args[0],
            c,
            'color: inherit'
          ].concat(Array.prototype.slice.call(args, 1));
          // the final "%c" is somewhat tricky, because there could be other
          // arguments passed either before or after the %c, so we need to
          // figure out the correct index to insert the CSS into
          var index = 0;
          var lastC = 0;
          args[0].replace(/%[a-z%]/g, function (match) {
            if ('%%' === match)
              return;
            index++;
            if ('%c' === match) {
              // we only are interested in the *last* %c
              // (the user may have provided their own)
              lastC = index;
            }
          });
          args.splice(lastC, 0, c);
          return args;
        }
        /**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
        function log() {
          // this hackery is required for IE8/9, where
          // the `console.log` function doesn't have 'apply'
          return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
        function save(namespaces) {
          try {
            if (null == namespaces) {
              exports.storage.removeItem('debug');
            } else {
              exports.storage.debug = namespaces;
            }
          } catch (e) {
          }
        }
        /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
        function load() {
          var r;
          try {
            r = exports.storage.debug;
          } catch (e) {
          }
          return r;
        }
        /**
 * Enable namespaces listed in `localStorage.debug` initially.
 */
        exports.enable(load());
        /**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */
        function localstorage() {
          try {
            return window.localStorage;
          } catch (e) {
          }
        }
      },
      { './debug': 47 }
    ],
    47: [
      function (require, module, exports) {
        /**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = debug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = require('ms');
        /**
 * The currently active debug mode names, and names to skip.
 */
        exports.names = [];
        exports.skips = [];
        /**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */
        exports.formatters = {};
        /**
 * Previously assigned color.
 */
        var prevColor = 0;
        /**
 * Previous log timestamp.
 */
        var prevTime;
        /**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */
        function selectColor() {
          return exports.colors[prevColor++ % exports.colors.length];
        }
        /**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */
        function debug(namespace) {
          // define the `disabled` version
          function disabled() {
          }
          disabled.enabled = false;
          // define the `enabled` version
          function enabled() {
            var self = enabled;
            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            // add the `color` if not set
            if (null == self.useColors)
              self.useColors = exports.useColors();
            if (null == self.color && self.useColors)
              self.color = selectColor();
            var args = Array.prototype.slice.call(arguments);
            args[0] = exports.coerce(args[0]);
            if ('string' !== typeof args[0]) {
              // anything else let's inspect with %o
              args = ['%o'].concat(args);
            }
            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
              // if we encounter an escaped % then don't increase the array index
              if (match === '%%')
                return match;
              index++;
              var formatter = exports.formatters[format];
              if ('function' === typeof formatter) {
                var val = args[index];
                match = formatter.call(self, val);
                // now we need to remove `args[index]` since it's inlined in the `format`
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            if ('function' === typeof exports.formatArgs) {
              args = exports.formatArgs.apply(self, args);
            }
            var logFn = enabled.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
          }
          enabled.enabled = true;
          var fn = exports.enabled(namespace) ? enabled : disabled;
          fn.namespace = namespace;
          return fn;
        }
        /**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */
        function enable(namespaces) {
          exports.save(namespaces);
          var split = (namespaces || '').split(/[\s,]+/);
          var len = split.length;
          for (var i = 0; i < len; i++) {
            if (!split[i])
              continue;
            // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
              exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            } else {
              exports.names.push(new RegExp('^' + namespaces + '$'));
            }
          }
        }
        /**
 * Disable debug output.
 *
 * @api public
 */
        function disable() {
          exports.enable('');
        }
        /**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */
        function enabled(name) {
          var i, len;
          for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        /**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */
        function coerce(val) {
          if (val instanceof Error)
            return val.stack || val.message;
          return val;
        }
      },
      { 'ms': 110 }
    ],
    48: [
      function (require, module, exports) {
        (function (process, global) {
          /*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */
          (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.ES6Promise = factory();
          }(this, function () {
            'use strict';
            function objectOrFunction(x) {
              return typeof x === 'function' || typeof x === 'object' && x !== null;
            }
            function isFunction(x) {
              return typeof x === 'function';
            }
            var _isArray = undefined;
            if (!Array.isArray) {
              _isArray = function (x) {
                return Object.prototype.toString.call(x) === '[object Array]';
              };
            } else {
              _isArray = Array.isArray;
            }
            var isArray = _isArray;
            var len = 0;
            var vertxNext = undefined;
            var customSchedulerFn = undefined;
            var asap = function asap(callback, arg) {
              queue[len] = callback;
              queue[len + 1] = arg;
              len += 2;
              if (len === 2) {
                // If len is 2, that means that we need to schedule an async flush.
                // If additional callbacks are queued before the queue is flushed, they
                // will be processed by this flush that we are scheduling.
                if (customSchedulerFn) {
                  customSchedulerFn(flush);
                } else {
                  scheduleFlush();
                }
              }
            };
            function setScheduler(scheduleFn) {
              customSchedulerFn = scheduleFn;
            }
            function setAsap(asapFn) {
              asap = asapFn;
            }
            var browserWindow = typeof window !== 'undefined' ? window : undefined;
            var browserGlobal = browserWindow || {};
            var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
            var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
            // test for web worker but not in IE10
            var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
            // node
            function useNextTick() {
              // node version 0.10.x displays a deprecation warning when nextTick is used recursively
              // see https://github.com/cujojs/when/issues/410 for details
              return function () {
                return process.nextTick(flush);
              };
            }
            // vertx
            function useVertxTimer() {
              return function () {
                vertxNext(flush);
              };
            }
            function useMutationObserver() {
              var iterations = 0;
              var observer = new BrowserMutationObserver(flush);
              var node = document.createTextNode('');
              observer.observe(node, { characterData: true });
              return function () {
                node.data = iterations = ++iterations % 2;
              };
            }
            // web worker
            function useMessageChannel() {
              var channel = new MessageChannel();
              channel.port1.onmessage = flush;
              return function () {
                return channel.port2.postMessage(0);
              };
            }
            function useSetTimeout() {
              // Store setTimeout reference so es6-promise will be unaffected by
              // other code modifying setTimeout (like sinon.useFakeTimers())
              var globalSetTimeout = setTimeout;
              return function () {
                return globalSetTimeout(flush, 1);
              };
            }
            var queue = new Array(1000);
            function flush() {
              for (var i = 0; i < len; i += 2) {
                var callback = queue[i];
                var arg = queue[i + 1];
                callback(arg);
                queue[i] = undefined;
                queue[i + 1] = undefined;
              }
              len = 0;
            }
            function attemptVertx() {
              try {
                var r = require;
                var vertx = r('vertx');
                vertxNext = vertx.runOnLoop || vertx.runOnContext;
                return useVertxTimer();
              } catch (e) {
                return useSetTimeout();
              }
            }
            var scheduleFlush = undefined;
            // Decide what async method to use to triggering processing of queued callbacks:
            if (isNode) {
              scheduleFlush = useNextTick();
            } else if (BrowserMutationObserver) {
              scheduleFlush = useMutationObserver();
            } else if (isWorker) {
              scheduleFlush = useMessageChannel();
            } else if (browserWindow === undefined && typeof require === 'function') {
              scheduleFlush = attemptVertx();
            } else {
              scheduleFlush = useSetTimeout();
            }
            function then(onFulfillment, onRejection) {
              var _arguments = arguments;
              var parent = this;
              var child = new this.constructor(noop);
              if (child[PROMISE_ID] === undefined) {
                makePromise(child);
              }
              var _state = parent._state;
              if (_state) {
                (function () {
                  var callback = _arguments[_state - 1];
                  asap(function () {
                    return invokeCallback(_state, child, callback, parent._result);
                  });
                }());
              } else {
                subscribe(parent, child, onFulfillment, onRejection);
              }
              return child;
            }
            /**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
            function resolve(object) {
              /*jshint validthis:true */
              var Constructor = this;
              if (object && typeof object === 'object' && object.constructor === Constructor) {
                return object;
              }
              var promise = new Constructor(noop);
              _resolve(promise, object);
              return promise;
            }
            var PROMISE_ID = Math.random().toString(36).substring(16);
            function noop() {
            }
            var PENDING = void 0;
            var FULFILLED = 1;
            var REJECTED = 2;
            var GET_THEN_ERROR = new ErrorObject();
            function selfFulfillment() {
              return new TypeError('You cannot resolve a promise with itself');
            }
            function cannotReturnOwn() {
              return new TypeError('A promises callback cannot return that same promise.');
            }
            function getThen(promise) {
              try {
                return promise.then;
              } catch (error) {
                GET_THEN_ERROR.error = error;
                return GET_THEN_ERROR;
              }
            }
            function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
              try {
                then.call(value, fulfillmentHandler, rejectionHandler);
              } catch (e) {
                return e;
              }
            }
            function handleForeignThenable(promise, thenable, then) {
              asap(function (promise) {
                var sealed = false;
                var error = tryThen(then, thenable, function (value) {
                    if (sealed) {
                      return;
                    }
                    sealed = true;
                    if (thenable !== value) {
                      _resolve(promise, value);
                    } else {
                      fulfill(promise, value);
                    }
                  }, function (reason) {
                    if (sealed) {
                      return;
                    }
                    sealed = true;
                    _reject(promise, reason);
                  }, 'Settle: ' + (promise._label || ' unknown promise'));
                if (!sealed && error) {
                  sealed = true;
                  _reject(promise, error);
                }
              }, promise);
            }
            function handleOwnThenable(promise, thenable) {
              if (thenable._state === FULFILLED) {
                fulfill(promise, thenable._result);
              } else if (thenable._state === REJECTED) {
                _reject(promise, thenable._result);
              } else {
                subscribe(thenable, undefined, function (value) {
                  return _resolve(promise, value);
                }, function (reason) {
                  return _reject(promise, reason);
                });
              }
            }
            function handleMaybeThenable(promise, maybeThenable, then$$) {
              if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
                handleOwnThenable(promise, maybeThenable);
              } else {
                if (then$$ === GET_THEN_ERROR) {
                  _reject(promise, GET_THEN_ERROR.error);
                } else if (then$$ === undefined) {
                  fulfill(promise, maybeThenable);
                } else if (isFunction(then$$)) {
                  handleForeignThenable(promise, maybeThenable, then$$);
                } else {
                  fulfill(promise, maybeThenable);
                }
              }
            }
            function _resolve(promise, value) {
              if (promise === value) {
                _reject(promise, selfFulfillment());
              } else if (objectOrFunction(value)) {
                handleMaybeThenable(promise, value, getThen(value));
              } else {
                fulfill(promise, value);
              }
            }
            function publishRejection(promise) {
              if (promise._onerror) {
                promise._onerror(promise._result);
              }
              publish(promise);
            }
            function fulfill(promise, value) {
              if (promise._state !== PENDING) {
                return;
              }
              promise._result = value;
              promise._state = FULFILLED;
              if (promise._subscribers.length !== 0) {
                asap(publish, promise);
              }
            }
            function _reject(promise, reason) {
              if (promise._state !== PENDING) {
                return;
              }
              promise._state = REJECTED;
              promise._result = reason;
              asap(publishRejection, promise);
            }
            function subscribe(parent, child, onFulfillment, onRejection) {
              var _subscribers = parent._subscribers;
              var length = _subscribers.length;
              parent._onerror = null;
              _subscribers[length] = child;
              _subscribers[length + FULFILLED] = onFulfillment;
              _subscribers[length + REJECTED] = onRejection;
              if (length === 0 && parent._state) {
                asap(publish, parent);
              }
            }
            function publish(promise) {
              var subscribers = promise._subscribers;
              var settled = promise._state;
              if (subscribers.length === 0) {
                return;
              }
              var child = undefined, callback = undefined, detail = promise._result;
              for (var i = 0; i < subscribers.length; i += 3) {
                child = subscribers[i];
                callback = subscribers[i + settled];
                if (child) {
                  invokeCallback(settled, child, callback, detail);
                } else {
                  callback(detail);
                }
              }
              promise._subscribers.length = 0;
            }
            function ErrorObject() {
              this.error = null;
            }
            var TRY_CATCH_ERROR = new ErrorObject();
            function tryCatch(callback, detail) {
              try {
                return callback(detail);
              } catch (e) {
                TRY_CATCH_ERROR.error = e;
                return TRY_CATCH_ERROR;
              }
            }
            function invokeCallback(settled, promise, callback, detail) {
              var hasCallback = isFunction(callback), value = undefined, error = undefined, succeeded = undefined, failed = undefined;
              if (hasCallback) {
                value = tryCatch(callback, detail);
                if (value === TRY_CATCH_ERROR) {
                  failed = true;
                  error = value.error;
                  value = null;
                } else {
                  succeeded = true;
                }
                if (promise === value) {
                  _reject(promise, cannotReturnOwn());
                  return;
                }
              } else {
                value = detail;
                succeeded = true;
              }
              if (promise._state !== PENDING) {
              } else if (hasCallback && succeeded) {
                _resolve(promise, value);
              } else if (failed) {
                _reject(promise, error);
              } else if (settled === FULFILLED) {
                fulfill(promise, value);
              } else if (settled === REJECTED) {
                _reject(promise, value);
              }
            }
            function initializePromise(promise, resolver) {
              try {
                resolver(function resolvePromise(value) {
                  _resolve(promise, value);
                }, function rejectPromise(reason) {
                  _reject(promise, reason);
                });
              } catch (e) {
                _reject(promise, e);
              }
            }
            var id = 0;
            function nextId() {
              return id++;
            }
            function makePromise(promise) {
              promise[PROMISE_ID] = id++;
              promise._state = undefined;
              promise._result = undefined;
              promise._subscribers = [];
            }
            function Enumerator(Constructor, input) {
              this._instanceConstructor = Constructor;
              this.promise = new Constructor(noop);
              if (!this.promise[PROMISE_ID]) {
                makePromise(this.promise);
              }
              if (isArray(input)) {
                this._input = input;
                this.length = input.length;
                this._remaining = input.length;
                this._result = new Array(this.length);
                if (this.length === 0) {
                  fulfill(this.promise, this._result);
                } else {
                  this.length = this.length || 0;
                  this._enumerate();
                  if (this._remaining === 0) {
                    fulfill(this.promise, this._result);
                  }
                }
              } else {
                _reject(this.promise, validationError());
              }
            }
            function validationError() {
              return new Error('Array Methods must be provided an Array');
            }
            ;
            Enumerator.prototype._enumerate = function () {
              var length = this.length;
              var _input = this._input;
              for (var i = 0; this._state === PENDING && i < length; i++) {
                this._eachEntry(_input[i], i);
              }
            };
            Enumerator.prototype._eachEntry = function (entry, i) {
              var c = this._instanceConstructor;
              var resolve$$ = c.resolve;
              if (resolve$$ === resolve) {
                var _then = getThen(entry);
                if (_then === then && entry._state !== PENDING) {
                  this._settledAt(entry._state, i, entry._result);
                } else if (typeof _then !== 'function') {
                  this._remaining--;
                  this._result[i] = entry;
                } else if (c === Promise) {
                  var promise = new c(noop);
                  handleMaybeThenable(promise, entry, _then);
                  this._willSettleAt(promise, i);
                } else {
                  this._willSettleAt(new c(function (resolve$$) {
                    return resolve$$(entry);
                  }), i);
                }
              } else {
                this._willSettleAt(resolve$$(entry), i);
              }
            };
            Enumerator.prototype._settledAt = function (state, i, value) {
              var promise = this.promise;
              if (promise._state === PENDING) {
                this._remaining--;
                if (state === REJECTED) {
                  _reject(promise, value);
                } else {
                  this._result[i] = value;
                }
              }
              if (this._remaining === 0) {
                fulfill(promise, this._result);
              }
            };
            Enumerator.prototype._willSettleAt = function (promise, i) {
              var enumerator = this;
              subscribe(promise, undefined, function (value) {
                return enumerator._settledAt(FULFILLED, i, value);
              }, function (reason) {
                return enumerator._settledAt(REJECTED, i, reason);
              });
            };
            /**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
            function all(entries) {
              return new Enumerator(this, entries).promise;
            }
            /**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
            function race(entries) {
              /*jshint validthis:true */
              var Constructor = this;
              if (!isArray(entries)) {
                return new Constructor(function (_, reject) {
                  return reject(new TypeError('You must pass an array to race.'));
                });
              } else {
                return new Constructor(function (resolve, reject) {
                  var length = entries.length;
                  for (var i = 0; i < length; i++) {
                    Constructor.resolve(entries[i]).then(resolve, reject);
                  }
                });
              }
            }
            /**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
            function reject(reason) {
              /*jshint validthis:true */
              var Constructor = this;
              var promise = new Constructor(noop);
              _reject(promise, reason);
              return promise;
            }
            function needsResolver() {
              throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
            }
            function needsNew() {
              throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
            }
            /**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
            function Promise(resolver) {
              this[PROMISE_ID] = nextId();
              this._result = this._state = undefined;
              this._subscribers = [];
              if (noop !== resolver) {
                typeof resolver !== 'function' && needsResolver();
                this instanceof Promise ? initializePromise(this, resolver) : needsNew();
              }
            }
            Promise.all = all;
            Promise.race = race;
            Promise.resolve = resolve;
            Promise.reject = reject;
            Promise._setScheduler = setScheduler;
            Promise._setAsap = setAsap;
            Promise._asap = asap;
            Promise.prototype = {
              constructor: Promise,
              then: then,
              'catch': function _catch(onRejection) {
                return this.then(null, onRejection);
              }
            };
            function polyfill() {
              var local = undefined;
              if (typeof global !== 'undefined') {
                local = global;
              } else if (typeof self !== 'undefined') {
                local = self;
              } else {
                try {
                  local = Function('return this')();
                } catch (e) {
                  throw new Error('polyfill failed because global object is unavailable in this environment');
                }
              }
              var P = local.Promise;
              if (P) {
                var promiseToString = null;
                try {
                  promiseToString = Object.prototype.toString.call(P.resolve());
                } catch (e) {
                }
                if (promiseToString === '[object Promise]' && !P.cast) {
                  return;
                }
              }
              local.Promise = Promise;
            }
            polyfill();
            // Strange compat..
            Promise.polyfill = polyfill;
            Promise.Promise = Promise;
            return Promise;
          }));
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      { '_process': 115 }
    ],
    49: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        function EventEmitter() {
          this._events = this._events || {};
          this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;
        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        EventEmitter.defaultMaxListeners = 10;
        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function (n) {
          if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
          this._maxListeners = n;
          return this;
        };
        EventEmitter.prototype.emit = function (type) {
          var er, handler, len, args, i, listeners;
          if (!this._events)
            this._events = {};
          // If there is no 'error' event listener then throw.
          if (type === 'error') {
            if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
              er = arguments[1];
              if (er instanceof Error) {
                throw er;  // Unhandled 'error' event
              }
              throw TypeError('Uncaught, unspecified "error" event.');
            }
          }
          handler = this._events[type];
          if (isUndefined(handler))
            return false;
          if (isFunction(handler)) {
            switch (arguments.length) {
            // fast cases
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            // slower
            default:
              len = arguments.length;
              args = new Array(len - 1);
              for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
              handler.apply(this, args);
            }
          } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
              listeners[i].apply(this, args);
          }
          return true;
        };
        EventEmitter.prototype.addListener = function (type, listener) {
          var m;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events)
            this._events = {};
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (this._events.newListener)
            this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
          if (!this._events[type])
            // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
          else if (isObject(this._events[type]))
            // If we've already got an array, just append.
            this._events[type].push(listener);
          else
            // Adding the second element, need to change to array.
            this._events[type] = [
              this._events[type],
              listener
            ];
          // Check for listener leak
          if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
              m = this._maxListeners;
            } else {
              m = EventEmitter.defaultMaxListeners;
            }
            if (m && m > 0 && this._events[type].length > m) {
              this._events[type].warned = true;
              console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
              if (typeof console.trace === 'function') {
                // not supported in IE 10
                console.trace();
              }
            }
          }
          return this;
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.once = function (type, listener) {
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          var fired = false;
          function g() {
            this.removeListener(type, g);
            if (!fired) {
              fired = true;
              listener.apply(this, arguments);
            }
          }
          g.listener = listener;
          this.on(type, g);
          return this;
        };
        // emits a 'removeListener' event iff the listener was removed
        EventEmitter.prototype.removeListener = function (type, listener) {
          var list, position, length, i;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events || !this._events[type])
            return this;
          list = this._events[type];
          length = list.length;
          position = -1;
          if (list === listener || isFunction(list.listener) && list.listener === listener) {
            delete this._events[type];
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
              if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (list.length === 1) {
              list.length = 0;
              delete this._events[type];
            } else {
              list.splice(position, 1);
            }
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function (type) {
          var key, listeners;
          if (!this._events)
            return this;
          // not listening for removeListener, no need to emit
          if (!this._events.removeListener) {
            if (arguments.length === 0)
              this._events = {};
            else if (this._events[type])
              delete this._events[type];
            return this;
          }
          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            for (key in this._events) {
              if (key === 'removeListener')
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
          }
          listeners = this._events[type];
          if (isFunction(listeners)) {
            this.removeListener(type, listeners);
          } else {
            // LIFO order
            while (listeners.length)
              this.removeListener(type, listeners[listeners.length - 1]);
          }
          delete this._events[type];
          return this;
        };
        EventEmitter.prototype.listeners = function (type) {
          var ret;
          if (!this._events || !this._events[type])
            ret = [];
          else if (isFunction(this._events[type]))
            ret = [this._events[type]];
          else
            ret = this._events[type].slice();
          return ret;
        };
        EventEmitter.listenerCount = function (emitter, type) {
          var ret;
          if (!emitter._events || !emitter._events[type])
            ret = 0;
          else if (isFunction(emitter._events[type]))
            ret = 1;
          else
            ret = emitter._events[type].length;
          return ret;
        };
        function isFunction(arg) {
          return typeof arg === 'function';
        }
        function isNumber(arg) {
          return typeof arg === 'number';
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isUndefined(arg) {
          return arg === void 0;
        }
      },
      {}
    ],
    50: [
      function (require, module, exports) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var toString = Object.prototype.toString;
        module.exports = function forEach(obj, fn, ctx) {
          if (toString.call(fn) !== '[object Function]') {
            throw new TypeError('iterator must be a function');
          }
          var l = obj.length;
          if (l === +l) {
            for (var i = 0; i < l; i++) {
              fn.call(ctx, obj[i], i, obj);
            }
          } else {
            for (var k in obj) {
              if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
              }
            }
          }
        };
      },
      {}
    ],
    51: [
      function (require, module, exports) {
        var http = require('http');
        var https = module.exports;
        for (var key in http) {
          if (http.hasOwnProperty(key))
            https[key] = http[key];
        }
        ;
        https.request = function (params, cb) {
          if (!params)
            params = {};
          params.scheme = 'https';
          params.protocol = 'https:';
          return http.request.call(this, params, cb);
        };
      },
      { 'http': 133 }
    ],
    52: [
      function (require, module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      },
      {}
    ],
    53: [
      function (require, module, exports) {
        var indexOf = [].indexOf;
        module.exports = function (arr, obj) {
          if (indexOf)
            return arr.indexOf(obj);
          for (var i = 0; i < arr.length; ++i) {
            if (arr[i] === obj)
              return i;
          }
          return -1;
        };
      },
      {}
    ],
    54: [
      function (require, module, exports) {
        if (typeof Object.create === 'function') {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      },
      {}
    ],
    55: [
      function (require, module, exports) {
        /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function (obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
        }
        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
        }
      },
      {}
    ],
    56: [
      function (require, module, exports) {
        'use strict';
        var yaml = require('./lib/js-yaml.js');
        module.exports = yaml;
      },
      { './lib/js-yaml.js': 57 }
    ],
    57: [
      function (require, module, exports) {
        'use strict';
        var loader = require('./js-yaml/loader');
        var dumper = require('./js-yaml/dumper');
        function deprecated(name) {
          return function () {
            throw new Error('Function ' + name + ' is deprecated and cannot be used.');
          };
        }
        module.exports.Type = require('./js-yaml/type');
        module.exports.Schema = require('./js-yaml/schema');
        module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');
        module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');
        module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');
        module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
        module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
        module.exports.load = loader.load;
        module.exports.loadAll = loader.loadAll;
        module.exports.safeLoad = loader.safeLoad;
        module.exports.safeLoadAll = loader.safeLoadAll;
        module.exports.dump = dumper.dump;
        module.exports.safeDump = dumper.safeDump;
        module.exports.YAMLException = require('./js-yaml/exception');
        // Deprecated schema names from JS-YAML 2.0.x
        module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
        module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
        module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');
        // Deprecated functions from JS-YAML 1.x.x
        module.exports.scan = deprecated('scan');
        module.exports.parse = deprecated('parse');
        module.exports.compose = deprecated('compose');
        module.exports.addConstructor = deprecated('addConstructor');
      },
      {
        './js-yaml/dumper': 59,
        './js-yaml/exception': 60,
        './js-yaml/loader': 61,
        './js-yaml/schema': 63,
        './js-yaml/schema/core': 64,
        './js-yaml/schema/default_full': 65,
        './js-yaml/schema/default_safe': 66,
        './js-yaml/schema/failsafe': 67,
        './js-yaml/schema/json': 68,
        './js-yaml/type': 69
      }
    ],
    58: [
      function (require, module, exports) {
        'use strict';
        function isNothing(subject) {
          return typeof subject === 'undefined' || subject === null;
        }
        function isObject(subject) {
          return typeof subject === 'object' && subject !== null;
        }
        function toArray(sequence) {
          if (Array.isArray(sequence))
            return sequence;
          else if (isNothing(sequence))
            return [];
          return [sequence];
        }
        function extend(target, source) {
          var index, length, key, sourceKeys;
          if (source) {
            sourceKeys = Object.keys(source);
            for (index = 0, length = sourceKeys.length; index < length; index += 1) {
              key = sourceKeys[index];
              target[key] = source[key];
            }
          }
          return target;
        }
        function repeat(string, count) {
          var result = '', cycle;
          for (cycle = 0; cycle < count; cycle += 1) {
            result += string;
          }
          return result;
        }
        function isNegativeZero(number) {
          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
        }
        module.exports.isNothing = isNothing;
        module.exports.isObject = isObject;
        module.exports.toArray = toArray;
        module.exports.repeat = repeat;
        module.exports.isNegativeZero = isNegativeZero;
        module.exports.extend = extend;
      },
      {}
    ],
    59: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable no-use-before-define*/
        var common = require('./common');
        var YAMLException = require('./exception');
        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
        var _toString = Object.prototype.toString;
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CHAR_TAB = 9;
        /* Tab */
        var CHAR_LINE_FEED = 10;
        /* LF */
        var CHAR_SPACE = 32;
        /* Space */
        var CHAR_EXCLAMATION = 33;
        /* ! */
        var CHAR_DOUBLE_QUOTE = 34;
        /* " */
        var CHAR_SHARP = 35;
        /* # */
        var CHAR_PERCENT = 37;
        /* % */
        var CHAR_AMPERSAND = 38;
        /* & */
        var CHAR_SINGLE_QUOTE = 39;
        /* ' */
        var CHAR_ASTERISK = 42;
        /* * */
        var CHAR_COMMA = 44;
        /* , */
        var CHAR_MINUS = 45;
        /* - */
        var CHAR_COLON = 58;
        /* : */
        var CHAR_GREATER_THAN = 62;
        /* > */
        var CHAR_QUESTION = 63;
        /* ? */
        var CHAR_COMMERCIAL_AT = 64;
        /* @ */
        var CHAR_LEFT_SQUARE_BRACKET = 91;
        /* [ */
        var CHAR_RIGHT_SQUARE_BRACKET = 93;
        /* ] */
        var CHAR_GRAVE_ACCENT = 96;
        /* ` */
        var CHAR_LEFT_CURLY_BRACKET = 123;
        /* { */
        var CHAR_VERTICAL_LINE = 124;
        /* | */
        var CHAR_RIGHT_CURLY_BRACKET = 125;
        /* } */
        var ESCAPE_SEQUENCES = {};
        ESCAPE_SEQUENCES[0] = '\\0';
        ESCAPE_SEQUENCES[7] = '\\a';
        ESCAPE_SEQUENCES[8] = '\\b';
        ESCAPE_SEQUENCES[9] = '\\t';
        ESCAPE_SEQUENCES[10] = '\\n';
        ESCAPE_SEQUENCES[11] = '\\v';
        ESCAPE_SEQUENCES[12] = '\\f';
        ESCAPE_SEQUENCES[13] = '\\r';
        ESCAPE_SEQUENCES[27] = '\\e';
        ESCAPE_SEQUENCES[34] = '\\"';
        ESCAPE_SEQUENCES[92] = '\\\\';
        ESCAPE_SEQUENCES[133] = '\\N';
        ESCAPE_SEQUENCES[160] = '\\_';
        ESCAPE_SEQUENCES[8232] = '\\L';
        ESCAPE_SEQUENCES[8233] = '\\P';
        var DEPRECATED_BOOLEANS_SYNTAX = [
            'y',
            'Y',
            'yes',
            'Yes',
            'YES',
            'on',
            'On',
            'ON',
            'n',
            'N',
            'no',
            'No',
            'NO',
            'off',
            'Off',
            'OFF'
          ];
        function compileStyleMap(schema, map) {
          var result, keys, index, length, tag, style, type;
          if (map === null)
            return {};
          result = {};
          keys = Object.keys(map);
          for (index = 0, length = keys.length; index < length; index += 1) {
            tag = keys[index];
            style = String(map[tag]);
            if (tag.slice(0, 2) === '!!') {
              tag = 'tag:yaml.org,2002:' + tag.slice(2);
            }
            type = schema.compiledTypeMap[tag];
            if (type && _hasOwnProperty.call(type.styleAliases, style)) {
              style = type.styleAliases[style];
            }
            result[tag] = style;
          }
          return result;
        }
        function encodeHex(character) {
          var string, handle, length;
          string = character.toString(16).toUpperCase();
          if (character <= 255) {
            handle = 'x';
            length = 2;
          } else if (character <= 65535) {
            handle = 'u';
            length = 4;
          } else if (character <= 4294967295) {
            handle = 'U';
            length = 8;
          } else {
            throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
          }
          return '\\' + handle + common.repeat('0', length - string.length) + string;
        }
        function State(options) {
          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
          this.indent = Math.max(1, options['indent'] || 2);
          this.skipInvalid = options['skipInvalid'] || false;
          this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
          this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
          this.sortKeys = options['sortKeys'] || false;
          this.lineWidth = options['lineWidth'] || 80;
          this.noRefs = options['noRefs'] || false;
          this.noCompatMode = options['noCompatMode'] || false;
          this.implicitTypes = this.schema.compiledImplicit;
          this.explicitTypes = this.schema.compiledExplicit;
          this.tag = null;
          this.result = '';
          this.duplicates = [];
          this.usedDuplicates = null;
        }
        // Indents every line in a string. Empty lines (\n only) are not indented.
        function indentString(string, spaces) {
          var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
          while (position < length) {
            next = string.indexOf('\n', position);
            if (next === -1) {
              line = string.slice(position);
              position = length;
            } else {
              line = string.slice(position, next + 1);
              position = next + 1;
            }
            if (line.length && line !== '\n')
              result += ind;
            result += line;
          }
          return result;
        }
        function generateNextLine(state, level) {
          return '\n' + common.repeat(' ', state.indent * level);
        }
        function testImplicitResolving(state, str) {
          var index, length, type;
          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
            type = state.implicitTypes[index];
            if (type.resolve(str)) {
              return true;
            }
          }
          return false;
        }
        // [33] s-white ::= s-space | s-tab
        function isWhitespace(c) {
          return c === CHAR_SPACE || c === CHAR_TAB;
        }
        // Returns true if the character can be printed without escaping.
        // From YAML 1.2: "any allowed characters known to be non-printable
        // should also be escaped. [However,] This isnt mandatory"
        // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
        function isPrintable(c) {
          return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
        }
        // Simplified test for values allowed after the first character in plain style.
        function isPlainSafe(c) {
          // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
          // where nb-char ::= c-printable - b-char - c-byte-order-mark.
          return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;
        }
        // Simplified test for values allowed as the first character in plain style.
        function isPlainSafeFirst(c) {
          // Uses a subset of ns-char - c-indicator
          // where ns-char = nb-char - s-white.
          return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
        }
        var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
        // Determines which scalar styles are possible and returns the preferred style.
        // lineWidth = -1 => no limit.
        // Pre-conditions: str.length > 0.
        // Post-conditions:
        //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
        //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
        //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
          var i;
          var char;
          var hasLineBreak = false;
          var hasFoldableLine = false;
          // only checked if shouldTrackWidth
          var shouldTrackWidth = lineWidth !== -1;
          var previousLineBreak = -1;
          // count the first line correctly
          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
          if (singleLineOnly) {
            // Case: no block styles.
            // Check for disallowed characters to rule out plain and single.
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              plain = plain && isPlainSafe(char);
            }
          } else {
            // Case: block styles permitted.
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                  hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
                  previousLineBreak = i;
                }
              } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              plain = plain && isPlainSafe(char);
            }
            // in case the end is missing a \n
            hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ');
          }
          // Although every style can represent \n without escaping, prefer block styles
          // for multiline, since they're more readable and they don't add empty lines.
          // Also prefer folding a super-long line.
          if (!hasLineBreak && !hasFoldableLine) {
            // Strings interpretable as another type have to be quoted;
            // e.g. the string 'true' vs. the boolean true.
            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
          }
          // Edge case: block indentation indicator can only have one digit.
          if (string[0] === ' ' && indentPerLevel > 9) {
            return STYLE_DOUBLE;
          }
          // At this point we know block styles are valid.
          // Prefer literal style unless we want to fold.
          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
        }
        // Note: line breaking/folding is implemented for only the folded style.
        // NB. We drop the last trailing newline (if any) of a returned block scalar
        //  since the dumper adds its own newline. This always works:
        //     No ending newline => unaffected; already using strip "-" chomping.
        //     Ending newline    => removed then restored.
        //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
        function writeScalar(state, string, level, iskey) {
          state.dump = function () {
            if (string.length === 0) {
              return '\'\'';
            }
            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
              return '\'' + string + '\'';
            }
            var indent = state.indent * Math.max(1, level);
            // no 0-indent scalars
            // As indentation gets deeper, let the width decrease monotonically
            // to the lower bound min(state.lineWidth, 40).
            // Note that this implies
            //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
            //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
            // This behaves better than a constant minimum width which disallows narrower options,
            // or an indent threshold which causes the width to suddenly increase.
            var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
            // Without knowing if keys are implicit/explicit, assume implicit for safety.
            var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
            function testAmbiguity(string) {
              return testImplicitResolving(state, string);
            }
            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
            case STYLE_PLAIN:
              return string;
            case STYLE_SINGLE:
              return '\'' + string.replace(/'/g, '\'\'') + '\'';
            case STYLE_LITERAL:
              return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
              return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
              return '"' + escapeString(string, lineWidth) + '"';
            default:
              throw new YAMLException('impossible error: invalid scalar style');
            }
          }();
        }
        // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
        function blockHeader(string, indentPerLevel) {
          var indentIndicator = string[0] === ' ' ? String(indentPerLevel) : '';
          // note the special case: the string '\n' counts as a "trailing" empty line.
          var clip = string[string.length - 1] === '\n';
          var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
          var chomp = keep ? '+' : clip ? '' : '-';
          return indentIndicator + chomp + '\n';
        }
        // (See the note for writeScalar.)
        function dropEndingNewline(string) {
          return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
        }
        // Note: a long line without a suitable break point will exceed the width limit.
        // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
        function foldString(string, width) {
          // In folded style, $k$ consecutive newlines output as $k+1$ newlines
          // unless they're before or after a more-indented line, or at the very
          // beginning or end, in which case $k$ maps to $k$.
          // Therefore, parse each chunk as newline(s) followed by a content line.
          var lineRe = /(\n+)([^\n]*)/g;
          // first line (possibly an empty line)
          var result = function () {
              var nextLF = string.indexOf('\n');
              nextLF = nextLF !== -1 ? nextLF : string.length;
              lineRe.lastIndex = nextLF;
              return foldLine(string.slice(0, nextLF), width);
            }();
          // If we haven't reached the first content line yet, don't add an extra \n.
          var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
          var moreIndented;
          // rest of the lines
          var match;
          while (match = lineRe.exec(string)) {
            var prefix = match[1], line = match[2];
            moreIndented = line[0] === ' ';
            result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
            prevMoreIndented = moreIndented;
          }
          return result;
        }
        // Greedy line breaking.
        // Picks the longest line under the limit each time,
        // otherwise settles for the shortest line over the limit.
        // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
        function foldLine(line, width) {
          if (line === '' || line[0] === ' ')
            return line;
          // Since a more-indented line adds a \n, breaks can't be followed by a space.
          var breakRe = / [^ ]/g;
          // note: the match index will always be <= length-2.
          var match;
          // start is an inclusive index. end, curr, and next are exclusive.
          var start = 0, end, curr = 0, next = 0;
          var result = '';
          // Invariants: 0 <= start <= length-1.
          //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
          // Inside the loop:
          //   A match implies length >= 2, so curr and next are <= length-2.
          while (match = breakRe.exec(line)) {
            next = match.index;
            // maintain invariant: curr - start <= width
            if (next - start > width) {
              end = curr > start ? curr : next;
              // derive end <= length-2
              result += '\n' + line.slice(start, end);
              // skip the space that was output as \n
              start = end + 1;  // derive start <= length-1
            }
            curr = next;
          }
          // By the invariants, start <= length-1, so there is something left over.
          // It is either the whole string or a part starting from non-whitespace.
          result += '\n';
          // Insert a break if the remainder is too long and there is a break available.
          if (line.length - start > width && curr > start) {
            result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
          } else {
            result += line.slice(start);
          }
          return result.slice(1);  // drop extra \n joiner
        }
        // Escapes a double-quoted string.
        function escapeString(string) {
          var result = '';
          var char;
          var escapeSeq;
          for (var i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            escapeSeq = ESCAPE_SEQUENCES[char];
            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
          }
          return result;
        }
        function writeFlowSequence(state, level, object) {
          var _result = '', _tag = state.tag, index, length;
          for (index = 0, length = object.length; index < length; index += 1) {
            // Write only valid elements.
            if (writeNode(state, level, object[index], false, false)) {
              if (index !== 0)
                _result += ', ';
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = '[' + _result + ']';
        }
        function writeBlockSequence(state, level, object, compact) {
          var _result = '', _tag = state.tag, index, length;
          for (index = 0, length = object.length; index < length; index += 1) {
            // Write only valid elements.
            if (writeNode(state, level + 1, object[index], true, true)) {
              if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
              }
              _result += '- ' + state.dump;
            }
          }
          state.tag = _tag;
          state.dump = _result || '[]';  // Empty sequence if no valid values.
        }
        function writeFlowMapping(state, level, object) {
          var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = '';
            if (index !== 0)
              pairBuffer += ', ';
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level, objectKey, false, false)) {
              continue;  // Skip this pair because of invalid key;
            }
            if (state.dump.length > 1024)
              pairBuffer += '? ';
            pairBuffer += state.dump + ': ';
            if (!writeNode(state, level, objectValue, false, false)) {
              continue;  // Skip this pair because of invalid value.
            }
            pairBuffer += state.dump;
            // Both key and value are valid.
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = '{' + _result + '}';
        }
        function writeBlockMapping(state, level, object, compact) {
          var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
          // Allow sorting keys so that the output file is deterministic
          if (state.sortKeys === true) {
            // Default sorting
            objectKeyList.sort();
          } else if (typeof state.sortKeys === 'function') {
            // Custom sort function
            objectKeyList.sort(state.sortKeys);
          } else if (state.sortKeys) {
            // Something is wrong
            throw new YAMLException('sortKeys must be a boolean or a function');
          }
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = '';
            if (!compact || index !== 0) {
              pairBuffer += generateNextLine(state, level);
            }
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level + 1, objectKey, true, true, true)) {
              continue;  // Skip this pair because of invalid key.
            }
            explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
            if (explicitPair) {
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += '?';
              } else {
                pairBuffer += '? ';
              }
            }
            pairBuffer += state.dump;
            if (explicitPair) {
              pairBuffer += generateNextLine(state, level);
            }
            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
              continue;  // Skip this pair because of invalid value.
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += ':';
            } else {
              pairBuffer += ': ';
            }
            pairBuffer += state.dump;
            // Both key and value are valid.
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = _result || '{}';  // Empty mapping if no valid pairs.
        }
        function detectType(state, object, explicit) {
          var _result, typeList, index, length, type, style;
          typeList = explicit ? state.explicitTypes : state.implicitTypes;
          for (index = 0, length = typeList.length; index < length; index += 1) {
            type = typeList[index];
            if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
              state.tag = explicit ? type.tag : '?';
              if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === '[object Function]') {
                  _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                  _result = type.represent[style](object, style);
                } else {
                  throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
              }
              return true;
            }
          }
          return false;
        }
        // Serializes `object` and writes it to global `result`.
        // Returns true on success, or false on invalid object.
        //
        function writeNode(state, level, object, block, compact, iskey) {
          state.tag = null;
          state.dump = object;
          if (!detectType(state, object, false)) {
            detectType(state, object, true);
          }
          var type = _toString.call(state.dump);
          if (block) {
            block = state.flowLevel < 0 || state.flowLevel > level;
          }
          var objectOrArray = type === '[object Object]' || type === '[object Array]', duplicateIndex, duplicate;
          if (objectOrArray) {
            duplicateIndex = state.duplicates.indexOf(object);
            duplicate = duplicateIndex !== -1;
          }
          if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
            compact = false;
          }
          if (duplicate && state.usedDuplicates[duplicateIndex]) {
            state.dump = '*ref_' + duplicateIndex;
          } else {
            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
              state.usedDuplicates[duplicateIndex] = true;
            }
            if (type === '[object Object]') {
              if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object Array]') {
              if (block && state.dump.length !== 0) {
                writeBlockSequence(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowSequence(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object String]') {
              if (state.tag !== '?') {
                writeScalar(state, state.dump, level, iskey);
              }
            } else {
              if (state.skipInvalid)
                return false;
              throw new YAMLException('unacceptable kind of an object to dump ' + type);
            }
            if (state.tag !== null && state.tag !== '?') {
              state.dump = '!<' + state.tag + '> ' + state.dump;
            }
          }
          return true;
        }
        function getDuplicateReferences(object, state) {
          var objects = [], duplicatesIndexes = [], index, length;
          inspectNode(object, objects, duplicatesIndexes);
          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
            state.duplicates.push(objects[duplicatesIndexes[index]]);
          }
          state.usedDuplicates = new Array(length);
        }
        function inspectNode(object, objects, duplicatesIndexes) {
          var objectKeyList, index, length;
          if (object !== null && typeof object === 'object') {
            index = objects.indexOf(object);
            if (index !== -1) {
              if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
              }
            } else {
              objects.push(object);
              if (Array.isArray(object)) {
                for (index = 0, length = object.length; index < length; index += 1) {
                  inspectNode(object[index], objects, duplicatesIndexes);
                }
              } else {
                objectKeyList = Object.keys(object);
                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
              }
            }
          }
        }
        function dump(input, options) {
          options = options || {};
          var state = new State(options);
          if (!state.noRefs)
            getDuplicateReferences(input, state);
          if (writeNode(state, 0, input, true, true))
            return state.dump + '\n';
          return '';
        }
        function safeDump(input, options) {
          return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }
        module.exports.dump = dump;
        module.exports.safeDump = safeDump;
      },
      {
        './common': 58,
        './exception': 60,
        './schema/default_full': 65,
        './schema/default_safe': 66
      }
    ],
    60: [
      function (require, module, exports) {
        // YAML error class. http://stackoverflow.com/questions/8458984
        //
        'use strict';
        function YAMLException(reason, mark) {
          // Super constructor
          Error.call(this);
          // Include stack trace in error object
          if (Error.captureStackTrace) {
            // Chrome and NodeJS
            Error.captureStackTrace(this, this.constructor);
          } else {
            // FF, IE 10+ and Safari 6+. Fallback for others
            this.stack = new Error().stack || '';
          }
          this.name = 'YAMLException';
          this.reason = reason;
          this.mark = mark;
          this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
        }
        // Inherit from Error
        YAMLException.prototype = Object.create(Error.prototype);
        YAMLException.prototype.constructor = YAMLException;
        YAMLException.prototype.toString = function toString(compact) {
          var result = this.name + ': ';
          result += this.reason || '(unknown reason)';
          if (!compact && this.mark) {
            result += ' ' + this.mark.toString();
          }
          return result;
        };
        module.exports = YAMLException;
      },
      {}
    ],
    61: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable max-len,no-use-before-define*/
        var common = require('./common');
        var YAMLException = require('./exception');
        var Mark = require('./mark');
        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CONTEXT_FLOW_IN = 1;
        var CONTEXT_FLOW_OUT = 2;
        var CONTEXT_BLOCK_IN = 3;
        var CONTEXT_BLOCK_OUT = 4;
        var CHOMPING_CLIP = 1;
        var CHOMPING_STRIP = 2;
        var CHOMPING_KEEP = 3;
        var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
        var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
        var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function is_EOL(c) {
          return c === 10 || c === 13;
        }
        function is_WHITE_SPACE(c) {
          return c === 9 || c === 32;
        }
        function is_WS_OR_EOL(c) {
          return c === 9 || c === 32 || c === 10 || c === 13;
        }
        function is_FLOW_INDICATOR(c) {
          return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
        }
        function fromHexCode(c) {
          var lc;
          if (48 <= c && c <= 57) {
            return c - 48;
          }
          /*eslint-disable no-bitwise*/
          lc = c | 32;
          if (97 <= lc && lc <= 102) {
            return lc - 97 + 10;
          }
          return -1;
        }
        function escapedHexLen(c) {
          if (c === 120) {
            return 2;
          }
          if (c === 117) {
            return 4;
          }
          if (c === 85) {
            return 8;
          }
          return 0;
        }
        function fromDecimalCode(c) {
          if (48 <= c && c <= 57) {
            return c - 48;
          }
          return -1;
        }
        function simpleEscapeSequence(c) {
          return c === 48 ? '\0' : c === 97 ? '\x07' : c === 98 ? '\b' : c === 116 ? '\t' : c === 9 ? '\t' : c === 110 ? '\n' : c === 118 ? '\x0B' : c === 102 ? '\f' : c === 114 ? '\r' : c === 101 ? '\x1b' : c === 32 ? ' ' : c === 34 ? '"' : c === 47 ? '/' : c === 92 ? '\\' : c === 78 ? '\x85' : c === 95 ? '\xa0' : c === 76 ? '\u2028' : c === 80 ? '\u2029' : '';
        }
        function charFromCodepoint(c) {
          if (c <= 65535) {
            return String.fromCharCode(c);
          }
          // Encode UTF-16 surrogate pair
          // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
          return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
        }
        var simpleEscapeCheck = new Array(256);
        // integer, for fast access
        var simpleEscapeMap = new Array(256);
        for (var i = 0; i < 256; i++) {
          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
          simpleEscapeMap[i] = simpleEscapeSequence(i);
        }
        function State(input, options) {
          this.input = input;
          this.filename = options['filename'] || null;
          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
          this.onWarning = options['onWarning'] || null;
          this.legacy = options['legacy'] || false;
          this.json = options['json'] || false;
          this.listener = options['listener'] || null;
          this.implicitTypes = this.schema.compiledImplicit;
          this.typeMap = this.schema.compiledTypeMap;
          this.length = input.length;
          this.position = 0;
          this.line = 0;
          this.lineStart = 0;
          this.lineIndent = 0;
          this.documents = [];  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
        }
        function generateError(state, message) {
          return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
        }
        function throwError(state, message) {
          throw generateError(state, message);
        }
        function throwWarning(state, message) {
          if (state.onWarning) {
            state.onWarning.call(null, generateError(state, message));
          }
        }
        var directiveHandlers = {
            YAML: function handleYamlDirective(state, name, args) {
              var match, major, minor;
              if (state.version !== null) {
                throwError(state, 'duplication of %YAML directive');
              }
              if (args.length !== 1) {
                throwError(state, 'YAML directive accepts exactly one argument');
              }
              match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
              if (match === null) {
                throwError(state, 'ill-formed argument of the YAML directive');
              }
              major = parseInt(match[1], 10);
              minor = parseInt(match[2], 10);
              if (major !== 1) {
                throwError(state, 'unacceptable YAML version of the document');
              }
              state.version = args[0];
              state.checkLineBreaks = minor < 2;
              if (minor !== 1 && minor !== 2) {
                throwWarning(state, 'unsupported YAML version of the document');
              }
            },
            TAG: function handleTagDirective(state, name, args) {
              var handle, prefix;
              if (args.length !== 2) {
                throwError(state, 'TAG directive accepts exactly two arguments');
              }
              handle = args[0];
              prefix = args[1];
              if (!PATTERN_TAG_HANDLE.test(handle)) {
                throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
              }
              if (_hasOwnProperty.call(state.tagMap, handle)) {
                throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
              }
              if (!PATTERN_TAG_URI.test(prefix)) {
                throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
              }
              state.tagMap[handle] = prefix;
            }
          };
        function captureSegment(state, start, end, checkJson) {
          var _position, _length, _character, _result;
          if (start < end) {
            _result = state.input.slice(start, end);
            if (checkJson) {
              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                _character = _result.charCodeAt(_position);
                if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                  throwError(state, 'expected valid JSON character');
                }
              }
            } else if (PATTERN_NON_PRINTABLE.test(_result)) {
              throwError(state, 'the stream contains non-printable characters');
            }
            state.result += _result;
          }
        }
        function mergeMappings(state, destination, source, overridableKeys) {
          var sourceKeys, key, index, quantity;
          if (!common.isObject(source)) {
            throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
          }
          sourceKeys = Object.keys(source);
          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
            key = sourceKeys[index];
            if (!_hasOwnProperty.call(destination, key)) {
              destination[key] = source[key];
              overridableKeys[key] = true;
            }
          }
        }
        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) {
          var index, quantity;
          keyNode = String(keyNode);
          if (_result === null) {
            _result = {};
          }
          if (keyTag === 'tag:yaml.org,2002:merge') {
            if (Array.isArray(valueNode)) {
              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                mergeMappings(state, _result, valueNode[index], overridableKeys);
              }
            } else {
              mergeMappings(state, _result, valueNode, overridableKeys);
            }
          } else {
            if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
              throwError(state, 'duplicated mapping key');
            }
            _result[keyNode] = valueNode;
            delete overridableKeys[keyNode];
          }
          return _result;
        }
        function readLineBreak(state) {
          var ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 10) {
            state.position++;
          } else if (ch === 13) {
            state.position++;
            if (state.input.charCodeAt(state.position) === 10) {
              state.position++;
            }
          } else {
            throwError(state, 'a line break is expected');
          }
          state.line += 1;
          state.lineStart = state.position;
        }
        function skipSeparationSpace(state, allowComments, checkIndent) {
          var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (allowComments && ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 10 && ch !== 13 && ch !== 0);
            }
            if (is_EOL(ch)) {
              readLineBreak(state);
              ch = state.input.charCodeAt(state.position);
              lineBreaks++;
              state.lineIndent = 0;
              while (ch === 32) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
            } else {
              break;
            }
          }
          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
            throwWarning(state, 'deficient indentation');
          }
          return lineBreaks;
        }
        function testDocumentSeparator(state) {
          var _position = state.position, ch;
          ch = state.input.charCodeAt(_position);
          // Condition state.position === state.lineStart is tested
          // in parent on each call, for efficiency. No needs to test here again.
          if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
            _position += 3;
            ch = state.input.charCodeAt(_position);
            if (ch === 0 || is_WS_OR_EOL(ch)) {
              return true;
            }
          }
          return false;
        }
        function writeFoldedLines(state, count) {
          if (count === 1) {
            state.result += ' ';
          } else if (count > 1) {
            state.result += common.repeat('\n', count - 1);
          }
        }
        function readPlainScalar(state, nodeIndent, withinFlowCollection) {
          var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
          ch = state.input.charCodeAt(state.position);
          if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
            return false;
          }
          if (ch === 63 || ch === 45) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
              return false;
            }
          }
          state.kind = 'scalar';
          state.result = '';
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
          while (ch !== 0) {
            if (ch === 58) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                break;
              }
            } else if (ch === 35) {
              preceding = state.input.charCodeAt(state.position - 1);
              if (is_WS_OR_EOL(preceding)) {
                break;
              }
            } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
              break;
            } else if (is_EOL(ch)) {
              _line = state.line;
              _lineStart = state.lineStart;
              _lineIndent = state.lineIndent;
              skipSeparationSpace(state, false, -1);
              if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
              } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
              }
            }
            if (hasPendingContent) {
              captureSegment(state, captureStart, captureEnd, false);
              writeFoldedLines(state, state.line - _line);
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
            }
            if (!is_WHITE_SPACE(ch)) {
              captureEnd = state.position + 1;
            }
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, captureEnd, false);
          if (state.result) {
            return true;
          }
          state.kind = _kind;
          state.result = _result;
          return false;
        }
        function readSingleQuotedScalar(state, nodeIndent) {
          var ch, captureStart, captureEnd;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 39) {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 39) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (ch === 39) {
                captureStart = captureEnd = state.position;
                state.position++;
              } else {
                return true;
              }
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a single quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a single quoted scalar');
        }
        function readDoubleQuotedScalar(state, nodeIndent) {
          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 34) {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 34) {
              captureSegment(state, captureStart, state.position, true);
              state.position++;
              return true;
            } else if (ch === 92) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);  // TODO: rework to inline fn with no type cast?
              } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
              } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for (; hexLength > 0; hexLength--) {
                  ch = state.input.charCodeAt(++state.position);
                  if ((tmp = fromHexCode(ch)) >= 0) {
                    hexResult = (hexResult << 4) + tmp;
                  } else {
                    throwError(state, 'expected hexadecimal character');
                  }
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
              } else {
                throwError(state, 'unknown escape sequence');
              }
              captureStart = captureEnd = state.position;
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a double quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a double quoted scalar');
        }
        function readFlowCollection(state, nodeIndent) {
          var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 91) {
            terminator = 93;
            /* ] */
            isMapping = false;
            _result = [];
          } else if (ch === 123) {
            terminator = 125;
            /* } */
            isMapping = true;
            _result = {};
          } else {
            return false;
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(++state.position);
          while (ch !== 0) {
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === terminator) {
              state.position++;
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = isMapping ? 'mapping' : 'sequence';
              state.result = _result;
              return true;
            } else if (!readNext) {
              throwError(state, 'missed comma between flow collection entries');
            }
            keyTag = keyNode = valueNode = null;
            isPair = isExplicitPair = false;
            if (ch === 63) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            keyTag = state.tag;
            keyNode = state.result;
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if ((isExplicitPair || state.line === _line) && ch === 58) {
              isPair = true;
              ch = state.input.charCodeAt(++state.position);
              skipSeparationSpace(state, true, nodeIndent);
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              valueNode = state.result;
            }
            if (isMapping) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
            } else if (isPair) {
              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
            } else {
              _result.push(keyNode);
            }
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === 44) {
              readNext = true;
              ch = state.input.charCodeAt(++state.position);
            } else {
              readNext = false;
            }
          }
          throwError(state, 'unexpected end of the stream within a flow collection');
        }
        function readBlockScalar(state, nodeIndent) {
          var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 124) {
            folding = false;
          } else if (ch === 62) {
            folding = true;
          } else {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          while (ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
            if (ch === 43 || ch === 45) {
              if (CHOMPING_CLIP === chomping) {
                chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
              } else {
                throwError(state, 'repeat of a chomping mode identifier');
              }
            } else if ((tmp = fromDecimalCode(ch)) >= 0) {
              if (tmp === 0) {
                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
              } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
              } else {
                throwError(state, 'repeat of an indentation width identifier');
              }
            } else {
              break;
            }
          }
          if (is_WHITE_SPACE(ch)) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (is_WHITE_SPACE(ch));
            if (ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (!is_EOL(ch) && ch !== 0);
            }
          }
          while (ch !== 0) {
            readLineBreak(state);
            state.lineIndent = 0;
            ch = state.input.charCodeAt(state.position);
            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
            if (!detectedIndent && state.lineIndent > textIndent) {
              textIndent = state.lineIndent;
            }
            if (is_EOL(ch)) {
              emptyLines++;
              continue;
            }
            // End of the scalar.
            if (state.lineIndent < textIndent) {
              // Perform the chomping.
              if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
              } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                  // i.e. only if the scalar is not empty.
                  state.result += '\n';
                }
              }
              // Break this `while` cycle and go to the funciton's epilogue.
              break;
            }
            // Folded style: use fancy rules to handle line breaks.
            if (folding) {
              // Lines starting with white space characters (more-indented lines) are not folded.
              if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);  // End of more-indented block.
              } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat('\n', emptyLines + 1);  // Just one line break - perceive as the same line.
              } else if (emptyLines === 0) {
                if (didReadContent) {
                  // i.e. only if we have already read some scalar content.
                  state.result += ' ';
                }  // Several line breaks - perceive as different lines.
              } else {
                state.result += common.repeat('\n', emptyLines);
              }  // Literal style: just add exact number of line breaks between content lines.
            } else {
              // Keep all line breaks except the header line break.
              state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
            }
            didReadContent = true;
            detectedIndent = true;
            emptyLines = 0;
            captureStart = state.position;
            while (!is_EOL(ch) && ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, state.position, false);
          }
          return true;
        }
        function readBlockSequence(state, nodeIndent) {
          var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            if (ch !== 45) {
              break;
            }
            following = state.input.charCodeAt(state.position + 1);
            if (!is_WS_OR_EOL(following)) {
              break;
            }
            detected = true;
            state.position++;
            if (skipSeparationSpace(state, true, -1)) {
              if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
            _result.push(state.result);
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
              throwError(state, 'bad indentation of a sequence entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'sequence';
            state.result = _result;
            return true;
          }
          return false;
        }
        function readBlockMapping(state, nodeIndent, flowIndent) {
          var following, allowCompact, _line, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            following = state.input.charCodeAt(state.position + 1);
            _line = state.line;
            // Save the current line.
            //
            // Explicit notation case. There are two separate blocks:
            // first for the key (denoted by "?") and second for the value (denoted by ":")
            //
            if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
              if (ch === 63) {
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                  keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
              } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
              } else {
                throwError(state, 'incomplete explicit mapping pair; a key node is missed');
              }
              state.position += 1;
              ch = following;  //
                               // Implicit notation case. Flow-style node as the key first, then ":", and the value.
                               //
            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
              if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 58) {
                  ch = state.input.charCodeAt(++state.position);
                  if (!is_WS_OR_EOL(ch)) {
                    throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                  }
                  if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = false;
                  allowCompact = false;
                  keyTag = state.tag;
                  keyNode = state.result;
                } else if (detected) {
                  throwError(state, 'can not read an implicit mapping pair; a colon is missed');
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true;  // Keep the result of `composeNode`.
                }
              } else if (detected) {
                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true;  // Keep the result of `composeNode`.
              }
            } else {
              break;  // Reading is done. Go to the epilogue.
            }
            //
            // Common reading code for both explicit and implicit notations.
            //
            if (state.line === _line || state.lineIndent > nodeIndent) {
              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                  keyNode = state.result;
                } else {
                  valueNode = state.result;
                }
              }
              if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
                keyTag = keyNode = valueNode = null;
              }
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
            }
            if (state.lineIndent > nodeIndent && ch !== 0) {
              throwError(state, 'bad indentation of a mapping entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          //
          // Epilogue.
          //
          // Special case: last mapping's node contains only the key in explicit notation.
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          }
          // Expose the resulting mapping.
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'mapping';
            state.result = _result;
          }
          return detected;
        }
        function readTagProperty(state) {
          var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 33)
            return false;
          if (state.tag !== null) {
            throwError(state, 'duplication of a tag property');
          }
          ch = state.input.charCodeAt(++state.position);
          if (ch === 60) {
            isVerbatim = true;
            ch = state.input.charCodeAt(++state.position);
          } else if (ch === 33) {
            isNamed = true;
            tagHandle = '!!';
            ch = state.input.charCodeAt(++state.position);
          } else {
            tagHandle = '!';
          }
          _position = state.position;
          if (isVerbatim) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && ch !== 62);
            if (state.position < state.length) {
              tagName = state.input.slice(_position, state.position);
              ch = state.input.charCodeAt(++state.position);
            } else {
              throwError(state, 'unexpected end of the stream within a verbatim tag');
            }
          } else {
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              if (ch === 33) {
                if (!isNamed) {
                  tagHandle = state.input.slice(_position - 1, state.position + 1);
                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                    throwError(state, 'named tag handle cannot contain such characters');
                  }
                  isNamed = true;
                  _position = state.position + 1;
                } else {
                  throwError(state, 'tag suffix cannot contain exclamation marks');
                }
              }
              ch = state.input.charCodeAt(++state.position);
            }
            tagName = state.input.slice(_position, state.position);
            if (PATTERN_FLOW_INDICATORS.test(tagName)) {
              throwError(state, 'tag suffix cannot contain flow indicator characters');
            }
          }
          if (tagName && !PATTERN_TAG_URI.test(tagName)) {
            throwError(state, 'tag name cannot contain such characters: ' + tagName);
          }
          if (isVerbatim) {
            state.tag = tagName;
          } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
            state.tag = state.tagMap[tagHandle] + tagName;
          } else if (tagHandle === '!') {
            state.tag = '!' + tagName;
          } else if (tagHandle === '!!') {
            state.tag = 'tag:yaml.org,2002:' + tagName;
          } else {
            throwError(state, 'undeclared tag handle "' + tagHandle + '"');
          }
          return true;
        }
        function readAnchorProperty(state) {
          var _position, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 38)
            return false;
          if (state.anchor !== null) {
            throwError(state, 'duplication of an anchor property');
          }
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an anchor node must contain at least one character');
          }
          state.anchor = state.input.slice(_position, state.position);
          return true;
        }
        function readAlias(state) {
          var _position, alias, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 42)
            return false;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an alias node must contain at least one character');
          }
          alias = state.input.slice(_position, state.position);
          if (!state.anchorMap.hasOwnProperty(alias)) {
            throwError(state, 'unidentified alias "' + alias + '"');
          }
          state.result = state.anchorMap[alias];
          skipSeparationSpace(state, true, -1);
          return true;
        }
        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
          var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1,
            // 1: this>parent, 0: this=parent, -1: this<parent
            atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
          if (state.listener !== null) {
            state.listener('open', state);
          }
          state.tag = null;
          state.anchor = null;
          state.kind = null;
          state.result = null;
          allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
          if (allowToSeek) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            }
          }
          if (indentStatus === 1) {
            while (readTagProperty(state) || readAnchorProperty(state)) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              } else {
                allowBlockCollections = false;
              }
            }
          }
          if (allowBlockCollections) {
            allowBlockCollections = atNewLine || allowCompact;
          }
          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
              flowIndent = parentIndent;
            } else {
              flowIndent = parentIndent + 1;
            }
            blockIndent = state.position - state.lineStart;
            if (indentStatus === 1) {
              if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
              } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                  hasContent = true;
                } else if (readAlias(state)) {
                  hasContent = true;
                  if (state.tag !== null || state.anchor !== null) {
                    throwError(state, 'alias node should not have any properties');
                  }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                  hasContent = true;
                  if (state.tag === null) {
                    state.tag = '?';
                  }
                }
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else if (indentStatus === 0) {
              // Special case: block sequences are allowed to have same indentation level as the parent.
              // http://www.yaml.org/spec/1.2/spec.html#id2799784
              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
            }
          }
          if (state.tag !== null && state.tag !== '!') {
            if (state.tag === '?') {
              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];
                // Implicit resolving is not allowed for non-scalar types, and '?'
                // non-specific tag is only assigned to plain scalars. So, it isn't
                // needed to check for 'kind' conformity.
                if (type.resolve(state.result)) {
                  // `state.result` updated in resolver if matched
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
              type = state.typeMap[state.tag];
              if (state.result !== null && type.kind !== state.kind) {
                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
              }
              if (!type.resolve(state.result)) {
                // `state.result` updated in resolver if matched
                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
              } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else {
              throwError(state, 'unknown tag !<' + state.tag + '>');
            }
          }
          if (state.listener !== null) {
            state.listener('close', state);
          }
          return state.tag !== null || state.anchor !== null || hasContent;
        }
        function readDocument(state) {
          var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
          state.version = null;
          state.checkLineBreaks = state.legacy;
          state.tagMap = {};
          state.anchorMap = {};
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if (state.lineIndent > 0 || ch !== 37) {
              break;
            }
            hasDirectives = true;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveName = state.input.slice(_position, state.position);
            directiveArgs = [];
            if (directiveName.length < 1) {
              throwError(state, 'directive name must not be less than one character in length');
            }
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 35) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0 && !is_EOL(ch));
                break;
              }
              if (is_EOL(ch))
                break;
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveArgs.push(state.input.slice(_position, state.position));
            }
            if (ch !== 0)
              readLineBreak(state);
            if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
              directiveHandlers[directiveName](state, directiveName, directiveArgs);
            } else {
              throwWarning(state, 'unknown document directive "' + directiveName + '"');
            }
          }
          skipSeparationSpace(state, true, -1);
          if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          } else if (hasDirectives) {
            throwError(state, 'directives end mark is expected');
          }
          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
          skipSeparationSpace(state, true, -1);
          if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
            throwWarning(state, 'non-ASCII line breaks are interpreted as content');
          }
          state.documents.push(state.result);
          if (state.position === state.lineStart && testDocumentSeparator(state)) {
            if (state.input.charCodeAt(state.position) === 46) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            }
            return;
          }
          if (state.position < state.length - 1) {
            throwError(state, 'end of the stream or a document separator is expected');
          } else {
            return;
          }
        }
        function loadDocuments(input, options) {
          input = String(input);
          options = options || {};
          if (input.length !== 0) {
            // Add tailing `\n` if not exists
            if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
              input += '\n';
            }
            // Strip BOM
            if (input.charCodeAt(0) === 65279) {
              input = input.slice(1);
            }
          }
          var state = new State(input, options);
          // Use 0 as string terminator. That significantly simplifies bounds check.
          state.input += '\0';
          while (state.input.charCodeAt(state.position) === 32) {
            state.lineIndent += 1;
            state.position += 1;
          }
          while (state.position < state.length - 1) {
            readDocument(state);
          }
          return state.documents;
        }
        function loadAll(input, iterator, options) {
          var documents = loadDocuments(input, options), index, length;
          for (index = 0, length = documents.length; index < length; index += 1) {
            iterator(documents[index]);
          }
        }
        function load(input, options) {
          var documents = loadDocuments(input, options);
          if (documents.length === 0) {
            /*eslint-disable no-undefined*/
            return undefined;
          } else if (documents.length === 1) {
            return documents[0];
          }
          throw new YAMLException('expected a single document in the stream, but found more');
        }
        function safeLoadAll(input, output, options) {
          loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }
        function safeLoad(input, options) {
          return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }
        module.exports.loadAll = loadAll;
        module.exports.load = load;
        module.exports.safeLoadAll = safeLoadAll;
        module.exports.safeLoad = safeLoad;
      },
      {
        './common': 58,
        './exception': 60,
        './mark': 62,
        './schema/default_full': 65,
        './schema/default_safe': 66
      }
    ],
    62: [
      function (require, module, exports) {
        'use strict';
        var common = require('./common');
        function Mark(name, buffer, position, line, column) {
          this.name = name;
          this.buffer = buffer;
          this.position = position;
          this.line = line;
          this.column = column;
        }
        Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
          var head, start, tail, end, snippet;
          if (!this.buffer)
            return null;
          indent = indent || 4;
          maxLength = maxLength || 75;
          head = '';
          start = this.position;
          while (start > 0 && '\0\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
            start -= 1;
            if (this.position - start > maxLength / 2 - 1) {
              head = ' ... ';
              start += 5;
              break;
            }
          }
          tail = '';
          end = this.position;
          while (end < this.buffer.length && '\0\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
            end += 1;
            if (end - this.position > maxLength / 2 - 1) {
              tail = ' ... ';
              end -= 5;
              break;
            }
          }
          snippet = this.buffer.slice(start, end);
          return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
        };
        Mark.prototype.toString = function toString(compact) {
          var snippet, where = '';
          if (this.name) {
            where += 'in "' + this.name + '" ';
          }
          where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
          if (!compact) {
            snippet = this.getSnippet();
            if (snippet) {
              where += ':\n' + snippet;
            }
          }
          return where;
        };
        module.exports = Mark;
      },
      { './common': 58 }
    ],
    63: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable max-len*/
        var common = require('./common');
        var YAMLException = require('./exception');
        var Type = require('./type');
        function compileList(schema, name, result) {
          var exclude = [];
          schema.include.forEach(function (includedSchema) {
            result = compileList(includedSchema, name, result);
          });
          schema[name].forEach(function (currentType) {
            result.forEach(function (previousType, previousIndex) {
              if (previousType.tag === currentType.tag) {
                exclude.push(previousIndex);
              }
            });
            result.push(currentType);
          });
          return result.filter(function (type, index) {
            return exclude.indexOf(index) === -1;
          });
        }
        function compileMap() {
          var result = {}, index, length;
          function collectType(type) {
            result[type.tag] = type;
          }
          for (index = 0, length = arguments.length; index < length; index += 1) {
            arguments[index].forEach(collectType);
          }
          return result;
        }
        function Schema(definition) {
          this.include = definition.include || [];
          this.implicit = definition.implicit || [];
          this.explicit = definition.explicit || [];
          this.implicit.forEach(function (type) {
            if (type.loadKind && type.loadKind !== 'scalar') {
              throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
            }
          });
          this.compiledImplicit = compileList(this, 'implicit', []);
          this.compiledExplicit = compileList(this, 'explicit', []);
          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
        }
        Schema.DEFAULT = null;
        Schema.create = function createSchema() {
          var schemas, types;
          switch (arguments.length) {
          case 1:
            schemas = Schema.DEFAULT;
            types = arguments[0];
            break;
          case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
          default:
            throw new YAMLException('Wrong number of arguments for Schema.create function');
          }
          schemas = common.toArray(schemas);
          types = common.toArray(types);
          if (!schemas.every(function (schema) {
              return schema instanceof Schema;
            })) {
            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
          }
          if (!types.every(function (type) {
              return type instanceof Type;
            })) {
            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
          }
          return new Schema({
            include: schemas,
            explicit: types
          });
        };
        module.exports = Schema;
      },
      {
        './common': 58,
        './exception': 60,
        './type': 69
      }
    ],
    64: [
      function (require, module, exports) {
        // Standard YAML's Core schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2804923
        //
        // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
        // So, Core schema has no distinctions from JSON schema is JS-YAML.
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({ include: [require('./json')] });
      },
      {
        '../schema': 63,
        './json': 68
      }
    ],
    65: [
      function (require, module, exports) {
        // JS-YAML's default schema for `load` function.
        // It is not described in the YAML specification.
        //
        // This schema is based on JS-YAML's default safe schema and includes
        // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
        //
        // Also this schema is used as default base schema at `Schema.create` function.
        'use strict';
        var Schema = require('../schema');
        module.exports = Schema.DEFAULT = new Schema({
          include: [require('./default_safe')],
          explicit: [
            require('../type/js/undefined'),
            require('../type/js/regexp'),
            require('../type/js/function')
          ]
        });
      },
      {
        '../schema': 63,
        '../type/js/function': 74,
        '../type/js/regexp': 75,
        '../type/js/undefined': 76,
        './default_safe': 66
      }
    ],
    66: [
      function (require, module, exports) {
        // JS-YAML's default schema for `safeLoad` function.
        // It is not described in the YAML specification.
        //
        // This schema is based on standard YAML's Core schema and includes most of
        // extra types described at YAML tag repository. (http://yaml.org/type/)
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({
          include: [require('./core')],
          implicit: [
            require('../type/timestamp'),
            require('../type/merge')
          ],
          explicit: [
            require('../type/binary'),
            require('../type/omap'),
            require('../type/pairs'),
            require('../type/set')
          ]
        });
      },
      {
        '../schema': 63,
        '../type/binary': 70,
        '../type/merge': 78,
        '../type/omap': 80,
        '../type/pairs': 81,
        '../type/set': 83,
        '../type/timestamp': 85,
        './core': 64
      }
    ],
    67: [
      function (require, module, exports) {
        // Standard YAML's Failsafe schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2802346
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({
          explicit: [
            require('../type/str'),
            require('../type/seq'),
            require('../type/map')
          ]
        });
      },
      {
        '../schema': 63,
        '../type/map': 77,
        '../type/seq': 82,
        '../type/str': 84
      }
    ],
    68: [
      function (require, module, exports) {
        // Standard YAML's JSON schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2803231
        //
        // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
        // So, this schema is not such strict as defined in the YAML specification.
        // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({
          include: [require('./failsafe')],
          implicit: [
            require('../type/null'),
            require('../type/bool'),
            require('../type/int'),
            require('../type/float')
          ]
        });
      },
      {
        '../schema': 63,
        '../type/bool': 71,
        '../type/float': 72,
        '../type/int': 73,
        '../type/null': 79,
        './failsafe': 67
      }
    ],
    69: [
      function (require, module, exports) {
        'use strict';
        var YAMLException = require('./exception');
        var TYPE_CONSTRUCTOR_OPTIONS = [
            'kind',
            'resolve',
            'construct',
            'instanceOf',
            'predicate',
            'represent',
            'defaultStyle',
            'styleAliases'
          ];
        var YAML_NODE_KINDS = [
            'scalar',
            'sequence',
            'mapping'
          ];
        function compileStyleAliases(map) {
          var result = {};
          if (map !== null) {
            Object.keys(map).forEach(function (style) {
              map[style].forEach(function (alias) {
                result[String(alias)] = style;
              });
            });
          }
          return result;
        }
        function Type(tag, options) {
          options = options || {};
          Object.keys(options).forEach(function (name) {
            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
              throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
            }
          });
          // TODO: Add tag format check.
          this.tag = tag;
          this.kind = options['kind'] || null;
          this.resolve = options['resolve'] || function () {
            return true;
          };
          this.construct = options['construct'] || function (data) {
            return data;
          };
          this.instanceOf = options['instanceOf'] || null;
          this.predicate = options['predicate'] || null;
          this.represent = options['represent'] || null;
          this.defaultStyle = options['defaultStyle'] || null;
          this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
            throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
          }
        }
        module.exports = Type;
      },
      { './exception': 60 }
    ],
    70: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable no-bitwise*/
        var NodeBuffer;
        try {
          // A trick for browserified version, to not include `Buffer` shim
          var _require = require;
          NodeBuffer = _require('buffer').Buffer;
        } catch (__) {
        }
        var Type = require('../type');
        // [ 64, 65, 66 ] -> [ padding, CR, LF ]
        var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
        function resolveYamlBinary(data) {
          if (data === null)
            return false;
          var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
          // Convert one by one.
          for (idx = 0; idx < max; idx++) {
            code = map.indexOf(data.charAt(idx));
            // Skip CR/LF
            if (code > 64)
              continue;
            // Fail on illegal characters
            if (code < 0)
              return false;
            bitlen += 6;
          }
          // If there are any bits left, source was corrupted
          return bitlen % 8 === 0;
        }
        function constructYamlBinary(data) {
          var idx, tailbits, input = data.replace(/[\r\n=]/g, ''),
            // remove CR/LF & padding to simplify scan
            max = input.length, map = BASE64_MAP, bits = 0, result = [];
          // Collect by 6*4 bits (3 bytes)
          for (idx = 0; idx < max; idx++) {
            if (idx % 4 === 0 && idx) {
              result.push(bits >> 16 & 255);
              result.push(bits >> 8 & 255);
              result.push(bits & 255);
            }
            bits = bits << 6 | map.indexOf(input.charAt(idx));
          }
          // Dump tail
          tailbits = max % 4 * 6;
          if (tailbits === 0) {
            result.push(bits >> 16 & 255);
            result.push(bits >> 8 & 255);
            result.push(bits & 255);
          } else if (tailbits === 18) {
            result.push(bits >> 10 & 255);
            result.push(bits >> 2 & 255);
          } else if (tailbits === 12) {
            result.push(bits >> 4 & 255);
          }
          // Wrap into Buffer for NodeJS and leave Array for browser
          if (NodeBuffer)
            return new NodeBuffer(result);
          return result;
        }
        function representYamlBinary(object) {
          var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
          // Convert every three bytes to 4 ASCII characters.
          for (idx = 0; idx < max; idx++) {
            if (idx % 3 === 0 && idx) {
              result += map[bits >> 18 & 63];
              result += map[bits >> 12 & 63];
              result += map[bits >> 6 & 63];
              result += map[bits & 63];
            }
            bits = (bits << 8) + object[idx];
          }
          // Dump tail
          tail = max % 3;
          if (tail === 0) {
            result += map[bits >> 18 & 63];
            result += map[bits >> 12 & 63];
            result += map[bits >> 6 & 63];
            result += map[bits & 63];
          } else if (tail === 2) {
            result += map[bits >> 10 & 63];
            result += map[bits >> 4 & 63];
            result += map[bits << 2 & 63];
            result += map[64];
          } else if (tail === 1) {
            result += map[bits >> 2 & 63];
            result += map[bits << 4 & 63];
            result += map[64];
            result += map[64];
          }
          return result;
        }
        function isBinary(object) {
          return NodeBuffer && NodeBuffer.isBuffer(object);
        }
        module.exports = new Type('tag:yaml.org,2002:binary', {
          kind: 'scalar',
          resolve: resolveYamlBinary,
          construct: constructYamlBinary,
          predicate: isBinary,
          represent: representYamlBinary
        });
      },
      { '../type': 69 }
    ],
    71: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        function resolveYamlBoolean(data) {
          if (data === null)
            return false;
          var max = data.length;
          return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
        }
        function constructYamlBoolean(data) {
          return data === 'true' || data === 'True' || data === 'TRUE';
        }
        function isBoolean(object) {
          return Object.prototype.toString.call(object) === '[object Boolean]';
        }
        module.exports = new Type('tag:yaml.org,2002:bool', {
          kind: 'scalar',
          resolve: resolveYamlBoolean,
          construct: constructYamlBoolean,
          predicate: isBoolean,
          represent: {
            lowercase: function (object) {
              return object ? 'true' : 'false';
            },
            uppercase: function (object) {
              return object ? 'TRUE' : 'FALSE';
            },
            camelcase: function (object) {
              return object ? 'True' : 'False';
            }
          },
          defaultStyle: 'lowercase'
        });
      },
      { '../type': 69 }
    ],
    72: [
      function (require, module, exports) {
        'use strict';
        var common = require('../common');
        var Type = require('../type');
        var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');
        function resolveYamlFloat(data) {
          if (data === null)
            return false;
          if (!YAML_FLOAT_PATTERN.test(data))
            return false;
          return true;
        }
        function constructYamlFloat(data) {
          var value, sign, base, digits;
          value = data.replace(/_/g, '').toLowerCase();
          sign = value[0] === '-' ? -1 : 1;
          digits = [];
          if ('+-'.indexOf(value[0]) >= 0) {
            value = value.slice(1);
          }
          if (value === '.inf') {
            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          } else if (value === '.nan') {
            return NaN;
          } else if (value.indexOf(':') >= 0) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseFloat(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseFloat(value, 10);
        }
        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
        function representYamlFloat(object, style) {
          var res;
          if (isNaN(object)) {
            switch (style) {
            case 'lowercase':
              return '.nan';
            case 'uppercase':
              return '.NAN';
            case 'camelcase':
              return '.NaN';
            }
          } else if (Number.POSITIVE_INFINITY === object) {
            switch (style) {
            case 'lowercase':
              return '.inf';
            case 'uppercase':
              return '.INF';
            case 'camelcase':
              return '.Inf';
            }
          } else if (Number.NEGATIVE_INFINITY === object) {
            switch (style) {
            case 'lowercase':
              return '-.inf';
            case 'uppercase':
              return '-.INF';
            case 'camelcase':
              return '-.Inf';
            }
          } else if (common.isNegativeZero(object)) {
            return '-0.0';
          }
          res = object.toString(10);
          // JS stringifier can build scientific format without dots: 5e-100,
          // while YAML requres dot: 5.e-100. Fix it with simple hack
          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
        }
        function isFloat(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
        }
        module.exports = new Type('tag:yaml.org,2002:float', {
          kind: 'scalar',
          resolve: resolveYamlFloat,
          construct: constructYamlFloat,
          predicate: isFloat,
          represent: representYamlFloat,
          defaultStyle: 'lowercase'
        });
      },
      {
        '../common': 58,
        '../type': 69
      }
    ],
    73: [
      function (require, module, exports) {
        'use strict';
        var common = require('../common');
        var Type = require('../type');
        function isHexCode(c) {
          return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
        }
        function isOctCode(c) {
          return 48 <= c && c <= 55;
        }
        function isDecCode(c) {
          return 48 <= c && c <= 57;
        }
        function resolveYamlInteger(data) {
          if (data === null)
            return false;
          var max = data.length, index = 0, hasDigits = false, ch;
          if (!max)
            return false;
          ch = data[index];
          // sign
          if (ch === '-' || ch === '+') {
            ch = data[++index];
          }
          if (ch === '0') {
            // 0
            if (index + 1 === max)
              return true;
            ch = data[++index];
            // base 2, base 8, base 16
            if (ch === 'b') {
              // base 2
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_')
                  continue;
                if (ch !== '0' && ch !== '1')
                  return false;
                hasDigits = true;
              }
              return hasDigits;
            }
            if (ch === 'x') {
              // base 16
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_')
                  continue;
                if (!isHexCode(data.charCodeAt(index)))
                  return false;
                hasDigits = true;
              }
              return hasDigits;
            }
            // base 8
            for (; index < max; index++) {
              ch = data[index];
              if (ch === '_')
                continue;
              if (!isOctCode(data.charCodeAt(index)))
                return false;
              hasDigits = true;
            }
            return hasDigits;
          }
          // base 10 (except 0) or base 60
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_')
              continue;
            if (ch === ':')
              break;
            if (!isDecCode(data.charCodeAt(index))) {
              return false;
            }
            hasDigits = true;
          }
          if (!hasDigits)
            return false;
          // if !base60 - done;
          if (ch !== ':')
            return true;
          // base60 almost not used, no needs to optimize
          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
        }
        function constructYamlInteger(data) {
          var value = data, sign = 1, ch, base, digits = [];
          if (value.indexOf('_') !== -1) {
            value = value.replace(/_/g, '');
          }
          ch = value[0];
          if (ch === '-' || ch === '+') {
            if (ch === '-')
              sign = -1;
            value = value.slice(1);
            ch = value[0];
          }
          if (value === '0')
            return 0;
          if (ch === '0') {
            if (value[1] === 'b')
              return sign * parseInt(value.slice(2), 2);
            if (value[1] === 'x')
              return sign * parseInt(value, 16);
            return sign * parseInt(value, 8);
          }
          if (value.indexOf(':') !== -1) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseInt(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseInt(value, 10);
        }
        function isInteger(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 === 0 && !common.isNegativeZero(object));
        }
        module.exports = new Type('tag:yaml.org,2002:int', {
          kind: 'scalar',
          resolve: resolveYamlInteger,
          construct: constructYamlInteger,
          predicate: isInteger,
          represent: {
            binary: function (object) {
              return '0b' + object.toString(2);
            },
            octal: function (object) {
              return '0' + object.toString(8);
            },
            decimal: function (object) {
              return object.toString(10);
            },
            hexadecimal: function (object) {
              return '0x' + object.toString(16).toUpperCase();
            }
          },
          defaultStyle: 'decimal',
          styleAliases: {
            binary: [
              2,
              'bin'
            ],
            octal: [
              8,
              'oct'
            ],
            decimal: [
              10,
              'dec'
            ],
            hexadecimal: [
              16,
              'hex'
            ]
          }
        });
      },
      {
        '../common': 58,
        '../type': 69
      }
    ],
    74: [
      function (require, module, exports) {
        'use strict';
        var esprima;
        // Browserified version does not have esprima
        //
        // 1. For node.js just require module as deps
        // 2. For browser try to require mudule via external AMD system.
        //    If not found - try to fallback to window.esprima. If not
        //    found too - then fail to parse.
        //
        try {
          // workaround to exclude package from browserify list.
          var _require = require;
          esprima = _require('esprima');
        } catch (_) {
          /*global window */
          if (typeof window !== 'undefined')
            esprima = window.esprima;
        }
        var Type = require('../../type');
        function resolveJavascriptFunction(data) {
          if (data === null)
            return false;
          try {
            var source = '(' + data + ')', ast = esprima.parse(source, { range: true });
            if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        function constructJavascriptFunction(data) {
          /*jslint evil:true*/
          var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
            throw new Error('Failed to resolve function');
          }
          ast.body[0].expression.params.forEach(function (param) {
            params.push(param.name);
          });
          body = ast.body[0].expression.body.range;
          // Esprima's ranges include the first '{' and the last '}' characters on
          // function expressions. So cut them out.
          /*eslint-disable no-new-func*/
          return new Function(params, source.slice(body[0] + 1, body[1] - 1));
        }
        function representJavascriptFunction(object) {
          return object.toString();
        }
        function isFunction(object) {
          return Object.prototype.toString.call(object) === '[object Function]';
        }
        module.exports = new Type('tag:yaml.org,2002:js/function', {
          kind: 'scalar',
          resolve: resolveJavascriptFunction,
          construct: constructJavascriptFunction,
          predicate: isFunction,
          represent: representJavascriptFunction
        });
      },
      { '../../type': 69 }
    ],
    75: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../../type');
        function resolveJavascriptRegExp(data) {
          if (data === null)
            return false;
          if (data.length === 0)
            return false;
          var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
          // if regexp starts with '/' it can have modifiers and must be properly closed
          // `/foo/gim` - modifiers tail can be maximum 3 chars
          if (regexp[0] === '/') {
            if (tail)
              modifiers = tail[1];
            if (modifiers.length > 3)
              return false;
            // if expression starts with /, is should be properly terminated
            if (regexp[regexp.length - modifiers.length - 1] !== '/')
              return false;
          }
          return true;
        }
        function constructJavascriptRegExp(data) {
          var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
          // `/foo/gim` - tail can be maximum 4 chars
          if (regexp[0] === '/') {
            if (tail)
              modifiers = tail[1];
            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
          }
          return new RegExp(regexp, modifiers);
        }
        function representJavascriptRegExp(object) {
          var result = '/' + object.source + '/';
          if (object.global)
            result += 'g';
          if (object.multiline)
            result += 'm';
          if (object.ignoreCase)
            result += 'i';
          return result;
        }
        function isRegExp(object) {
          return Object.prototype.toString.call(object) === '[object RegExp]';
        }
        module.exports = new Type('tag:yaml.org,2002:js/regexp', {
          kind: 'scalar',
          resolve: resolveJavascriptRegExp,
          construct: constructJavascriptRegExp,
          predicate: isRegExp,
          represent: representJavascriptRegExp
        });
      },
      { '../../type': 69 }
    ],
    76: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../../type');
        function resolveJavascriptUndefined() {
          return true;
        }
        function constructJavascriptUndefined() {
          /*eslint-disable no-undefined*/
          return undefined;
        }
        function representJavascriptUndefined() {
          return '';
        }
        function isUndefined(object) {
          return typeof object === 'undefined';
        }
        module.exports = new Type('tag:yaml.org,2002:js/undefined', {
          kind: 'scalar',
          resolve: resolveJavascriptUndefined,
          construct: constructJavascriptUndefined,
          predicate: isUndefined,
          represent: representJavascriptUndefined
        });
      },
      { '../../type': 69 }
    ],
    77: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        module.exports = new Type('tag:yaml.org,2002:map', {
          kind: 'mapping',
          construct: function (data) {
            return data !== null ? data : {};
          }
        });
      },
      { '../type': 69 }
    ],
    78: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        function resolveYamlMerge(data) {
          return data === '<<' || data === null;
        }
        module.exports = new Type('tag:yaml.org,2002:merge', {
          kind: 'scalar',
          resolve: resolveYamlMerge
        });
      },
      { '../type': 69 }
    ],
    79: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        function resolveYamlNull(data) {
          if (data === null)
            return true;
          var max = data.length;
          return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
        }
        function constructYamlNull() {
          return null;
        }
        function isNull(object) {
          return object === null;
        }
        module.exports = new Type('tag:yaml.org,2002:null', {
          kind: 'scalar',
          resolve: resolveYamlNull,
          construct: constructYamlNull,
          predicate: isNull,
          represent: {
            canonical: function () {
              return '~';
            },
            lowercase: function () {
              return 'null';
            },
            uppercase: function () {
              return 'NULL';
            },
            camelcase: function () {
              return 'Null';
            }
          },
          defaultStyle: 'lowercase'
        });
      },
      { '../type': 69 }
    ],
    80: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var _toString = Object.prototype.toString;
        function resolveYamlOmap(data) {
          if (data === null)
            return true;
          var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            pairHasKey = false;
            if (_toString.call(pair) !== '[object Object]')
              return false;
            for (pairKey in pair) {
              if (_hasOwnProperty.call(pair, pairKey)) {
                if (!pairHasKey)
                  pairHasKey = true;
                else
                  return false;
              }
            }
            if (!pairHasKey)
              return false;
            if (objectKeys.indexOf(pairKey) === -1)
              objectKeys.push(pairKey);
            else
              return false;
          }
          return true;
        }
        function constructYamlOmap(data) {
          return data !== null ? data : [];
        }
        module.exports = new Type('tag:yaml.org,2002:omap', {
          kind: 'sequence',
          resolve: resolveYamlOmap,
          construct: constructYamlOmap
        });
      },
      { '../type': 69 }
    ],
    81: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var _toString = Object.prototype.toString;
        function resolveYamlPairs(data) {
          if (data === null)
            return true;
          var index, length, pair, keys, result, object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            if (_toString.call(pair) !== '[object Object]')
              return false;
            keys = Object.keys(pair);
            if (keys.length !== 1)
              return false;
            result[index] = [
              keys[0],
              pair[keys[0]]
            ];
          }
          return true;
        }
        function constructYamlPairs(data) {
          if (data === null)
            return [];
          var index, length, pair, keys, result, object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            keys = Object.keys(pair);
            result[index] = [
              keys[0],
              pair[keys[0]]
            ];
          }
          return result;
        }
        module.exports = new Type('tag:yaml.org,2002:pairs', {
          kind: 'sequence',
          resolve: resolveYamlPairs,
          construct: constructYamlPairs
        });
      },
      { '../type': 69 }
    ],
    82: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        module.exports = new Type('tag:yaml.org,2002:seq', {
          kind: 'sequence',
          construct: function (data) {
            return data !== null ? data : [];
          }
        });
      },
      { '../type': 69 }
    ],
    83: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        function resolveYamlSet(data) {
          if (data === null)
            return true;
          var key, object = data;
          for (key in object) {
            if (_hasOwnProperty.call(object, key)) {
              if (object[key] !== null)
                return false;
            }
          }
          return true;
        }
        function constructYamlSet(data) {
          return data !== null ? data : {};
        }
        module.exports = new Type('tag:yaml.org,2002:set', {
          kind: 'mapping',
          resolve: resolveYamlSet,
          construct: constructYamlSet
        });
      },
      { '../type': 69 }
    ],
    84: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        module.exports = new Type('tag:yaml.org,2002:str', {
          kind: 'scalar',
          construct: function (data) {
            return data !== null ? data : '';
          }
        });
      },
      { '../type': 69 }
    ],
    85: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9])' + '-([0-9][0-9])$');
        // [3] day
        var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9]?)' + '-([0-9][0-9]?)' + '(?:[Tt]|[ \\t]+)' + '([0-9][0-9]?)' + ':([0-9][0-9])' + ':([0-9][0-9])' + '(?:\\.([0-9]*))?' + '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + '(?::([0-9][0-9]))?))?$');
        // [11] tz_minute
        function resolveYamlTimestamp(data) {
          if (data === null)
            return false;
          if (YAML_DATE_REGEXP.exec(data) !== null)
            return true;
          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
            return true;
          return false;
        }
        function constructYamlTimestamp(data) {
          var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
          match = YAML_DATE_REGEXP.exec(data);
          if (match === null)
            match = YAML_TIMESTAMP_REGEXP.exec(data);
          if (match === null)
            throw new Error('Date resolve error');
          // match: [1] year [2] month [3] day
          year = +match[1];
          month = +match[2] - 1;
          // JS month starts with 0
          day = +match[3];
          if (!match[4]) {
            // no hour
            return new Date(Date.UTC(year, month, day));
          }
          // match: [4] hour [5] minute [6] second [7] fraction
          hour = +match[4];
          minute = +match[5];
          second = +match[6];
          if (match[7]) {
            fraction = match[7].slice(0, 3);
            while (fraction.length < 3) {
              // milli-seconds
              fraction += '0';
            }
            fraction = +fraction;
          }
          // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
          if (match[9]) {
            tz_hour = +match[10];
            tz_minute = +(match[11] || 0);
            delta = (tz_hour * 60 + tz_minute) * 60000;
            // delta in mili-seconds
            if (match[9] === '-')
              delta = -delta;
          }
          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
          if (delta)
            date.setTime(date.getTime() - delta);
          return date;
        }
        function representYamlTimestamp(object) {
          return object.toISOString();
        }
        module.exports = new Type('tag:yaml.org,2002:timestamp', {
          kind: 'scalar',
          resolve: resolveYamlTimestamp,
          construct: constructYamlTimestamp,
          instanceOf: Date,
          represent: representYamlTimestamp
        });
      },
      { '../type': 69 }
    ],
    86: [
      function (require, module, exports) {
        var JsonSchemaCompatability = function () {
            function convert3to4Type(types, always) {
              if (!Array.isArray(types)) {
                types = [types];
              }
              var needsReplacement = !!always;
              var result = [];
              for (var i = 0; i < types.length; i++) {
                var entry = types[i];
                if (typeof entry === 'object') {
                  result.push(entry);
                  needsReplacement = true;
                } else {
                  result.push({ 'type': entry });
                }
              }
              return needsReplacement && result;
            }
            function convert3to4(obj) {
              // Old-style "type"
              if (obj.type) {
                if (typeof obj.type !== 'string') {
                  var anyOf = convert3to4Type(obj.type);
                  if (anyOf) {
                    obj.anyOf = anyOf;
                    delete obj.type;
                  }
                } else if (obj.type == 'any') {
                  delete obj.type;
                }
              }
              if (obj['extends']) {
                var allOf = obj['extends'];
                if (!Array.isArray(allOf)) {
                  allOf = [allOf];
                }
                obj.allOf = allOf;
                delete obj['extends'];
              }
              if (obj.disallow) {
                if (typeof obj.disallow === 'string') {
                  obj.not = { 'type': obj.disallow };
                } else {
                  obj.not = { 'anyOf': convert3to4Type(obj.disallow, true) };
                }
                delete obj.disallow;
              }
              // Object concerns
              if (obj.properties) {
                var required = Array.isArray(obj.required) ? obj.required : [];
                for (var key in obj.properties) {
                  var subSchema = obj.properties[key];
                  if (subSchema && typeof subSchema.required === 'boolean') {
                    if (subSchema.required) {
                      required.push(key);
                    }
                    delete subSchema.required;
                  }
                }
                if (required.length) {
                  obj.required = required;
                }
              }
              if (obj.dependencies) {
                for (var key in obj.dependencies) {
                  if (typeof obj.dependencies[key] === 'string') {
                    obj.dependencies[key] = [obj.dependencies[key]];
                  }
                }
              }
              // This is safe as long as we process our children *after* we collect their "required" properties
              // - otherwise, they'd delete their "required" booleans before we got a chance to see them
              if (typeof obj.required === 'boolean') {
                delete obj.required;
              }
              // Numeric concerns
              if (typeof obj.divisibleBy !== 'undefined') {
                obj.multipleOf = obj.divisibleBy;
                delete obj.divisibleBy;
              }
              // This MUST happen at the end of the function, otherwise it'll screw up "required" collection
              for (var key in obj) {
                if (key === 'properties' || key === 'patternProperties' || key === 'dependencies') {
                  for (var subKey in obj[key]) {
                    obj[key][subKey] = convert3to4(obj[key][subKey]);
                  }
                } else if (key !== 'enum') {
                  if (Array.isArray(obj[key])) {
                    for (var i = 0; i < obj[key].length; i++) {
                      obj[key][i] = convert3to4(obj[key][i]);
                    }
                  } else if (typeof obj[key] === 'object') {
                    obj[key] = convert3to4(obj[key]);
                  }
                }
              }
              return obj;
            }
            var api = { v4: convert3to4 };
            if (typeof module !== 'undefined') {
              module.exports = api;
            }
            return api;
          }();
      },
      {}
    ],
    87: [
      function (require, module, exports) {
        /** !
 * JSON Schema $Ref Parser v3.1.2
 *
 * @link https://github.com/BigstickCarpet/json-schema-ref-parser
 * @license MIT
 */
        'use strict';
        var $Ref = require('./ref'), Pointer = require('./pointer'), debug = require('./util/debug'), url = require('./util/url');
        module.exports = bundle;
        /**
 * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that
 * only has *internal* references, not any *external* references.
 * This method mutates the JSON schema object, adding new references and re-mapping existing ones.
 *
 * @param {$RefParser} parser
 * @param {$RefParserOptions} options
 */
        function bundle(parser, options) {
          debug('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);
          // Build an inventory of all $ref pointers in the JSON Schema
          var inventory = [];
          crawl(parser, 'schema', parser.$refs._root$Ref.path + '#', '#', inventory, parser.$refs, options);
          // Remap all $ref pointers
          remap(inventory);
        }
        /**
 * Recursively crawls the given value, and inventories all JSON references.
 *
 * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.
 * @param {string} key - The property key of `parent` to be crawled
 * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of the property being crawled, from the schema root
 * @param {object[]} inventory - An array of already-inventoried $ref pointers
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 */
        function crawl(parent, key, path, pathFromRoot, inventory, $refs, options) {
          var obj = key === null ? parent : parent[key];
          if (obj && typeof obj === 'object') {
            if ($Ref.is$Ref(obj)) {
              inventory$Ref(parent, key, path, pathFromRoot, inventory, $refs, options);
            } else {
              var keys = Object.keys(obj);
              // Most people will expect references to be bundled into the the "definitions" property,
              // so we always crawl that property first, if it exists.
              var defs = keys.indexOf('definitions');
              if (defs > 0) {
                keys.splice(0, 0, keys.splice(defs, 1)[0]);
              }
              keys.forEach(function (key) {
                var keyPath = Pointer.join(path, key);
                var keyPathFromRoot = Pointer.join(pathFromRoot, key);
                var value = obj[key];
                if ($Ref.is$Ref(value)) {
                  inventory$Ref(obj, key, path, keyPathFromRoot, inventory, $refs, options);
                } else {
                  crawl(obj, key, keyPath, keyPathFromRoot, inventory, $refs, options);
                }
              });
            }
          }
        }
        /**
 * Inventories the given JSON Reference (i.e. records detailed information about it so we can
 * optimize all $refs in the schema), and then crawls the resolved value.
 *
 * @param {object} $refParent - The object that contains a JSON Reference as one of its keys
 * @param {string} $refKey - The key in `$refParent` that is a JSON Reference
 * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root
 * @param {object[]} inventory - An array of already-inventoried $ref pointers
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 */
        function inventory$Ref($refParent, $refKey, path, pathFromRoot, inventory, $refs, options) {
          if (inventory.some(function (i) {
              return i.parent === $refParent && i.key === $refKey;
            })) {
            // This $Ref has already been inventoried, so we don't need to process it again
            return;
          }
          var $ref = $refKey === null ? $refParent : $refParent[$refKey];
          var $refPath = url.resolve(path, $ref.$ref);
          var pointer = $refs._resolve($refPath, options);
          var depth = Pointer.parse(pathFromRoot).length;
          var file = url.stripHash(pointer.path);
          var hash = url.getHash(pointer.path);
          var external = file !== $refs._root$Ref.path;
          var extended = $Ref.isExtended$Ref($ref);
          inventory.push({
            $ref: $ref,
            parent: $refParent,
            key: $refKey,
            pathFromRoot: pathFromRoot,
            depth: depth,
            file: file,
            hash: hash,
            value: pointer.value,
            circular: pointer.circular,
            extended: extended,
            external: external
          });
          // Recursively crawl the resolved value
          crawl(pointer.value, null, pointer.path, pathFromRoot, inventory, $refs, options);
        }
        /**
 * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.
 * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same
 * value are re-mapped to point to the first reference.
 *
 * @example:
 *  {
 *    first: { $ref: somefile.json#/some/part },
 *    second: { $ref: somefile.json#/another/part },
 *    third: { $ref: somefile.json },
 *    fourth: { $ref: somefile.json#/some/part/sub/part }
 *  }
 *
 * In this example, there are four references to the same file, but since the third reference points
 * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be
 * remapped to point inside the third one.
 *
 * On the other hand, if the third reference DIDN'T exist, then the first and second would both need
 * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT
 * need to be dereferenced, because it can be remapped to point inside the first one.
 *
 * @param {object[]} inventory
 */
        function remap(inventory) {
          // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them
          inventory.sort(function (a, b) {
            if (a.file !== b.file) {
              return a.file < b.file ? -1 : +1;  // Group all the $refs that point to the same file
            } else if (a.hash !== b.hash) {
              return a.hash < b.hash ? -1 : +1;  // Group all the $refs that point to the same part of the file
            } else if (a.circular !== b.circular) {
              return a.circular ? -1 : +1;  // If the $ref points to itself, then sort it higher than other $refs that point to this $ref
            } else if (a.extended !== b.extended) {
              return a.extended ? +1 : -1;  // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value
            } else if (a.depth !== b.depth) {
              return a.depth - b.depth;  // Sort $refs by how close they are to the JSON Schema root
            } else {
              // If all else is equal, use the $ref that's in the "definitions" property
              return b.pathFromRoot.lastIndexOf('/definitions') - a.pathFromRoot.lastIndexOf('/definitions');
            }
          });
          var file, hash, pathFromRoot;
          inventory.forEach(function (i) {
            debug('Re-mapping $ref pointer "%s" at %s', i.$ref.$ref, i.pathFromRoot);
            if (!i.external) {
              // This $ref already resolves to the main JSON Schema file
              i.$ref.$ref = i.hash;
            } else if (i.file === file && i.hash === hash) {
              // This $ref points to the same value as the prevous $ref, so remap it to the same path
              i.$ref.$ref = pathFromRoot;
            } else if (i.file === file && i.hash.indexOf(hash + '/') === 0) {
              // This $ref points to the a sub-value as the prevous $ref, so remap it beneath that path
              i.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(i.hash));
            } else {
              // We've moved to a new file or new hash
              file = i.file;
              hash = i.hash;
              pathFromRoot = i.pathFromRoot;
              // This is the first $ref to point to this value, so dereference the value.
              // Any other $refs that point to the same value will point to this $ref instead
              i.$ref = i.parent[i.key] = $Ref.dereference(i.$ref, i.value);
              if (i.circular) {
                // This $ref points to itself
                i.$ref.$ref = i.pathFromRoot;
              }
            }
            debug('    new value: %s', i.$ref && i.$ref.$ref ? i.$ref.$ref : '[object Object]');
          });
        }
      },
      {
        './pointer': 96,
        './ref': 97,
        './util/debug': 102,
        './util/url': 105
      }
    ],
    88: [
      function (require, module, exports) {
        'use strict';
        var $Ref = require('./ref'), Pointer = require('./pointer'), ono = require('ono'), debug = require('./util/debug'), url = require('./util/url');
        module.exports = dereference;
        /**
 * Crawls the JSON schema, finds all JSON references, and dereferences them.
 * This method mutates the JSON schema object, replacing JSON references with their resolved value.
 *
 * @param {$RefParser} parser
 * @param {$RefParserOptions} options
 */
        function dereference(parser, options) {
          debug('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);
          var dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, '#', [], parser.$refs, options);
          parser.$refs.circular = dereferenced.circular;
          parser.schema = dereferenced.value;
        }
        /**
 * Recursively crawls the given value, and dereferences any JSON references.
 *
 * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
 * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of `obj` from the schema root
 * @param {object[]} parents - An array of the parent objects that have already been dereferenced
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 * @returns {{value: object, circular: boolean}}
 */
        function crawl(obj, path, pathFromRoot, parents, $refs, options) {
          var dereferenced;
          var result = {
              value: obj,
              circular: false
            };
          if (obj && typeof obj === 'object') {
            parents.push(obj);
            if ($Ref.isAllowed$Ref(obj, options)) {
              dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, $refs, options);
              result.circular = dereferenced.circular;
              result.value = dereferenced.value;
            } else {
              Object.keys(obj).forEach(function (key) {
                var keyPath = Pointer.join(path, key);
                var keyPathFromRoot = Pointer.join(pathFromRoot, key);
                var value = obj[key];
                var circular = false;
                if ($Ref.isAllowed$Ref(value, options)) {
                  dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, $refs, options);
                  circular = dereferenced.circular;
                  obj[key] = dereferenced.value;
                } else {
                  if (parents.indexOf(value) === -1) {
                    dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, $refs, options);
                    circular = dereferenced.circular;
                    obj[key] = dereferenced.value;
                  } else {
                    circular = foundCircularReference(keyPath, $refs, options);
                  }
                }
                // Set the "isCircular" flag if this or any other property is circular
                result.circular = result.circular || circular;
              });
            }
            parents.pop();
          }
          return result;
        }
        /**
 * Dereferences the given JSON Reference, and then crawls the resulting value.
 *
 * @param {{$ref: string}} $ref - The JSON Reference to resolve
 * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of `$ref` from the schema root
 * @param {object[]} parents - An array of the parent objects that have already been dereferenced
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 * @returns {{value: object, circular: boolean}}
 */
        function dereference$Ref($ref, path, pathFromRoot, parents, $refs, options) {
          debug('Dereferencing $ref pointer "%s" at %s', $ref.$ref, path);
          var $refPath = url.resolve(path, $ref.$ref);
          var pointer = $refs._resolve($refPath, options);
          // Check for circular references
          var directCircular = pointer.circular;
          var circular = directCircular || parents.indexOf(pointer.value) !== -1;
          circular && foundCircularReference(path, $refs, options);
          // Dereference the JSON reference
          var dereferencedValue = $Ref.dereference($ref, pointer.value);
          // Crawl the dereferenced value (unless it's circular)
          if (!circular) {
            // Determine if the dereferenced value is circular
            var dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, $refs, options);
            circular = dereferenced.circular;
            dereferencedValue = dereferenced.value;
          }
          if (circular && !directCircular && options.dereference.circular === 'ignore') {
            // The user has chosen to "ignore" circular references, so don't change the value
            dereferencedValue = $ref;
          }
          if (directCircular) {
            // The pointer is a DIRECT circular reference (i.e. it references itself).
            // So replace the $ref path with the absolute path from the JSON Schema root
            dereferencedValue.$ref = pathFromRoot;
          }
          return {
            circular: circular,
            value: dereferencedValue
          };
        }
        /**
 * Called when a circular reference is found.
 * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.
 *
 * @param {string} keyPath - The JSON Reference path of the circular reference
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 * @returns {boolean} - always returns true, to indicate that a circular reference was found
 */
        function foundCircularReference(keyPath, $refs, options) {
          $refs.circular = true;
          if (!options.dereference.circular) {
            throw ono.reference('Circular $ref pointer found at %s', keyPath);
          }
          return true;
        }
      },
      {
        './pointer': 96,
        './ref': 97,
        './util/debug': 102,
        './util/url': 105,
        'ono': 113
      }
    ],
    89: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var Promise = require('./util/promise'), Options = require('./options'), $Refs = require('./refs'), parse = require('./parse'), resolveExternal = require('./resolve-external'), bundle = require('./bundle'), dereference = require('./dereference'), url = require('./util/url'), maybe = require('call-me-maybe'), ono = require('ono');
          module.exports = $RefParser;
          module.exports.YAML = require('./util/yaml');
          /**
 * This class parses a JSON schema, builds a map of its JSON references and their resolved values,
 * and provides methods for traversing, manipulating, and dereferencing those references.
 *
 * @constructor
 */
          function $RefParser() {
            /**
   * The parsed (and possibly dereferenced) JSON schema object
   *
   * @type {object}
   * @readonly
   */
            this.schema = null;
            /**
   * The resolved JSON references
   *
   * @type {$Refs}
   * @readonly
   */
            this.$refs = new $Refs();
          }
          /**
 * Parses the given JSON schema.
 * This method does not resolve any JSON references.
 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
 * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
 */
          $RefParser.parse = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.parse.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema.
 * This method does not resolve any JSON references.
 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
 * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
 */
          $RefParser.prototype.parse = function (schema, options, callback) {
            var args = normalizeArgs(arguments);
            var promise;
            if (!args.path && !args.schema) {
              var err = ono('Expected a file path, URL, or object. Got %s', args.path || args.schema);
              return maybe(args.callback, Promise.reject(err));
            }
            // Reset everything
            this.schema = null;
            this.$refs = new $Refs();
            // If the path is a filesystem path, then convert it to a URL.
            // NOTE: According to the JSON Reference spec, these should already be URLs,
            // but, in practice, many people use local filesystem paths instead.
            // So we're being generous here and doing the conversion automatically.
            // This is not intended to be a 100% bulletproof solution.
            // If it doesn't work for your use-case, then use a URL instead.
            if (url.isFileSystemPath(args.path)) {
              args.path = url.fromFileSystemPath(args.path);
            }
            // Resolve the absolute path of the schema
            args.path = url.resolve(url.cwd(), args.path);
            if (args.schema && typeof args.schema === 'object') {
              // A schema object was passed-in.
              // So immediately add a new $Ref with the schema object as its value
              this.$refs._add(args.path, args.schema);
              promise = Promise.resolve(args.schema);
            } else {
              // Parse the schema file/url
              promise = parse(args.path, this.$refs, args.options);
            }
            var me = this;
            return promise.then(function (result) {
              if (!result || typeof result !== 'object' || Buffer.isBuffer(result)) {
                throw ono.syntax('"%s" is not a valid JSON Schema', me.$refs._root$Ref.path || result);
              } else {
                me.schema = result;
                return maybe(args.callback, Promise.resolve(me.schema));
              }
            }).catch(function (e) {
              return maybe(args.callback, Promise.reject(e));
            });
          };
          /**
 * Parses the given JSON schema and resolves any JSON references, including references in
 * externally-referenced files.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
 * @param {function} [callback]
 * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
 *
 * @returns {Promise}
 * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
 */
          $RefParser.resolve = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.resolve.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema and resolves any JSON references, including references in
 * externally-referenced files.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
 * @param {function} [callback]
 * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
 *
 * @returns {Promise}
 * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
 */
          $RefParser.prototype.resolve = function (schema, options, callback) {
            var me = this;
            var args = normalizeArgs(arguments);
            return this.parse(args.path, args.schema, args.options).then(function () {
              return resolveExternal(me, args.options);
            }).then(function () {
              return maybe(args.callback, Promise.resolve(me.$refs));
            }).catch(function (err) {
              return maybe(args.callback, Promise.reject(err));
            });
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and bundles all external references
 * into the main JSON schema. This produces a JSON schema that only has *internal* references,
 * not any *external* references.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
 * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
 */
          $RefParser.bundle = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.bundle.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and bundles all external references
 * into the main JSON schema. This produces a JSON schema that only has *internal* references,
 * not any *external* references.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
 * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
 */
          $RefParser.prototype.bundle = function (schema, options, callback) {
            var me = this;
            var args = normalizeArgs(arguments);
            return this.resolve(args.path, args.schema, args.options).then(function () {
              bundle(me, args.options);
              return maybe(args.callback, Promise.resolve(me.schema));
            }).catch(function (err) {
              return maybe(args.callback, Promise.reject(err));
            });
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
 * That is, all JSON references are replaced with their resolved values.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
 * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
 */
          $RefParser.dereference = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.dereference.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
 * That is, all JSON references are replaced with their resolved values.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
 * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
 */
          $RefParser.prototype.dereference = function (schema, options, callback) {
            var me = this;
            var args = normalizeArgs(arguments);
            return this.resolve(args.path, args.schema, args.options).then(function () {
              dereference(me, args.options);
              return maybe(args.callback, Promise.resolve(me.schema));
            }).catch(function (err) {
              return maybe(args.callback, Promise.reject(err));
            });
          };
          /**
 * Normalizes the given arguments, accounting for optional args.
 *
 * @param {Arguments} args
 * @returns {object}
 */
          function normalizeArgs(args) {
            var path, schema, options, callback;
            args = Array.prototype.slice.call(args);
            if (typeof args[args.length - 1] === 'function') {
              // The last parameter is a callback function
              callback = args.pop();
            }
            if (typeof args[0] === 'string') {
              // The first parameter is the path
              path = args[0];
              if (typeof args[2] === 'object') {
                // The second parameter is the schema, and the third parameter is the options
                schema = args[1];
                options = args[2];
              } else {
                // The second parameter is the options
                schema = undefined;
                options = args[1];
              }
            } else {
              // The first parameter is the schema
              path = '';
              schema = args[0];
              options = args[1];
            }
            if (!(options instanceof Options)) {
              options = new Options(options);
            }
            return {
              path: path,
              schema: schema,
              options: options,
              callback: callback
            };
          }
        }.call(this, { 'isBuffer': require('../../is-buffer/index.js') }));
      },
      {
        '../../is-buffer/index.js': 55,
        './bundle': 87,
        './dereference': 88,
        './options': 90,
        './parse': 91,
        './refs': 98,
        './resolve-external': 99,
        './util/promise': 104,
        './util/url': 105,
        './util/yaml': 106,
        'call-me-maybe': 44,
        'ono': 113
      }
    ],
    90: [
      function (require, module, exports) {
        /* eslint lines-around-comment: [2, {beforeBlockComment: false}] */
        'use strict';
        var jsonParser = require('./parsers/json'), yamlParser = require('./parsers/yaml'), textParser = require('./parsers/text'), binaryParser = require('./parsers/binary'), fileResolver = require('./resolvers/file'), httpResolver = require('./resolvers/http'), zschemaValidator = require('./validators/z-schema');
        module.exports = $RefParserOptions;
        /**
 * Options that determine how JSON schemas are parsed, resolved, dereferenced, and validated.
 *
 * @param {object|$RefParserOptions} [options] - Overridden options
 * @constructor
 */
        function $RefParserOptions(options) {
          merge(this, $RefParserOptions.defaults);
          merge(this, options);
        }
        $RefParserOptions.defaults = {
          parse: {
            json: jsonParser,
            yaml: yamlParser,
            text: textParser,
            binary: binaryParser
          },
          resolve: {
            file: fileResolver,
            http: httpResolver,
            external: true
          },
          dereference: { circular: true },
          validate: { zschema: zschemaValidator }
        };
        /**
 * Merges the properties of the source object into the target object.
 *
 * @param {object} target - The object that we're populating
 * @param {?object} source - The options that are being merged
 * @returns {object}
 */
        function merge(target, source) {
          if (isMergeable(source)) {
            var keys = Object.keys(source);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              var sourceSetting = source[key];
              var targetSetting = target[key];
              if (isMergeable(sourceSetting)) {
                // It's a nested object, so merge it recursively
                target[key] = merge(targetSetting || {}, sourceSetting);
              } else if (sourceSetting !== undefined) {
                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.
                target[key] = sourceSetting;
              }
            }
          }
          return target;
        }
        /**
 * Determines whether the given value can be merged,
 * or if it is a scalar value that should just override the target value.
 *
 * @param   {*}  val
 * @returns {Boolean}
 */
        function isMergeable(val) {
          return val && typeof val === 'object' && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);
        }
      },
      {
        './parsers/binary': 92,
        './parsers/json': 93,
        './parsers/text': 94,
        './parsers/yaml': 95,
        './resolvers/file': 100,
        './resolvers/http': 101,
        './validators/z-schema': 107
      }
    ],
    91: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var ono = require('ono'), debug = require('./util/debug'), url = require('./util/url'), plugins = require('./util/plugins'), Promise = require('./util/promise');
          module.exports = parse;
          /**
 * Reads and parses the specified file path or URL.
 *
 * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.
 */
          function parse(path, $refs, options) {
            try {
              // Remove the URL fragment, if any
              path = url.stripHash(path);
              // Add a new $Ref for this file, even though we don't have the value yet.
              // This ensures that we don't simultaneously read & parse the same file multiple times
              var $ref = $refs._add(path);
              // This "file object" will be passed to all resolvers and parsers.
              var file = {
                  url: path,
                  extension: url.getExtension(path)
                };
              // Read the file and then parse the data
              return readFile(file, options).then(function (resolver) {
                $ref.pathType = resolver.plugin.name;
                file.data = resolver.result;
                return parseFile(file, options);
              }).then(function (parser) {
                $ref.value = parser.result;
                return parser.result;
              });
            } catch (e) {
              return Promise.reject(e);
            }
          }
          /**
 * Reads the given file, using the configured resolver plugins
 *
 * @param {object} file           - An object containing information about the referenced file
 * @param {string} file.url       - The full URL of the referenced file
 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves with the raw file contents and the resolver that was used.
 */
          function readFile(file, options) {
            return new Promise(function (resolve, reject) {
              debug('Reading %s', file.url);
              // Find the resolvers that can read this file
              var resolvers = plugins.all(options.resolve);
              resolvers = plugins.filter(resolvers, 'canRead', file);
              // Run the resolvers, in order, until one of them succeeds
              plugins.sort(resolvers);
              plugins.run(resolvers, 'read', file).then(resolve, onError);
              function onError(err) {
                // Throw the original error, if it's one of our own (user-friendly) errors.
                // Otherwise, throw a generic, friendly error.
                if (err && !(err instanceof SyntaxError)) {
                  reject(err);
                } else {
                  reject(ono.syntax('Unable to resolve $ref pointer "%s"', file.url));
                }
              }
            });
          }
          /**
 * Parses the given file's contents, using the configured parser plugins.
 *
 * @param {object} file           - An object containing information about the referenced file
 * @param {string} file.url       - The full URL of the referenced file
 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves with the parsed file contents and the parser that was used.
 */
          function parseFile(file, options) {
            return new Promise(function (resolve, reject) {
              debug('Parsing %s', file.url);
              // Find the parsers that can read this file type.
              // If none of the parsers are an exact match for this file, then we'll try ALL of them.
              // This handles situations where the file IS a supported type, just with an unknown extension.
              var allParsers = plugins.all(options.parse);
              var filteredParsers = plugins.filter(allParsers, 'canParse', file);
              var parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;
              // Run the parsers, in order, until one of them succeeds
              plugins.sort(parsers);
              plugins.run(parsers, 'parse', file).then(onParsed, onError);
              function onParsed(parser) {
                if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
                  reject(ono.syntax('Error parsing "%s" as %s. \nParsed value is empty', file.url, parser.plugin.name));
                } else {
                  resolve(parser);
                }
              }
              function onError(err) {
                if (err) {
                  err = err instanceof Error ? err : new Error(err);
                  reject(ono.syntax(err, 'Error parsing %s', file.url));
                } else {
                  reject(ono.syntax('Unable to parse %s', file.url));
                }
              }
            });
          }
          /**
 * Determines whether the parsed value is "empty".
 *
 * @param {*} value
 * @returns {boolean}
 */
          function isEmpty(value) {
            return value === undefined || typeof value === 'object' && Object.keys(value).length === 0 || typeof value === 'string' && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;
          }
        }.call(this, { 'isBuffer': require('../../is-buffer/index.js') }));
      },
      {
        '../../is-buffer/index.js': 55,
        './util/debug': 102,
        './util/plugins': 103,
        './util/promise': 104,
        './util/url': 105,
        'ono': 113
      }
    ],
    92: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
          module.exports = {
            order: 400,
            allowEmpty: true,
            canParse: function isBinary(file) {
              // Use this parser if the file is a Buffer, and has a known binary extension
              return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
            },
            parse: function parseBinary(file) {
              if (Buffer.isBuffer(file.data)) {
                return file.data;
              } else {
                // This will reject if data is anything other than a string or typed array
                return new Buffer(file.data);
              }
            }
          };
        }.call(this, require('buffer').Buffer));
      },
      { 'buffer': 41 }
    ],
    93: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var Promise = require('../util/promise');
          module.exports = {
            order: 100,
            allowEmpty: true,
            canParse: '.json',
            parse: function parseJSON(file) {
              return new Promise(function (resolve, reject) {
                var data = file.data;
                if (Buffer.isBuffer(data)) {
                  data = data.toString();
                }
                if (typeof data === 'string') {
                  if (data.trim().length === 0) {
                    resolve(undefined);  // This mirrors the YAML behavior
                  } else {
                    resolve(JSON.parse(data));
                  }
                } else {
                  // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                  resolve(data);
                }
              });
            }
          };
        }.call(this, { 'isBuffer': require('../../../is-buffer/index.js') }));
      },
      {
        '../../../is-buffer/index.js': 55,
        '../util/promise': 104
      }
    ],
    94: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
          module.exports = {
            order: 300,
            allowEmpty: true,
            encoding: 'utf8',
            canParse: function isText(file) {
              // Use this parser if the file is a string or Buffer, and has a known text-based extension
              return (typeof file.data === 'string' || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
            },
            parse: function parseText(file) {
              if (typeof file.data === 'string') {
                return file.data;
              } else if (Buffer.isBuffer(file.data)) {
                return file.data.toString(this.encoding);
              } else {
                throw new Error('data is not text');
              }
            }
          };
        }.call(this, { 'isBuffer': require('../../../is-buffer/index.js') }));
      },
      { '../../../is-buffer/index.js': 55 }
    ],
    95: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var Promise = require('../util/promise'), YAML = require('../util/yaml');
          module.exports = {
            order: 200,
            allowEmpty: true,
            canParse: [
              '.yaml',
              '.yml',
              '.json'
            ],
            parse: function parseYAML(file) {
              return new Promise(function (resolve, reject) {
                var data = file.data;
                if (Buffer.isBuffer(data)) {
                  data = data.toString();
                }
                if (typeof data === 'string') {
                  resolve(YAML.parse(data));
                } else {
                  // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                  resolve(data);
                }
              });
            }
          };
        }.call(this, { 'isBuffer': require('../../../is-buffer/index.js') }));
      },
      {
        '../../../is-buffer/index.js': 55,
        '../util/promise': 104,
        '../util/yaml': 106
      }
    ],
    96: [
      function (require, module, exports) {
        'use strict';
        module.exports = Pointer;
        var $Ref = require('./ref'), url = require('./util/url'), ono = require('ono'), slashes = /\//g, tildes = /~/g, escapedSlash = /~1/g, escapedTilde = /~0/g;
        /**
 * This class represents a single JSON pointer and its resolved value.
 *
 * @param {$Ref} $ref
 * @param {string} path
 * @constructor
 */
        function Pointer($ref, path) {
          /**
   * The {@link $Ref} object that contains this {@link Pointer} object.
   * @type {$Ref}
   */
          this.$ref = $ref;
          /**
   * The file path or URL, containing the JSON pointer in the hash.
   * This path is relative to the path of the main JSON schema file.
   * @type {string}
   */
          this.path = path;
          /**
   * The value of the JSON pointer.
   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
   * @type {?*}
   */
          this.value = undefined;
          /**
   * Indicates whether the pointer references itself.
   * @type {boolean}
   */
          this.circular = false;
        }
        /**
 * Resolves the value of a nested property within the given object.
 *
 * @param {*} obj - The object that will be crawled
 * @param {$RefParserOptions} options
 *
 * @returns {Pointer}
 * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.
 * If resolving this value required resolving other JSON references, then
 * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path
 * of the resolved value.
 */
        Pointer.prototype.resolve = function (obj, options) {
          var tokens = Pointer.parse(this.path);
          // Crawl the object, one token at a time
          this.value = obj;
          for (var i = 0; i < tokens.length; i++) {
            if (resolveIf$Ref(this, options)) {
              // The $ref path has changed, so append the remaining tokens to the path
              this.path = Pointer.join(this.path, tokens.slice(i));
            }
            var token = tokens[i];
            if (this.value[token] === undefined) {
              throw ono.syntax('Error resolving $ref pointer "%s". \nToken "%s" does not exist.', this.path, token);
            } else {
              this.value = this.value[token];
            }
          }
          // Resolve the final value
          resolveIf$Ref(this, options);
          return this;
        };
        /**
 * Sets the value of a nested property within the given object.
 *
 * @param {*} obj - The object that will be crawled
 * @param {*} value - the value to assign
 * @param {$RefParserOptions} options
 *
 * @returns {*}
 * Returns the modified object, or an entirely new object if the entire object is overwritten.
 */
        Pointer.prototype.set = function (obj, value, options) {
          var tokens = Pointer.parse(this.path);
          var token;
          if (tokens.length === 0) {
            // There are no tokens, replace the entire object with the new value
            this.value = value;
            return value;
          }
          // Crawl the object, one token at a time
          this.value = obj;
          for (var i = 0; i < tokens.length - 1; i++) {
            resolveIf$Ref(this, options);
            token = tokens[i];
            if (this.value && this.value[token] !== undefined) {
              // The token exists
              this.value = this.value[token];
            } else {
              // The token doesn't exist, so create it
              this.value = setValue(this, token, {});
            }
          }
          // Set the value of the final token
          resolveIf$Ref(this, options);
          token = tokens[tokens.length - 1];
          setValue(this, token, value);
          // Return the updated object
          return obj;
        };
        /**
 * Parses a JSON pointer (or a path containing a JSON pointer in the hash)
 * and returns an array of the pointer's tokens.
 * (e.g. "schema.json#/definitions/person/name" => ["definitions", "person", "name"])
 *
 * The pointer is parsed according to RFC 6901
 * {@link https://tools.ietf.org/html/rfc6901#section-3}
 *
 * @param {string} path
 * @returns {string[]}
 */
        Pointer.parse = function (path) {
          // Get the JSON pointer from the path's hash
          var pointer = url.getHash(path).substr(1);
          // If there's no pointer, then there are no tokens,
          // so return an empty array
          if (!pointer) {
            return [];
          }
          // Split into an array
          pointer = pointer.split('/');
          // Decode each part, according to RFC 6901
          for (var i = 0; i < pointer.length; i++) {
            pointer[i] = decodeURI(pointer[i].replace(escapedSlash, '/').replace(escapedTilde, '~'));
          }
          if (pointer[0] !== '') {
            throw ono.syntax('Invalid $ref pointer "%s". Pointers must begin with "#/"', pointer);
          }
          return pointer.slice(1);
        };
        /**
 * Creates a JSON pointer path, by joining one or more tokens to a base path.
 *
 * @param {string} base - The base path (e.g. "schema.json#/definitions/person")
 * @param {string|string[]} tokens - The token(s) to append (e.g. ["name", "first"])
 * @returns {string}
 */
        Pointer.join = function (base, tokens) {
          // Ensure that the base path contains a hash
          if (base.indexOf('#') === -1) {
            base += '#';
          }
          // Append each token to the base path
          tokens = Array.isArray(tokens) ? tokens : [tokens];
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            // Encode the token, according to RFC 6901
            base += '/' + encodeURI(token.replace(tildes, '~0').replace(slashes, '~1'));
          }
          return base;
        };
        /**
 * If the given pointer's {@link Pointer#value} is a JSON reference,
 * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.
 * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the
 * resolution path of the new value.
 *
 * @param {Pointer} pointer
 * @param {$RefParserOptions} options
 * @returns {boolean} - Returns `true` if the resolution path changed
 */
        function resolveIf$Ref(pointer, options) {
          // Is the value a JSON reference? (and allowed?)
          if ($Ref.isAllowed$Ref(pointer.value, options)) {
            var $refPath = url.resolve(pointer.path, pointer.value.$ref);
            if ($refPath === pointer.path) {
              // The value is a reference to itself, so there's nothing to do.
              pointer.circular = true;
            } else {
              var resolved = pointer.$ref.$refs._resolve($refPath, options);
              if ($Ref.isExtended$Ref(pointer.value)) {
                // This JSON reference "extends" the resolved value, rather than simply pointing to it.
                // So the resolved path does NOT change.  Just the value does.
                pointer.value = $Ref.dereference(pointer.value, resolved.value);
              } else {
                // Resolve the reference
                pointer.$ref = resolved.$ref;
                pointer.path = resolved.path;
                pointer.value = resolved.value;
              }
              return true;
            }
          }
        }
        /**
 * Sets the specified token value of the {@link Pointer#value}.
 *
 * The token is evaluated according to RFC 6901.
 * {@link https://tools.ietf.org/html/rfc6901#section-4}
 *
 * @param {Pointer} pointer - The JSON Pointer whose value will be modified
 * @param {string} token - A JSON Pointer token that indicates how to modify `obj`
 * @param {*} value - The value to assign
 * @returns {*} - Returns the assigned value
 */
        function setValue(pointer, token, value) {
          if (pointer.value && typeof pointer.value === 'object') {
            if (token === '-' && Array.isArray(pointer.value)) {
              pointer.value.push(value);
            } else {
              pointer.value[token] = value;
            }
          } else {
            throw ono.syntax('Error assigning $ref pointer "%s". \nCannot set "%s" of a non-object.', pointer.path, token);
          }
          return value;
        }
      },
      {
        './ref': 97,
        './util/url': 105,
        'ono': 113
      }
    ],
    97: [
      function (require, module, exports) {
        'use strict';
        module.exports = $Ref;
        var Pointer = require('./pointer');
        /**
 * This class represents a single JSON reference and its resolved value.
 *
 * @constructor
 */
        function $Ref() {
          /**
   * The file path or URL of the referenced file.
   * This path is relative to the path of the main JSON schema file.
   *
   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.
   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get
   * specific JSON pointers within the file.
   *
   * @type {string}
   */
          this.path = undefined;
          /**
   * The resolved value of the JSON reference.
   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
   * @type {?*}
   */
          this.value = undefined;
          /**
   * The {@link $Refs} object that contains this {@link $Ref} object.
   * @type {$Refs}
   */
          this.$refs = undefined;
          /**
   * Indicates the type of {@link $Ref#path} (e.g. "file", "http", etc.)
   * @type {?string}
   */
          this.pathType = undefined;
        }
        /**
 * Determines whether the given JSON reference exists within this {@link $Ref#value}.
 *
 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} options
 * @returns {boolean}
 */
        $Ref.prototype.exists = function (path, options) {
          try {
            this.resolve(path, options);
            return true;
          } catch (e) {
            return false;
          }
        };
        /**
 * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.
 *
 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} options
 * @returns {*} - Returns the resolved value
 */
        $Ref.prototype.get = function (path, options) {
          return this.resolve(path, options).value;
        };
        /**
 * Resolves the given JSON reference within this {@link $Ref#value}.
 *
 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} options
 * @returns {Pointer}
 */
        $Ref.prototype.resolve = function (path, options) {
          var pointer = new Pointer(this, path);
          return pointer.resolve(this.value, options);
        };
        /**
 * Sets the value of a nested property within this {@link $Ref#value}.
 * If the property, or any of its parents don't exist, they will be created.
 *
 * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash
 * @param {*} value - The value to assign
 */
        $Ref.prototype.set = function (path, value) {
          var pointer = new Pointer(this, path);
          this.value = pointer.set(this.value, value);
        };
        /**
 * Determines whether the given value is a JSON reference.
 *
 * @param {*} value - The value to inspect
 * @returns {boolean}
 */
        $Ref.is$Ref = function (value) {
          return value && typeof value === 'object' && typeof value.$ref === 'string' && value.$ref.length > 0;
        };
        /**
 * Determines whether the given value is an external JSON reference.
 *
 * @param {*} value - The value to inspect
 * @returns {boolean}
 */
        $Ref.isExternal$Ref = function (value) {
          return $Ref.is$Ref(value) && value.$ref[0] !== '#';
        };
        /**
 * Determines whether the given value is a JSON reference, and whether it is allowed by the options.
 * For example, if it references an external file, then options.resolve.external must be true.
 *
 * @param {*} value - The value to inspect
 * @param {$RefParserOptions} options
 * @returns {boolean}
 */
        $Ref.isAllowed$Ref = function (value, options) {
          if ($Ref.is$Ref(value)) {
            if (value.$ref[0] === '#' || !options || options.resolve.external) {
              return true;
            }
          }
        };
        /**
 * Determines whether the given value is a JSON reference that "extends" its resolved value.
 * That is, it has extra properties (in addition to "$ref"), so rather than simply pointing to
 * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved
 * value, plus the extra properties.
 *
 * @example:
 *  {
 *    person: {
 *      properties: {
 *        firstName: { type: string }
 *        lastName: { type: string }
 *      }
 *    }
 *    employee: {
 *      properties: {
 *        $ref: #/person/properties
 *        salary: { type: number }
 *      }
 *    }
 *  }
 *
 *  In this example, "employee" is an extended $ref, since it extends "person" with an additional
 *  property (salary).  The result is a NEW value that looks like this:
 *
 *  {
 *    properties: {
 *      firstName: { type: string }
 *      lastName: { type: string }
 *      salary: { type: number }
 *    }
 *  }
 *
 * @param {*} value - The value to inspect
 * @returns {boolean}
 */
        $Ref.isExtended$Ref = function (value) {
          return $Ref.is$Ref(value) && Object.keys(value).length > 1;
        };
        /**
 * Returns the resolved value of a JSON Reference.
 * If necessary, the resolved value is merged with the JSON Reference to create a new object
 *
 * @example:
 *  {
 *    person: {
 *      properties: {
 *        firstName: { type: string }
 *        lastName: { type: string }
 *      }
 *    }
 *    employee: {
 *      properties: {
 *        $ref: #/person/properties
 *        salary: { type: number }
 *      }
 *    }
 *  }
 *
 *  When "person" and "employee" are merged, you end up with the following object:
 *
 *  {
 *    properties: {
 *      firstName: { type: string }
 *      lastName: { type: string }
 *      salary: { type: number }
 *    }
 *  }
 *
 * @param {object} $ref - The JSON reference object (the one with the "$ref" property)
 * @param {*} resolvedValue - The resolved value, which can be any type
 * @returns {*} - Returns the dereferenced value
 */
        $Ref.dereference = function ($ref, resolvedValue) {
          if (resolvedValue && typeof resolvedValue === 'object' && $Ref.isExtended$Ref($ref)) {
            var merged = {};
            Object.keys($ref).forEach(function (key) {
              if (key !== '$ref') {
                merged[key] = $ref[key];
              }
            });
            Object.keys(resolvedValue).forEach(function (key) {
              if (!(key in merged)) {
                merged[key] = resolvedValue[key];
              }
            });
            return merged;
          } else {
            // Completely replace the original reference with the resolved value
            return resolvedValue;
          }
        };
      },
      { './pointer': 96 }
    ],
    98: [
      function (require, module, exports) {
        'use strict';
        var ono = require('ono'), $Ref = require('./ref'), url = require('./util/url');
        module.exports = $Refs;
        /**
 * This class is a map of JSON references and their resolved values.
 */
        function $Refs() {
          /**
   * Indicates whether the schema contains any circular references.
   *
   * @type {boolean}
   */
          this.circular = false;
          /**
   * A map of paths/urls to {@link $Ref} objects
   *
   * @type {object}
   * @protected
   */
          this._$refs = {};
          /**
   * The {@link $Ref} object that is the root of the JSON schema.
   *
   * @type {$Ref}
   * @protected
   */
          this._root$Ref = null;
        }
        /**
 * Returns the paths of all the files/URLs that are referenced by the JSON schema,
 * including the schema itself.
 *
 * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
 * @returns {string[]}
 */
        $Refs.prototype.paths = function (types) {
          var paths = getPaths(this._$refs, arguments);
          return paths.map(function (path) {
            return path.decoded;
          });
        };
        /**
 * Returns the map of JSON references and their resolved values.
 *
 * @param {...string|string[]} [types] - Only return references of the given types ("file", "http", etc.)
 * @returns {object}
 */
        $Refs.prototype.values = function (types) {
          var $refs = this._$refs;
          var paths = getPaths($refs, arguments);
          return paths.reduce(function (obj, path) {
            obj[path.decoded] = $refs[path.encoded].value;
            return obj;
          }, {});
        };
        /**
 * Returns a POJO (plain old JavaScript object) for serialization as JSON.
 *
 * @returns {object}
 */
        $Refs.prototype.toJSON = $Refs.prototype.values;
        /**
 * Determines whether the given JSON reference exists.
 *
 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} [options]
 * @returns {boolean}
 */
        $Refs.prototype.exists = function (path, options) {
          try {
            this._resolve(path, options);
            return true;
          } catch (e) {
            return false;
          }
        };
        /**
 * Resolves the given JSON reference and returns the resolved value.
 *
 * @param {string} path - The path being resolved, with a JSON pointer in the hash
 * @param {$RefParserOptions} [options]
 * @returns {*} - Returns the resolved value
 */
        $Refs.prototype.get = function (path, options) {
          return this._resolve(path, options).value;
        };
        /**
 * Sets the value of a nested property within this {@link $Ref#value}.
 * If the property, or any of its parents don't exist, they will be created.
 *
 * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash
 * @param {*} value - The value to assign
 */
        $Refs.prototype.set = function (path, value) {
          path = url.resolve(this._root$Ref.path, path);
          var withoutHash = url.stripHash(path);
          var $ref = this._$refs[withoutHash];
          if (!$ref) {
            throw ono('Error resolving $ref pointer "%s". \n"%s" not found.', path, withoutHash);
          }
          $ref.set(path, value);
        };
        /**
 * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.
 *
 * @param {string} path  - The file path or URL of the referenced file
 * @param {*} [value] - Optional. The value of the $ref.
 */
        $Refs.prototype._add = function (path, value) {
          var withoutHash = url.stripHash(path);
          var $ref = new $Ref();
          $ref.path = withoutHash;
          $ref.value = value;
          $ref.$refs = this;
          this._$refs[withoutHash] = $ref;
          this._root$Ref = this._root$Ref || $ref;
          return $ref;
        };
        /**
 * Resolves the given JSON reference.
 *
 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} [options]
 * @returns {Pointer}
 * @protected
 */
        $Refs.prototype._resolve = function (path, options) {
          path = url.resolve(this._root$Ref.path, path);
          var withoutHash = url.stripHash(path);
          var $ref = this._$refs[withoutHash];
          if (!$ref) {
            throw ono('Error resolving $ref pointer "%s". \n"%s" not found.', path, withoutHash);
          }
          return $ref.resolve(path, options);
        };
        /**
 * Returns the specified {@link $Ref} object, or undefined.
 *
 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
 * @returns {$Ref|undefined}
 * @protected
 */
        $Refs.prototype._get$Ref = function (path) {
          path = url.resolve(this._root$Ref.path, path);
          var withoutHash = url.stripHash(path);
          return this._$refs[withoutHash];
        };
        /**
 * Returns the encoded and decoded paths keys of the given object.
 *
 * @param {object} $refs - The object whose keys are URL-encoded paths
 * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
 * @returns {object[]}
 */
        function getPaths($refs, types) {
          var paths = Object.keys($refs);
          // Filter the paths by type
          types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);
          if (types.length > 0 && types[0]) {
            paths = paths.filter(function (key) {
              return types.indexOf($refs[key].pathType) !== -1;
            });
          }
          // Decode local filesystem paths
          return paths.map(function (path) {
            return {
              encoded: path,
              decoded: $refs[path].pathType === 'file' ? url.toFileSystemPath(path, true) : path
            };
          });
        }
      },
      {
        './ref': 97,
        './util/url': 105,
        'ono': 113
      }
    ],
    99: [
      function (require, module, exports) {
        'use strict';
        var Promise = require('./util/promise'), $Ref = require('./ref'), Pointer = require('./pointer'), parse = require('./parse'), debug = require('./util/debug'), url = require('./util/url');
        module.exports = resolveExternal;
        /**
 * Crawls the JSON schema, finds all external JSON references, and resolves their values.
 * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.
 *
 * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.
 *
 * @param {$RefParser} parser
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves once all JSON references in the schema have been resolved,
 * including nested references that are contained in externally-referenced files.
 */
        function resolveExternal(parser, options) {
          if (!options.resolve.external) {
            // Nothing to resolve, so exit early
            return Promise.resolve();
          }
          try {
            debug('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);
            var promises = crawl(parser.schema, parser.$refs._root$Ref.path + '#', parser.$refs, options);
            return Promise.all(promises);
          } catch (e) {
            return Promise.reject(e);
          }
        }
        /**
 * Recursively crawls the given value, and resolves any external JSON references.
 *
 * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
 * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 *
 * @returns {Promise[]}
 * Returns an array of promises. There will be one promise for each JSON reference in `obj`.
 * If `obj` does not contain any JSON references, then the array will be empty.
 * If any of the JSON references point to files that contain additional JSON references,
 * then the corresponding promise will internally reference an array of promises.
 */
        function crawl(obj, path, $refs, options) {
          var promises = [];
          if (obj && typeof obj === 'object') {
            if ($Ref.isExternal$Ref(obj)) {
              promises.push(resolve$Ref(obj, path, $refs, options));
            } else {
              Object.keys(obj).forEach(function (key) {
                var keyPath = Pointer.join(path, key);
                var value = obj[key];
                if ($Ref.isExternal$Ref(value)) {
                  promises.push(resolve$Ref(value, keyPath, $refs, options));
                } else {
                  promises = promises.concat(crawl(value, keyPath, $refs, options));
                }
              });
            }
          }
          return promises;
        }
        /**
 * Resolves the given JSON Reference, and then crawls the resulting value.
 *
 * @param {{$ref: string}} $ref - The JSON Reference to resolve
 * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves once all JSON references in the object have been resolved,
 * including nested references that are contained in externally-referenced files.
 */
        function resolve$Ref($ref, path, $refs, options) {
          debug('Resolving $ref pointer "%s" at %s', $ref.$ref, path);
          var resolvedPath = url.resolve(path, $ref.$ref);
          var withoutHash = url.stripHash(resolvedPath);
          // Do we already have this $ref?
          $ref = $refs._$refs[withoutHash];
          if ($ref) {
            // We've already parsed this $ref, so use the existing value
            return Promise.resolve($ref.value);
          }
          // Parse the $referenced file/url
          return parse(resolvedPath, $refs, options).then(function (result) {
            // Crawl the parsed value
            debug('Resolving $ref pointers in %s', withoutHash);
            var promises = crawl(result, withoutHash + '#', $refs, options);
            return Promise.all(promises);
          });
        }
      },
      {
        './parse': 91,
        './pointer': 96,
        './ref': 97,
        './util/debug': 102,
        './util/promise': 104,
        './util/url': 105
      }
    ],
    100: [
      function (require, module, exports) {
        'use strict';
        var fs = require('fs'), ono = require('ono'), Promise = require('../util/promise'), url = require('../util/url'), debug = require('../util/debug');
        module.exports = {
          order: 100,
          canRead: function isFile(file) {
            return url.isFileSystemPath(file.url);
          },
          read: function readFile(file) {
            return new Promise(function (resolve, reject) {
              var path;
              try {
                path = url.toFileSystemPath(file.url);
              } catch (err) {
                reject(ono.uri(err, 'Malformed URI: %s', file.url));
              }
              debug('Opening file: %s', path);
              try {
                fs.readFile(path, function (err, data) {
                  if (err) {
                    reject(ono(err, 'Error opening file "%s"', path));
                  } else {
                    resolve(data);
                  }
                });
              } catch (err) {
                reject(ono(err, 'Error opening file "%s"', path));
              }
            });
          }
        };
      },
      {
        '../util/debug': 102,
        '../util/promise': 104,
        '../util/url': 105,
        'fs': 39,
        'ono': 113
      }
    ],
    101: [
      function (require, module, exports) {
        (function (process, Buffer) {
          'use strict';
          var http = require('http'), https = require('https'), ono = require('ono'), url = require('../util/url'), debug = require('../util/debug'), Promise = require('../util/promise');
          module.exports = {
            order: 200,
            headers: null,
            timeout: 5000,
            redirects: 5,
            withCredentials: false,
            canRead: function isHttp(file) {
              return url.isHttp(file.url);
            },
            read: function readHttp(file) {
              var u = url.parse(file.url);
              if (process.browser && !u.protocol) {
                // Use the protocol of the current page
                u.protocol = url.parse(location.href).protocol;
              }
              return download(u, this);
            }
          };
          /**
 * Downloads the given file.
 *
 * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)
 * @param {object} httpOptions  - The `options.resolve.http` object
 * @param {number} [redirects]  - The redirect URLs that have already been followed
 *
 * @returns {Promise<Buffer>}
 * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.
 */
          function download(u, httpOptions, redirects) {
            return new Promise(function (resolve, reject) {
              u = url.parse(u);
              redirects = redirects || [];
              redirects.push(u.href);
              get(u, httpOptions).then(function (res) {
                if (res.statusCode >= 400) {
                  throw ono({ status: res.statusCode }, 'HTTP ERROR %d', res.statusCode);
                } else if (res.statusCode >= 300) {
                  if (redirects.length > httpOptions.redirects) {
                    reject(ono({ status: res.statusCode }, 'Error downloading %s. \nToo many redirects: \n  %s', redirects[0], redirects.join(' \n  ')));
                  } else if (!res.headers.location) {
                    throw ono({ status: res.statusCode }, 'HTTP %d redirect with no location header', res.statusCode);
                  } else {
                    debug('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);
                    var redirectTo = url.resolve(u, res.headers.location);
                    download(redirectTo, httpOptions, redirects).then(resolve, reject);
                  }
                } else {
                  resolve(res.body || new Buffer(0));
                }
              }).catch(function (err) {
                reject(ono(err, 'Error downloading', u.href));
              });
            });
          }
          /**
 * Sends an HTTP GET request.
 *
 * @param {Url} u - A parsed {@link Url} object
 * @param {object} httpOptions - The `options.resolve.http` object
 *
 * @returns {Promise<Response>}
 * The promise resolves with the HTTP Response object.
 */
          function get(u, httpOptions) {
            return new Promise(function (resolve, reject) {
              debug('GET', u.href);
              var protocol = u.protocol === 'https:' ? https : http;
              var req = protocol.get({
                  hostname: u.hostname,
                  port: u.port,
                  path: u.path,
                  auth: u.auth,
                  headers: httpOptions.headers || {},
                  withCredentials: httpOptions.withCredentials
                });
              if (typeof req.setTimeout === 'function') {
                req.setTimeout(httpOptions.timeout);
              }
              req.on('timeout', function () {
                req.abort();
              });
              req.on('error', reject);
              req.once('response', function (res) {
                res.body = new Buffer(0);
                res.on('data', function (data) {
                  res.body = Buffer.concat([
                    res.body,
                    new Buffer(data)
                  ]);
                });
                res.on('error', reject);
                res.on('end', function () {
                  resolve(res);
                });
              });
            });
          }
        }.call(this, require('_process'), require('buffer').Buffer));
      },
      {
        '../util/debug': 102,
        '../util/promise': 104,
        '../util/url': 105,
        '_process': 115,
        'buffer': 41,
        'http': 133,
        'https': 51,
        'ono': 113
      }
    ],
    102: [
      function (require, module, exports) {
        'use strict';
        var debug = require('debug');
        /**
 * Writes messages to stdout.
 * Log messages are suppressed by default, but can be enabled by setting the DEBUG variable.
 * @type {function}
 */
        module.exports = debug('json-schema-ref-parser');
      },
      { 'debug': 46 }
    ],
    103: [
      function (require, module, exports) {
        'use strict';
        var Promise = require('./promise'), debug = require('./debug');
        /**
 * Returns the given plugins as an array, rather than an object map.
 * All other methods in this module expect an array of plugins rather than an object map.
 *
 * @param  {object} plugins - A map of plugin objects
 * @return {object[]}
 */
        exports.all = function (plugins) {
          return Object.keys(plugins).filter(function (key) {
            return typeof plugins[key] === 'object';
          }).map(function (key) {
            plugins[key].name = key;
            return plugins[key];
          });
        };
        /**
 * Filters the given plugins, returning only the ones return `true` for the given method.
 *
 * @param  {object[]} plugins - An array of plugin objects
 * @param  {string}   method  - The name of the filter method to invoke for each plugin
 * @param  {object}   file    - A file info object, which will be passed to each method
 * @return {object[]}
 */
        exports.filter = function (plugins, method, file) {
          return plugins.filter(function (plugin) {
            return !!getResult(plugin, method, file);
          });
        };
        /**
 * Sorts the given plugins, in place, by their `order` property.
 *
 * @param {object[]} plugins - An array of plugin objects
 * @returns {object[]}
 */
        exports.sort = function (plugins) {
          plugins.forEach(function (plugin) {
            plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
          });
          return plugins.sort(function (a, b) {
            return a.order - b.order;
          });
        };
        /**
 * Runs the specified method of the given plugins, in order, until one of them returns a successful result.
 * Each method can return a synchronous value, a Promise, or call an error-first callback.
 * If the promise resolves successfully, or the callback is called without an error, then the result
 * is immediately returned and no further plugins are called.
 * If the promise rejects, or the callback is called with an error, then the next plugin is called.
 * If ALL plugins fail, then the last error is thrown.
 *
 * @param {object[]}  plugins - An array of plugin objects
 * @param {string}    method  - The name of the method to invoke for each plugin
 * @param {object}    file    - A file info object, which will be passed to each method
 * @returns {Promise}
 */
        exports.run = function (plugins, method, file) {
          var plugin, lastError, index = 0;
          return new Promise(function (resolve, reject) {
            runNextPlugin();
            function runNextPlugin() {
              plugin = plugins[index++];
              if (!plugin) {
                // There are no more functions, so re-throw the last error
                return reject(lastError);
              }
              try {
                debug('  %s', plugin.name);
                var result = getResult(plugin, method, file, callback);
                if (result && typeof result.then === 'function') {
                  // A promise was returned
                  result.then(onSuccess, onError);
                } else if (result !== undefined) {
                  // A synchronous result was returned
                  onSuccess(result);
                }  // else { the callback will be called }
              } catch (e) {
                onError(e);
              }
            }
            function callback(err, result) {
              if (err) {
                onError(err);
              } else {
                onSuccess(result);
              }
            }
            function onSuccess(result) {
              debug('    success');
              resolve({
                plugin: plugin,
                result: result
              });
            }
            function onError(err) {
              debug('    %s', err.message || err);
              lastError = err;
              runNextPlugin();
            }
          });
        };
        /**
 * Returns the value of the given property.
 * If the property is a function, then the result of the function is returned.
 * If the value is a RegExp, then it will be tested against the file URL.
 * If the value is an aray, then it will be compared against the file extension.
 *
 * @param   {object}   obj        - The object whose property/method is called
 * @param   {string}   prop       - The name of the property/method to invoke
 * @param   {object}   file       - A file info object, which will be passed to the method
 * @param   {function} [callback] - A callback function, which will be passed to the method
 * @returns {*}
 */
        function getResult(obj, prop, file, callback) {
          var value = obj[prop];
          if (typeof value === 'function') {
            return value.apply(obj, [
              file,
              callback
            ]);
          }
          if (!callback) {
            // The synchronous plugin functions (canParse and canRead)
            // allow a "shorthand" syntax, where the user can match
            // files by RegExp or by file extension.
            if (value instanceof RegExp) {
              return value.test(file.url);
            } else if (typeof value === 'string') {
              return value === file.extension;
            } else if (Array.isArray(value)) {
              return value.indexOf(file.extension) !== -1;
            }
          }
          return value;
        }
      },
      {
        './debug': 102,
        './promise': 104
      }
    ],
    104: [
      function (require, module, exports) {
        'use strict';
        /** @type {Promise} **/
        module.exports = typeof Promise === 'function' ? Promise : require('es6-promise').Promise;
      },
      { 'es6-promise': 48 }
    ],
    105: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          var isWindows = /^win/.test(process.platform), forwardSlashPattern = /\//g, protocolPattern = /^([a-z0-9.+-]+):\/\//i, url = module.exports;
          // RegExp patterns to URL-encode special characters in local filesystem paths
          var urlEncodePatterns = [
              /\?/g,
              '%3F',
              /\#/g,
              '%23',
              isWindows ? /\\/g : /\//,
              '/'
            ];
          // RegExp patterns to URL-decode special characters for local filesystem paths
          var urlDecodePatterns = [
              /\%23/g,
              '#',
              /\%24/g,
              '$',
              /\%26/g,
              '&',
              /\%2C/g,
              ',',
              /\%40/g,
              '@'
            ];
          exports.parse = require('url').parse;
          exports.resolve = require('url').resolve;
          /**
 * Returns the current working directory (in Node) or the current page URL (in browsers).
 *
 * @returns {string}
 */
          exports.cwd = function cwd() {
            return process.browser ? location.href : process.cwd() + '/';
          };
          /**
 * Returns the protocol of the given URL, or `undefined` if it has no protocol.
 *
 * @param   {string} path
 * @returns {?string}
 */
          exports.getProtocol = function getProtocol(path) {
            var match = protocolPattern.exec(path);
            if (match) {
              return match[1].toLowerCase();
            }
          };
          /**
 * Returns the lowercased file extension of the given URL,
 * or an empty string if it has no extension.
 *
 * @param   {string} path
 * @returns {string}
 */
          exports.getExtension = function getExtension(path) {
            var lastDot = path.lastIndexOf('.');
            if (lastDot >= 0) {
              return path.substr(lastDot).toLowerCase();
            }
            return '';
          };
          /**
 * Returns the hash (URL fragment), of the given path.
 * If there is no hash, then the root hash ("#") is returned.
 *
 * @param   {string} path
 * @returns {string}
 */
          exports.getHash = function getHash(path) {
            var hashIndex = path.indexOf('#');
            if (hashIndex >= 0) {
              return path.substr(hashIndex);
            }
            return '#';
          };
          /**
 * Removes the hash (URL fragment), if any, from the given path.
 *
 * @param   {string} path
 * @returns {string}
 */
          exports.stripHash = function stripHash(path) {
            var hashIndex = path.indexOf('#');
            if (hashIndex >= 0) {
              path = path.substr(0, hashIndex);
            }
            return path;
          };
          /**
 * Determines whether the given path is an HTTP(S) URL.
 *
 * @param   {string} path
 * @returns {boolean}
 */
          exports.isHttp = function isHttp(path) {
            var protocol = url.getProtocol(path);
            if (protocol === 'http' || protocol === 'https') {
              return true;
            } else if (protocol === undefined) {
              // There is no protocol.  If we're running in a browser, then assume it's HTTP.
              return process.browser;
            } else {
              // It's some other protocol, such as "ftp://", "mongodb://", etc.
              return false;
            }
          };
          /**
 * Determines whether the given path is a filesystem path.
 * This includes "file://" URLs.
 *
 * @param   {string} path
 * @returns {boolean}
 */
          exports.isFileSystemPath = function isFileSystemPath(path) {
            if (process.browser) {
              // We're running in a browser, so assume that all paths are URLs.
              // This way, even relative paths will be treated as URLs rather than as filesystem paths
              return false;
            }
            var protocol = url.getProtocol(path);
            return protocol === undefined || protocol === 'file';
          };
          /**
 * Converts a filesystem path to a properly-encoded URL.
 *
 * This is intended to handle situations where JSON Schema $Ref Parser is called
 * with a filesystem path that contains characters which are not allowed in URLs.
 *
 * @example
 * The following filesystem paths would be converted to the following URLs:
 *
 *    <"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\'%3E.json
 *    C:\\My Documents\\File (1).json   ==>   C:/My%20Documents/File%20(1).json
 *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json
 *
 * @param {string} path
 * @returns {string}
 */
          exports.fromFileSystemPath = function fromFileSystemPath(path) {
            // Step 1: Manually encode characters that are not encoded by `encodeURI`.
            // This includes characters such as "#" and "?", which have special meaning in URLs,
            // but are just normal characters in a filesystem path.
            // On Windows, this will also replace backslashes with forward slashes,
            // rather than encoding them as special characters.
            for (var i = 0; i < urlEncodePatterns.length; i += 2) {
              path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);
            }
            // Step 2: `encodeURI` will take care of all other characters
            return encodeURI(path);
          };
          /**
 * Converts a URL to a local filesystem path.
 *
 * @param {string}  path
 * @param {boolean} [keepFileProtocol] - If true, then "file://" will NOT be stripped
 * @returns {string}
 */
          exports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {
            // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.
            path = decodeURI(path);
            // Step 2: Manually decode characters that are not decoded by `decodeURI`.
            // This includes characters such as "#" and "?", which have special meaning in URLs,
            // but are just normal characters in a filesystem path.
            for (var i = 0; i < urlDecodePatterns.length; i += 2) {
              path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);
            }
            // Step 3: If it's a "file://" URL, then format it consistently
            // or convert it to a local filesystem path
            var isFileUrl = path.substr(0, 7).toLowerCase() === 'file://';
            if (isFileUrl) {
              // Strip-off the protocol, and the initial "/", if there is one
              path = path[7] === '/' ? path.substr(8) : path.substr(7);
              // insert a colon (":") after the drive letter on Windows
              if (isWindows && path[1] === '/') {
                path = path[0] + ':' + path.substr(1);
              }
              if (keepFileProtocol) {
                // Return the consistently-formatted "file://" URL
                path = 'file:///' + path;
              } else {
                // Convert the "file://" URL to a local filesystem path.
                // On Windows, it will start with something like "C:/".
                // On Posix, it will start with "/"
                isFileUrl = false;
                path = isWindows ? path : '/' + path;
              }
            }
            // Step 4: On Windows, convert backslashes to forward slashes,
            // unless it's a "file://" URL
            if (isWindows && !isFileUrl) {
              path = path.replace(forwardSlashPattern, '\\');
            }
            return path;
          };
        }.call(this, require('_process')));
      },
      {
        '_process': 115,
        'url': 146
      }
    ],
    106: [
      function (require, module, exports) {
        /* eslint lines-around-comment: [2, {beforeBlockComment: false}] */
        'use strict';
        var yaml = require('js-yaml'), ono = require('ono');
        /**
 * Simple YAML parsing functions, similar to {@link JSON.parse} and {@link JSON.stringify}
 */
        module.exports = {
          parse: function yamlParse(text, reviver) {
            try {
              return yaml.safeLoad(text);
            } catch (e) {
              if (e instanceof Error) {
                throw e;
              } else {
                // https://github.com/nodeca/js-yaml/issues/153
                throw ono(e, e.message);
              }
            }
          },
          stringify: function yamlStringify(value, replacer, space) {
            try {
              var indent = (typeof space === 'string' ? space.length : space) || 2;
              return yaml.safeDump(value, { indent: indent });
            } catch (e) {
              if (e instanceof Error) {
                throw e;
              } else {
                // https://github.com/nodeca/js-yaml/issues/153
                throw ono(e, e.message);
              }
            }
          }
        };
      },
      {
        'js-yaml': 56,
        'ono': 113
      }
    ],
    107: [
      function (require, module, exports) {
        'use strict';
        module.exports = {
          order: 100,
          canValidate: function canValidate(file) {
            // Z-Schema requires JSON References to already be resolved (but not dereferenced)
            return !!file.resolved;
          },
          validate: function validate(file) {
          }
        };
      },
      {}
    ],
    108: [
      function (require, module, exports) {
        (function (global) {
          /**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
          /** Used as the `TypeError` message for "Functions" methods. */
          var FUNC_ERROR_TEXT = 'Expected a function';
          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__';
          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0;
          /** `Object#toString` result references. */
          var funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
          /** Used to match property names within property paths. */
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
          /**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          /** Used to match backslashes in property paths. */
          var reEscapeChar = /\\(\\)?/g;
          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          /** Detect free variable `global` from Node.js. */
          var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
          /** Detect free variable `self`. */
          var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')();
          /**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }
          /**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
          function isHostObject(value) {
            // Many host objects are `Object` objects that can coerce to strings
            // despite having improperly defined `toString` methods.
            var result = false;
            if (value != null && typeof value.toString != 'function') {
              try {
                result = !!(value + '');
              } catch (e) {
              }
            }
            return result;
          }
          /** Used for built-in method references. */
          var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__'];
          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
              var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
              return uid ? 'Symbol(src)_1.' + uid : '';
            }();
          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;
          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;
          /**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
          var objectToString = objectProto.toString;
          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
          /** Built-in value references. */
          var Symbol = root.Symbol, splice = arrayProto.splice;
          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, 'Map'), nativeCreate = getNative(Object, 'create');
          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
          /**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function Hash(entries) {
            var index = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
          }
          /**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }
          /**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }
          /**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }
          /**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
          function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }
          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          /**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function ListCache(entries) {
            var index = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
          function listCacheClear() {
            this.__data__ = [];
          }
          /**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            return true;
          }
          /**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }
          /**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          /**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              data.push([
                key,
                value
              ]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          /**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function MapCache(entries) {
            var index = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
          function mapCacheClear() {
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }
          /**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function mapCacheDelete(key) {
            return getMapData(this, key)['delete'](key);
          }
          /**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          /**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          /**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
          function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
          }
          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          /**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          /**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
          function baseGet(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined;
          }
          /**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          /**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
              return value;
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : '';
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
          function castPath(value) {
            return isArray(value) ? value : stringToPath(value);
          }
          /**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }
          /**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }
          /**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }
          /**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
          function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }
          /**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          /**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
          var stringToPath = memoize(function (string) {
              string = toString(string);
              var result = [];
              if (reLeadingDot.test(string)) {
                result.push('');
              }
              string.replace(rePropName, function (match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
              });
              return result;
            });
          /**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
          function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) {
              return value;
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + '';
              } catch (e) {
              }
            }
            return '';
          }
          /**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
          function memoize(func, resolver) {
            if (typeof func != 'function' || resolver && typeof resolver != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function () {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result);
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          // Assign cache to `_.memoize`.
          memoize.Cache = MapCache;
          /**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          /**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
          var isArray = Array.isArray;
          /**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
          function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 8-9 which returns 'object' for typed array and other constructors.
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
          }
          /**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }
          /**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
          function isObjectLike(value) {
            return !!value && typeof value == 'object';
          }
          /**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
          function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
          }
          /**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
          function toString(value) {
            return value == null ? '' : baseToString(value);
          }
          /**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }
          module.exports = get;
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    109: [
      function (require, module, exports) {
        (function (global) {
          /**
 * @license
 * lodash <https://lodash.com/>
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
          ;
          (function () {
            /** Used as a safe reference for `undefined` in pre-ES5 environments. */
            var undefined;
            /** Used as the semantic version number. */
            var VERSION = '4.16.0';
            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;
            /** Used as the `TypeError` message for "Functions" methods. */
            var FUNC_ERROR_TEXT = 'Expected a function';
            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            /** Used as the maximum memoize cache size. */
            var MAX_MEMOIZE_SIZE = 500;
            /** Used as the internal argument placeholder. */
            var PLACEHOLDER = '__lodash_placeholder__';
            /** Used to compose bitmasks for function metadata. */
            var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, FLIP_FLAG = 512;
            /** Used to compose bitmasks for comparison styles. */
            var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
            /** Used as default options for `_.truncate`. */
            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
            /** Used to detect hot functions by number of calls within a span of milliseconds. */
            var HOT_COUNT = 500, HOT_SPAN = 16;
            /** Used to indicate the type of lazy iteratees. */
            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
            /** Used as references for the maximum length and index of an array. */
            var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
            /** Used to associate wrap methods with their bit flags. */
            var wrapFlags = [
                [
                  'ary',
                  ARY_FLAG
                ],
                [
                  'bind',
                  BIND_FLAG
                ],
                [
                  'bindKey',
                  BIND_KEY_FLAG
                ],
                [
                  'curry',
                  CURRY_FLAG
                ],
                [
                  'curryRight',
                  CURRY_RIGHT_FLAG
                ],
                [
                  'flip',
                  FLIP_FLAG
                ],
                [
                  'partial',
                  PARTIAL_FLAG
                ],
                [
                  'partialRight',
                  PARTIAL_RIGHT_FLAG
                ],
                [
                  'rearg',
                  REARG_FLAG
                ]
              ];
            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';
            var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
            /** Used to match empty string literals in compiled template source. */
            var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
            /** Used to match HTML entities and HTML characters. */
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
            /** Used to match template delimiters. */
            var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
            /** Used to match leading and trailing whitespace. */
            var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
            /** Used to match wrap detail comments. */
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
            /** Used to match words composed of alphanumeric characters. */
            var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g;
            /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
            /** Used to match `RegExp` flags from their coerced string values. */
            var reFlags = /\w*$/;
            /** Used to detect bad signed hexadecimal string values. */
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            /** Used to detect binary string values. */
            var reIsBinary = /^0b[01]+$/i;
            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            /** Used to detect octal string values. */
            var reIsOctal = /^0o[0-7]+$/i;
            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            /** Used to match Latin Unicode letters (excluding mathematical operators). */
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
            /** Used to ensure capturing order of template delimiters. */
            var reNoMatch = /($^)/;
            /** Used to match unescaped characters in compiled string literals. */
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
            /** Used to compose unicode character classes. */
            var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23', rsComboSymbolsRange = '\\u20d0-\\u20f0', rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
            /** Used to compose unicode capture groups. */
            var rsApos = '[\'\u2019]', rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
            /** Used to compose unicode regexes. */
            var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')', rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [
                rsNonAstral,
                rsRegional,
                rsSurrPair
              ].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [
                rsDingbat,
                rsRegional,
                rsSurrPair
              ].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [
                rsNonAstral + rsCombo + '?',
                rsCombo,
                rsRegional,
                rsSurrPair,
                rsAstral
              ].join('|') + ')';
            /** Used to match apostrophes. */
            var reApos = RegExp(rsApos, 'g');
            /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
            var reComboMark = RegExp(rsCombo, 'g');
            /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
            var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
            /** Used to match complex or compound words. */
            var reUnicodeWord = RegExp([
                rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [
                  rsBreak,
                  rsUpper,
                  '$'
                ].join('|') + ')',
                rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [
                  rsBreak,
                  rsUpper + rsLowerMisc,
                  '$'
                ].join('|') + ')',
                rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
                rsUpper + '+' + rsOptUpperContr,
                rsDigits,
                rsEmoji
              ].join('|'), 'g');
            /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
            var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
            /** Used to detect strings that need a more robust regexp to match words. */
            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
            /** Used to assign default `context` object properties. */
            var contextProps = [
                'Array',
                'Buffer',
                'DataView',
                'Date',
                'Error',
                'Float32Array',
                'Float64Array',
                'Function',
                'Int8Array',
                'Int16Array',
                'Int32Array',
                'Map',
                'Math',
                'Object',
                'Promise',
                'RegExp',
                'Set',
                'String',
                'Symbol',
                'TypeError',
                'Uint8Array',
                'Uint8ClampedArray',
                'Uint16Array',
                'Uint32Array',
                'WeakMap',
                '_',
                'clearTimeout',
                'isFinite',
                'parseInt',
                'setTimeout'
              ];
            /** Used to make template sourceURLs easier to identify. */
            var templateCounter = -1;
            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            /** Used to identify `toStringTag` values supported by `_.clone`. */
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
            /** Used to map Latin Unicode letters to basic Latin letters. */
            var deburredLetters = {
                '\xc0': 'A',
                '\xc1': 'A',
                '\xc2': 'A',
                '\xc3': 'A',
                '\xc4': 'A',
                '\xc5': 'A',
                '\xe0': 'a',
                '\xe1': 'a',
                '\xe2': 'a',
                '\xe3': 'a',
                '\xe4': 'a',
                '\xe5': 'a',
                '\xc7': 'C',
                '\xe7': 'c',
                '\xd0': 'D',
                '\xf0': 'd',
                '\xc8': 'E',
                '\xc9': 'E',
                '\xca': 'E',
                '\xcb': 'E',
                '\xe8': 'e',
                '\xe9': 'e',
                '\xea': 'e',
                '\xeb': 'e',
                '\xcc': 'I',
                '\xcd': 'I',
                '\xce': 'I',
                '\xcf': 'I',
                '\xec': 'i',
                '\xed': 'i',
                '\xee': 'i',
                '\xef': 'i',
                '\xd1': 'N',
                '\xf1': 'n',
                '\xd2': 'O',
                '\xd3': 'O',
                '\xd4': 'O',
                '\xd5': 'O',
                '\xd6': 'O',
                '\xd8': 'O',
                '\xf2': 'o',
                '\xf3': 'o',
                '\xf4': 'o',
                '\xf5': 'o',
                '\xf6': 'o',
                '\xf8': 'o',
                '\xd9': 'U',
                '\xda': 'U',
                '\xdb': 'U',
                '\xdc': 'U',
                '\xf9': 'u',
                '\xfa': 'u',
                '\xfb': 'u',
                '\xfc': 'u',
                '\xdd': 'Y',
                '\xfd': 'y',
                '\xff': 'y',
                '\xc6': 'Ae',
                '\xe6': 'ae',
                '\xde': 'Th',
                '\xfe': 'th',
                '\xdf': 'ss',
                '\u0100': 'A',
                '\u0102': 'A',
                '\u0104': 'A',
                '\u0101': 'a',
                '\u0103': 'a',
                '\u0105': 'a',
                '\u0106': 'C',
                '\u0108': 'C',
                '\u010a': 'C',
                '\u010c': 'C',
                '\u0107': 'c',
                '\u0109': 'c',
                '\u010b': 'c',
                '\u010d': 'c',
                '\u010e': 'D',
                '\u0110': 'D',
                '\u010f': 'd',
                '\u0111': 'd',
                '\u0112': 'E',
                '\u0114': 'E',
                '\u0116': 'E',
                '\u0118': 'E',
                '\u011a': 'E',
                '\u0113': 'e',
                '\u0115': 'e',
                '\u0117': 'e',
                '\u0119': 'e',
                '\u011b': 'e',
                '\u011c': 'G',
                '\u011e': 'G',
                '\u0120': 'G',
                '\u0122': 'G',
                '\u011d': 'g',
                '\u011f': 'g',
                '\u0121': 'g',
                '\u0123': 'g',
                '\u0124': 'H',
                '\u0126': 'H',
                '\u0125': 'h',
                '\u0127': 'h',
                '\u0128': 'I',
                '\u012a': 'I',
                '\u012c': 'I',
                '\u012e': 'I',
                '\u0130': 'I',
                '\u0129': 'i',
                '\u012b': 'i',
                '\u012d': 'i',
                '\u012f': 'i',
                '\u0131': 'i',
                '\u0134': 'J',
                '\u0135': 'j',
                '\u0136': 'K',
                '\u0137': 'k',
                '\u0138': 'k',
                '\u0139': 'L',
                '\u013b': 'L',
                '\u013d': 'L',
                '\u013f': 'L',
                '\u0141': 'L',
                '\u013a': 'l',
                '\u013c': 'l',
                '\u013e': 'l',
                '\u0140': 'l',
                '\u0142': 'l',
                '\u0143': 'N',
                '\u0145': 'N',
                '\u0147': 'N',
                '\u014a': 'N',
                '\u0144': 'n',
                '\u0146': 'n',
                '\u0148': 'n',
                '\u014b': 'n',
                '\u014c': 'O',
                '\u014e': 'O',
                '\u0150': 'O',
                '\u014d': 'o',
                '\u014f': 'o',
                '\u0151': 'o',
                '\u0154': 'R',
                '\u0156': 'R',
                '\u0158': 'R',
                '\u0155': 'r',
                '\u0157': 'r',
                '\u0159': 'r',
                '\u015a': 'S',
                '\u015c': 'S',
                '\u015e': 'S',
                '\u0160': 'S',
                '\u015b': 's',
                '\u015d': 's',
                '\u015f': 's',
                '\u0161': 's',
                '\u0162': 'T',
                '\u0164': 'T',
                '\u0166': 'T',
                '\u0163': 't',
                '\u0165': 't',
                '\u0167': 't',
                '\u0168': 'U',
                '\u016a': 'U',
                '\u016c': 'U',
                '\u016e': 'U',
                '\u0170': 'U',
                '\u0172': 'U',
                '\u0169': 'u',
                '\u016b': 'u',
                '\u016d': 'u',
                '\u016f': 'u',
                '\u0171': 'u',
                '\u0173': 'u',
                '\u0174': 'W',
                '\u0175': 'w',
                '\u0176': 'Y',
                '\u0177': 'y',
                '\u0178': 'Y',
                '\u0179': 'Z',
                '\u017b': 'Z',
                '\u017d': 'Z',
                '\u017a': 'z',
                '\u017c': 'z',
                '\u017e': 'z',
                '\u0132': 'IJ',
                '\u0133': 'ij',
                '\u0152': 'Oe',
                '\u0153': 'oe',
                '\u0149': '\'n',
                '\u017f': 's'
              };
            /** Used to map characters to HTML entities. */
            var htmlEscapes = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                '\'': '&#39;'
              };
            /** Used to map HTML entities to characters. */
            var htmlUnescapes = {
                '&amp;': '&',
                '&lt;': '<',
                '&gt;': '>',
                '&quot;': '"',
                '&#39;': '\''
              };
            /** Used to escape characters for inclusion in compiled string literals. */
            var stringEscapes = {
                '\\': '\\',
                '\'': '\'',
                '\n': 'n',
                '\r': 'r',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
              };
            /** Built-in method references without a dependency on `root`. */
            var freeParseFloat = parseFloat, freeParseInt = parseInt;
            /** Detect free variable `global` from Node.js. */
            var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
            /** Detect free variable `self`. */
            var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
            /** Used as a reference to the global object. */
            var root = freeGlobal || freeSelf || Function('return this')();
            /** Detect free variable `exports`. */
            var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
            /** Detect free variable `module`. */
            var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
            /** Detect the popular CommonJS extension `module.exports`. */
            var moduleExports = freeModule && freeModule.exports === freeExports;
            /** Detect free variable `process` from Node.js. */
            var freeProcess = moduleExports && freeGlobal.process;
            /** Used to access faster Node.js helpers. */
            var nodeUtil = function () {
                try {
                  return freeProcess && freeProcess.binding('util');
                } catch (e) {
                }
              }();
            /* Node.js helper references. */
            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            /*--------------------------------------------------------------------------*/
            /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */
            function addMapEntry(map, pair) {
              // Don't return `map.set` because it's not chainable in IE 11.
              map.set(pair[0], pair[1]);
              return map;
            }
            /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */
            function addSetEntry(set, value) {
              // Don't return `set.add` because it's not chainable in IE 11.
              set.add(value);
              return set;
            }
            /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
            function apply(func, thisArg, args) {
              switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
            function arrayAggregator(array, setter, iteratee, accumulator) {
              var index = -1, length = array ? array.length : 0;
              while (++index < length) {
                var value = array[index];
                setter(accumulator, value, iteratee(value), array);
              }
              return accumulator;
            }
            /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
            function arrayEach(array, iteratee) {
              var index = -1, length = array ? array.length : 0;
              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }
            /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
            function arrayEachRight(array, iteratee) {
              var length = array ? array.length : 0;
              while (length--) {
                if (iteratee(array[length], length, array) === false) {
                  break;
                }
              }
              return array;
            }
            /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
            function arrayEvery(array, predicate) {
              var index = -1, length = array ? array.length : 0;
              while (++index < length) {
                if (!predicate(array[index], index, array)) {
                  return false;
                }
              }
              return true;
            }
            /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
            function arrayFilter(array, predicate) {
              var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
              while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
            function arrayIncludes(array, value) {
              var length = array ? array.length : 0;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }
            /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
            function arrayIncludesWith(array, value, comparator) {
              var index = -1, length = array ? array.length : 0;
              while (++index < length) {
                if (comparator(value, array[index])) {
                  return true;
                }
              }
              return false;
            }
            /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
            function arrayMap(array, iteratee) {
              var index = -1, length = array ? array.length : 0, result = Array(length);
              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }
            /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
            function arrayPush(array, values) {
              var index = -1, length = values.length, offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1, length = array ? array.length : 0;
              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }
            /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
              var length = array ? array.length : 0;
              if (initAccum && length) {
                accumulator = array[--length];
              }
              while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
              }
              return accumulator;
            }
            /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
            function arraySome(array, predicate) {
              var index = -1, length = array ? array.length : 0;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
            var asciiSize = baseProperty('length');
            /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
            function asciiToArray(string) {
              return string.split('');
            }
            /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
            function asciiWords(string) {
              return string.match(reAsciiWord) || [];
            }
            /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
            function baseFindKey(collection, predicate, eachFunc) {
              var result;
              eachFunc(collection, function (value, key, collection) {
                if (predicate(value, key, collection)) {
                  result = key;
                  return false;
                }
              });
              return result;
            }
            /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
              while (fromRight ? index-- : ++index < length) {
                if (predicate(array[index], index, array)) {
                  return index;
                }
              }
              return -1;
            }
            /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function baseIndexOf(array, value, fromIndex) {
              return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function baseIndexOfWith(array, value, fromIndex, comparator) {
              var index = fromIndex - 1, length = array.length;
              while (++index < length) {
                if (comparator(array[index], value)) {
                  return index;
                }
              }
              return -1;
            }
            /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
            function baseIsNaN(value) {
              return value !== value;
            }
            /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
            function baseMean(array, iteratee) {
              var length = array ? array.length : 0;
              return length ? baseSum(array, iteratee) / length : NAN;
            }
            /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
            function baseProperty(key) {
              return function (object) {
                return object == null ? undefined : object[key];
              };
            }
            /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
            function basePropertyOf(object) {
              return function (key) {
                return object == null ? undefined : object[key];
              };
            }
            /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
              eachFunc(collection, function (value, index, collection) {
                accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
              });
              return accumulator;
            }
            /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
            function baseSortBy(array, comparer) {
              var length = array.length;
              array.sort(comparer);
              while (length--) {
                array[length] = array[length].value;
              }
              return array;
            }
            /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
            function baseSum(array, iteratee) {
              var result, index = -1, length = array.length;
              while (++index < length) {
                var current = iteratee(array[index]);
                if (current !== undefined) {
                  result = result === undefined ? current : result + current;
                }
              }
              return result;
            }
            /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
            function baseTimes(n, iteratee) {
              var index = -1, result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
            function baseToPairs(object, props) {
              return arrayMap(props, function (key) {
                return [
                  key,
                  object[key]
                ];
              });
            }
            /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
            function baseUnary(func) {
              return function (value) {
                return func(value);
              };
            }
            /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
            function baseValues(object, props) {
              return arrayMap(props, function (key) {
                return object[key];
              });
            }
            /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
            function cacheHas(cache, key) {
              return cache.has(key);
            }
            /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
            function charsStartIndex(strSymbols, chrSymbols) {
              var index = -1, length = strSymbols.length;
              while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
              }
              return index;
            }
            /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
            function charsEndIndex(strSymbols, chrSymbols) {
              var index = strSymbols.length;
              while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
              }
              return index;
            }
            /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
            function countHolders(array, placeholder) {
              var length = array.length, result = 0;
              while (length--) {
                if (array[length] === placeholder) {
                  ++result;
                }
              }
              return result;
            }
            /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
            var deburrLetter = basePropertyOf(deburredLetters);
            /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
            var escapeHtmlChar = basePropertyOf(htmlEscapes);
            /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
            function escapeStringChar(chr) {
              return '\\' + stringEscapes[chr];
            }
            /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
            function hasUnicode(string) {
              return reHasUnicode.test(string);
            }
            /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
            function hasUnicodeWord(string) {
              return reHasUnicodeWord.test(string);
            }
            /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
            function iteratorToArray(iterator) {
              var data, result = [];
              while (!(data = iterator.next()).done) {
                result.push(data.value);
              }
              return result;
            }
            /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
            function mapToArray(map) {
              var index = -1, result = Array(map.size);
              map.forEach(function (value, key) {
                result[++index] = [
                  key,
                  value
                ];
              });
              return result;
            }
            /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
            function overArg(func, transform) {
              return function (arg) {
                return func(transform(arg));
              };
            }
            /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
            function replaceHolders(array, placeholder) {
              var index = -1, length = array.length, resIndex = 0, result = [];
              while (++index < length) {
                var value = array[index];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index] = PLACEHOLDER;
                  result[resIndex++] = index;
                }
              }
              return result;
            }
            /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
            function setToArray(set) {
              var index = -1, result = Array(set.size);
              set.forEach(function (value) {
                result[++index] = value;
              });
              return result;
            }
            /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
            function setToPairs(set) {
              var index = -1, result = Array(set.size);
              set.forEach(function (value) {
                result[++index] = [
                  value,
                  value
                ];
              });
              return result;
            }
            /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function strictIndexOf(array, value, fromIndex) {
              var index = fromIndex - 1, length = array.length;
              while (++index < length) {
                if (array[index] === value) {
                  return index;
                }
              }
              return -1;
            }
            /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function strictLastIndexOf(array, value, fromIndex) {
              var index = fromIndex + 1;
              while (index--) {
                if (array[index] === value) {
                  return index;
                }
              }
              return index;
            }
            /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
            function stringSize(string) {
              return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
            }
            /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
            function stringToArray(string) {
              return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
            }
            /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
            /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
            function unicodeSize(string) {
              var result = reUnicode.lastIndex = 0;
              while (reUnicode.test(string)) {
                ++result;
              }
              return result;
            }
            /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
            function unicodeToArray(string) {
              return string.match(reUnicode) || [];
            }
            /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
            function unicodeWords(string) {
              return string.match(reUnicodeWord) || [];
            }
            /*--------------------------------------------------------------------------*/
            /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
            function runInContext(context) {
              context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
              /** Built-in constructor references. */
              var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
              /** Used for built-in method references. */
              var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
              /** Used to detect overreaching core-js shims. */
              var coreJsData = context['__core-js_shared__'];
              /** Used to detect methods masquerading as native. */
              var maskSrcKey = function () {
                  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                  return uid ? 'Symbol(src)_1.' + uid : '';
                }();
              /** Used to resolve the decompiled source of functions. */
              var funcToString = funcProto.toString;
              /** Used to check objects for own properties. */
              var hasOwnProperty = objectProto.hasOwnProperty;
              /** Used to generate unique IDs. */
              var idCounter = 0;
              /** Used to infer the `Object` constructor. */
              var objectCtorString = funcToString.call(Object);
              /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
              var objectToString = objectProto.toString;
              /** Used to restore the original `_` reference in `_.noConflict`. */
              var oldDash = root._;
              /** Used to detect if a method is native. */
              var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
              /** Built-in value references. */
              var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, defineProperty = Object.defineProperty, getPrototype = overArg(Object.getPrototypeOf, Object), iteratorSymbol = Symbol ? Symbol.iterator : undefined, objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
              /** Mocked built-ins. */
              var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
              /* Built-in method references for those with the same name as other `lodash` methods. */
              var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
              /* Built-in method references that are verified to be native. */
              var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create'), nativeDefineProperty = getNative(Object, 'defineProperty');
              /** Used to store function metadata. */
              var metaMap = WeakMap && new WeakMap();
              /** Used to lookup unminified function names. */
              var realNames = {};
              /** Used to detect maps, sets, and weakmaps. */
              var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
              /** Used to convert symbols to primitives and strings. */
              var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array of at least `200` elements
     * and any iteratees accept only one argument. The heuristic for whether a
     * section qualifies for shortcut fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
              function lodash(value) {
                if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                  if (value instanceof LodashWrapper) {
                    return value;
                  }
                  if (hasOwnProperty.call(value, '__wrapped__')) {
                    return wrapperClone(value);
                  }
                }
                return new LodashWrapper(value);
              }
              /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
              function baseLodash() {
              }
              /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
              function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined;
              }
              /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
              lodash.templateSettings = {
                'escape': reEscape,
                'evaluate': reEvaluate,
                'interpolate': reInterpolate,
                'variable': '',
                'imports': { '_': lodash }
              };
              // Ensure wrappers are instances of `baseLodash`.
              lodash.prototype = baseLodash.prototype;
              lodash.prototype.constructor = lodash;
              LodashWrapper.prototype = baseCreate(baseLodash.prototype);
              LodashWrapper.prototype.constructor = LodashWrapper;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
              function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
              }
              /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
              function lazyClone() {
                var result = new LazyWrapper(this.__wrapped__);
                result.__actions__ = copyArray(this.__actions__);
                result.__dir__ = this.__dir__;
                result.__filtered__ = this.__filtered__;
                result.__iteratees__ = copyArray(this.__iteratees__);
                result.__takeCount__ = this.__takeCount__;
                result.__views__ = copyArray(this.__views__);
                return result;
              }
              /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
              function lazyReverse() {
                if (this.__filtered__) {
                  var result = new LazyWrapper(this);
                  result.__dir__ = -1;
                  result.__filtered__ = true;
                } else {
                  result = this.clone();
                  result.__dir__ *= -1;
                }
                return result;
              }
              /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
              function lazyValue() {
                var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                if (!isArr || arrLength < LARGE_ARRAY_SIZE || arrLength == length && takeCount == length) {
                  return baseWrapperValue(array, this.__actions__);
                }
                var result = [];
                outer:
                  while (length-- && resIndex < takeCount) {
                    index += dir;
                    var iterIndex = -1, value = array[index];
                    while (++iterIndex < iterLength) {
                      var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                      if (type == LAZY_MAP_FLAG) {
                        value = computed;
                      } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                          continue outer;
                        } else {
                          break outer;
                        }
                      }
                    }
                    result[resIndex++] = value;
                  }
                return result;
              }
              // Ensure `LazyWrapper` is an instance of `baseLodash`.
              LazyWrapper.prototype = baseCreate(baseLodash.prototype);
              LazyWrapper.prototype.constructor = LazyWrapper;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function Hash(entries) {
                var index = -1, length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }
              /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
              }
              /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result = data[key];
                  return result === HASH_UNDEFINED ? undefined : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined;
              }
              /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
              }
              /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                return this;
              }
              // Add methods to `Hash`.
              Hash.prototype.clear = hashClear;
              Hash.prototype['delete'] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              /*------------------------------------------------------------------------*/
              /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function ListCache(entries) {
                var index = -1, length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }
              /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index, 1);
                }
                --this.size;
                return true;
              }
              /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? undefined : data[index][1];
              }
              /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
              function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  ++this.size;
                  data.push([
                    key,
                    value
                  ]);
                } else {
                  data[index][1] = value;
                }
                return this;
              }
              // Add methods to `ListCache`.
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype['delete'] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function MapCache(entries) {
                var index = -1, length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  'hash': new Hash(),
                  'map': new (Map || ListCache)(),
                  'string': new Hash()
                };
              }
              /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function mapCacheDelete(key) {
                var result = getMapData(this, key)['delete'](key);
                this.size -= result ? 1 : 0;
                return result;
              }
              /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
              function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
              }
              // Add methods to `MapCache`.
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype['delete'] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              /*------------------------------------------------------------------------*/
              /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
              function SetCache(values) {
                var index = -1, length = values ? values.length : 0;
                this.__data__ = new MapCache();
                while (++index < length) {
                  this.add(values[index]);
                }
              }
              /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }
              /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
              function setCacheHas(value) {
                return this.__data__.has(value);
              }
              // Add methods to `SetCache`.
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
              }
              /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }
              /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function stackDelete(key) {
                var data = this.__data__, result = data['delete'](key);
                this.size = data.size;
                return result;
              }
              /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function stackGet(key) {
                return this.__data__.get(key);
              }
              /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function stackHas(key) {
                return this.__data__.has(key);
              }
              /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([
                      key,
                      value
                    ]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              // Add methods to `Stack`.
              Stack.prototype.clear = stackClear;
              Stack.prototype['delete'] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              /*------------------------------------------------------------------------*/
              /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
              function arrayLikeKeys(value, inherited) {
                // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                // Safari 9 makes `arguments.length` enumerable in strict mode.
                var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
                var length = result.length, skipIndexes = !!length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * A specialized version of `_.sample` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
              function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined;
              }
              /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
              function arraySampleSize(array, n) {
                var result = arrayShuffle(array);
                result.length = baseClamp(n, 0, result.length);
                return result;
              }
              /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
              function arrayShuffle(array) {
                return shuffleSelf(copyArray(array));
              }
              /**
     * Used by `_.defaults` to customize its `_.assignIn` use.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
              function assignInDefaults(objValue, srcValue, key, object) {
                if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  return srcValue;
                }
                return objValue;
              }
              /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
              function assignMergeValue(object, key, value) {
                if (value !== undefined && !eq(object[key], value) || typeof key == 'number' && value === undefined && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
              function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
              function baseAggregator(collection, setter, iteratee, accumulator) {
                baseEach(collection, function (value, key, collection) {
                  setter(accumulator, value, iteratee(value), collection);
                });
                return accumulator;
              }
              /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
              function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
              }
              /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
              function baseAssignValue(object, key, value) {
                if (key == '__proto__' && defineProperty) {
                  defineProperty(object, key, {
                    'configurable': true,
                    'enumerable': true,
                    'value': value,
                    'writable': true
                  });
                } else {
                  object[key] = value;
                }
              }
              /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths of elements to pick.
     * @returns {Array} Returns the picked elements.
     */
              function baseAt(object, paths) {
                var index = -1, isNil = object == null, length = paths.length, result = Array(length);
                while (++index < length) {
                  result[index] = isNil ? undefined : get(object, paths[index]);
                }
                return result;
              }
              /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
              function baseClamp(number, lower, upper) {
                if (number === number) {
                  if (upper !== undefined) {
                    number = number <= upper ? number : upper;
                  }
                  if (lower !== undefined) {
                    number = number >= lower ? number : lower;
                  }
                }
                return number;
              }
              /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
              function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
                var result;
                if (customizer) {
                  result = object ? customizer(value, key, object, stack) : customizer(value);
                }
                if (result !== undefined) {
                  return result;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray(value, result);
                  }
                } else {
                  var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                  if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                  }
                  if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                      return copySymbols(value, baseAssign(result, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                  }
                }
                // Check for circular references and return its corresponding clone.
                stack || (stack = new Stack());
                var stacked = stack.get(value);
                if (stacked) {
                  return stacked;
                }
                stack.set(value, result);
                if (!isArr) {
                  var props = isFull ? getAllKeys(value) : keys(value);
                }
                arrayEach(props || value, function (subValue, key) {
                  if (props) {
                    key = subValue;
                    subValue = value[key];
                  }
                  // Recursively populate clone (susceptible to call stack limits).
                  assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
                });
                return result;
              }
              /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
              function baseConforms(source) {
                var props = keys(source);
                return function (object) {
                  return baseConformsTo(object, source, props);
                };
              }
              /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
              function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (length--) {
                  var key = props[length], predicate = source[key], value = object[key];
                  if (value === undefined && !(key in object) || !predicate(value)) {
                    return false;
                  }
                }
                return true;
              }
              /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
              function baseCreate(proto) {
                return isObject(proto) ? objectCreate(proto) : {};
              }
              /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
              function baseDelay(func, wait, args) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return setTimeout(function () {
                  func.apply(undefined, args);
                }, wait);
              }
              /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
              function baseDifference(array, values, iteratee, comparator) {
                var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
                if (!length) {
                  return result;
                }
                if (iteratee) {
                  values = arrayMap(values, baseUnary(iteratee));
                }
                if (comparator) {
                  includes = arrayIncludesWith;
                  isCommon = false;
                } else if (values.length >= LARGE_ARRAY_SIZE) {
                  includes = cacheHas;
                  isCommon = false;
                  values = new SetCache(values);
                }
                outer:
                  while (++index < length) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values[valuesIndex] === computed) {
                          continue outer;
                        }
                      }
                      result.push(value);
                    } else if (!includes(values, computed, comparator)) {
                      result.push(value);
                    }
                  }
                return result;
              }
              /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
              var baseEach = createBaseEach(baseForOwn);
              /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
              var baseEachRight = createBaseEach(baseForOwnRight, true);
              /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
              function baseEvery(collection, predicate) {
                var result = true;
                baseEach(collection, function (value, index, collection) {
                  result = !!predicate(value, index, collection);
                  return result;
                });
                return result;
              }
              /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
              function baseExtremum(array, iteratee, comparator) {
                var index = -1, length = array.length;
                while (++index < length) {
                  var value = array[index], current = iteratee(value);
                  if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                    var computed = current, result = value;
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
              function baseFill(array, value, start, end) {
                var length = array.length;
                start = toInteger(start);
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end === undefined || end > length ? length : toInteger(end);
                if (end < 0) {
                  end += length;
                }
                end = start > end ? 0 : toLength(end);
                while (start < end) {
                  array[start++] = value;
                }
                return array;
              }
              /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
              function baseFilter(collection, predicate) {
                var result = [];
                baseEach(collection, function (value, index, collection) {
                  if (predicate(value, index, collection)) {
                    result.push(value);
                  }
                });
                return result;
              }
              /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
              function baseFlatten(array, depth, predicate, isStrict, result) {
                var index = -1, length = array.length;
                predicate || (predicate = isFlattenable);
                result || (result = []);
                while (++index < length) {
                  var value = array[index];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      // Recursively flatten arrays (susceptible to call stack limits).
                      baseFlatten(value, depth - 1, predicate, isStrict, result);
                    } else {
                      arrayPush(result, value);
                    }
                  } else if (!isStrict) {
                    result[result.length] = value;
                  }
                }
                return result;
              }
              /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
              var baseFor = createBaseFor();
              /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
              var baseForRight = createBaseFor(true);
              /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
              function baseForOwn(object, iteratee) {
                return object && baseFor(object, iteratee, keys);
              }
              /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
              function baseForOwnRight(object, iteratee) {
                return object && baseForRight(object, iteratee, keys);
              }
              /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
              function baseFunctions(object, props) {
                return arrayFilter(props, function (key) {
                  return isFunction(object[key]);
                });
              }
              /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
              function baseGet(object, path) {
                path = isKey(path, object) ? [path] : castPath(path);
                var index = 0, length = path.length;
                while (object != null && index < length) {
                  object = object[toKey(path[index++])];
                }
                return index && index == length ? object : undefined;
              }
              /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
              }
              /**
     * The base implementation of `getTag`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
              function baseGetTag(value) {
                return objectToString.call(value);
              }
              /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
              function baseGt(value, other) {
                return value > other;
              }
              /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
              function baseHas(object, key) {
                return object != null && hasOwnProperty.call(object, key);
              }
              /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
              function baseHasIn(object, key) {
                return object != null && key in Object(object);
              }
              /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
              function baseInRange(number, start, end) {
                return number >= nativeMin(start, end) && number < nativeMax(start, end);
              }
              /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
              function baseIntersection(arrays, iteratee, comparator) {
                var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
                while (othIndex--) {
                  var array = arrays[othIndex];
                  if (othIndex && iteratee) {
                    array = arrayMap(array, baseUnary(iteratee));
                  }
                  maxLength = nativeMin(array.length, maxLength);
                  caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
                }
                array = arrays[0];
                var index = -1, seen = caches[0];
                outer:
                  while (++index < length && result.length < maxLength) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                      othIndex = othLength;
                      while (--othIndex) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                          continue outer;
                        }
                      }
                      if (seen) {
                        seen.push(computed);
                      }
                      result.push(value);
                    }
                  }
                return result;
              }
              /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
              function baseInverter(object, setter, iteratee, accumulator) {
                baseForOwn(object, function (value, key, object) {
                  setter(accumulator, iteratee(value), key, object);
                });
                return accumulator;
              }
              /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
              function baseInvoke(object, path, args) {
                if (!isKey(path, object)) {
                  path = castPath(path);
                  object = parent(object, path);
                  path = last(path);
                }
                var func = object == null ? object : object[toKey(path)];
                return func == null ? undefined : apply(func, object, args);
              }
              /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
              function baseIsArrayBuffer(value) {
                return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
              }
              /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
              function baseIsDate(value) {
                return isObjectLike(value) && objectToString.call(value) == dateTag;
              }
              /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {boolean} [bitmask] The bitmask of comparison flags.
     *  The bitmask may be composed of the following flags:
     *     1 - Unordered comparison
     *     2 - Partial comparison
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
              function baseIsEqual(value, other, customizer, bitmask, stack) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
              }
              /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
              function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
                if (!objIsArr) {
                  objTag = getTag(object);
                  objTag = objTag == argsTag ? objectTag : objTag;
                }
                if (!othIsArr) {
                  othTag = getTag(other);
                  othTag = othTag == argsTag ? objectTag : othTag;
                }
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
                }
                if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
              }
              /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
              function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
              }
              /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
              function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length, length = index, noCustomizer = !customizer;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (index--) {
                  var data = matchData[index];
                  if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                  }
                }
                while (++index < length) {
                  data = matchData[index];
                  var key = data[0], objValue = object[key], srcValue = data[1];
                  if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack = new Stack();
                    if (customizer) {
                      var result = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                      return false;
                    }
                  }
                }
                return true;
              }
              /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
              function baseIsRegExp(value) {
                return isObject(value) && objectToString.call(value) == regexpTag;
              }
              /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
              function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
              }
              /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
              function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
              }
              /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
              function baseIteratee(value) {
                // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                if (typeof value == 'function') {
                  return value;
                }
                if (value == null) {
                  return identity;
                }
                if (typeof value == 'object') {
                  return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                }
                return property(value);
              }
              /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (hasOwnProperty.call(object, key) && key != 'constructor') {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
              function baseKeysIn(object) {
                if (!isObject(object)) {
                  return nativeKeysIn(object);
                }
                var isProto = isPrototype(object), result = [];
                for (var key in object) {
                  if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
              function baseLt(value, other) {
                return value < other;
              }
              /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
              function baseMap(collection, iteratee) {
                var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                baseEach(collection, function (value, key, collection) {
                  result[++index] = iteratee(value, key, collection);
                });
                return result;
              }
              /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
              function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function (object) {
                  return object === source || baseIsMatch(object, source, matchData);
                };
              }
              /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
              function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                  return matchesStrictComparable(toKey(path), srcValue);
                }
                return function (object) {
                  var objValue = get(object, path);
                  return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
                };
              }
              /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
              function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                  return;
                }
                if (!(isArray(source) || isTypedArray(source))) {
                  var props = baseKeysIn(source);
                }
                arrayEach(props || source, function (srcValue, key) {
                  if (props) {
                    key = srcValue;
                    srcValue = source[key];
                  }
                  if (isObject(srcValue)) {
                    stack || (stack = new Stack());
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                  } else {
                    var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;
                    if (newValue === undefined) {
                      newValue = srcValue;
                    }
                    assignMergeValue(object, key, newValue);
                  }
                });
              }
              /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
              function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
                if (stacked) {
                  assignMergeValue(object, key, stacked);
                  return;
                }
                var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
                var isCommon = newValue === undefined;
                if (isCommon) {
                  newValue = srcValue;
                  if (isArray(srcValue) || isTypedArray(srcValue)) {
                    if (isArray(objValue)) {
                      newValue = objValue;
                    } else if (isArrayLikeObject(objValue)) {
                      newValue = copyArray(objValue);
                    } else {
                      isCommon = false;
                      newValue = baseClone(srcValue, true);
                    }
                  } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    if (isArguments(objValue)) {
                      newValue = toPlainObject(objValue);
                    } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
                      isCommon = false;
                      newValue = baseClone(srcValue, true);
                    } else {
                      newValue = objValue;
                    }
                  } else {
                    isCommon = false;
                  }
                }
                if (isCommon) {
                  // Recursively merge objects and arrays (susceptible to call stack limits).
                  stack.set(srcValue, newValue);
                  mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                  stack['delete'](srcValue);
                }
                assignMergeValue(object, key, newValue);
              }
              /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
              function baseNth(array, n) {
                var length = array.length;
                if (!length) {
                  return;
                }
                n += n < 0 ? length : 0;
                return isIndex(n, length) ? array[n] : undefined;
              }
              /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
              function baseOrderBy(collection, iteratees, orders) {
                var index = -1;
                iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
                var result = baseMap(collection, function (value, key, collection) {
                    var criteria = arrayMap(iteratees, function (iteratee) {
                        return iteratee(value);
                      });
                    return {
                      'criteria': criteria,
                      'index': ++index,
                      'value': value
                    };
                  });
                return baseSortBy(result, function (object, other) {
                  return compareMultiple(object, other, orders);
                });
              }
              /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property identifiers to pick.
     * @returns {Object} Returns the new object.
     */
              function basePick(object, props) {
                object = Object(object);
                return basePickBy(object, props, function (value, key) {
                  return key in object;
                });
              }
              /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property identifiers to pick from.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
              function basePickBy(object, props, predicate) {
                var index = -1, length = props.length, result = {};
                while (++index < length) {
                  var key = props[index], value = object[key];
                  if (predicate(value, key)) {
                    baseAssignValue(result, key, value);
                  }
                }
                return result;
              }
              /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
              function basePropertyDeep(path) {
                return function (object) {
                  return baseGet(object, path);
                };
              }
              /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
              function basePullAll(array, values, iteratee, comparator) {
                var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
                if (array === values) {
                  values = copyArray(values);
                }
                if (iteratee) {
                  seen = arrayMap(array, baseUnary(iteratee));
                }
                while (++index < length) {
                  var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                  while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                    if (seen !== array) {
                      splice.call(seen, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                  }
                }
                return array;
              }
              /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
              function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0, lastIndex = length - 1;
                while (length--) {
                  var index = indexes[length];
                  if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex(index)) {
                      splice.call(array, index, 1);
                    } else if (!isKey(index, array)) {
                      var path = castPath(index), object = parent(array, path);
                      if (object != null) {
                        delete object[toKey(last(path))];
                      }
                    } else {
                      delete array[toKey(index)];
                    }
                  }
                }
                return array;
              }
              /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
              function baseRandom(lower, upper) {
                return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
              }
              /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
              function baseRange(start, end, step, fromRight) {
                var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                while (length--) {
                  result[fromRight ? length : ++index] = start;
                  start += step;
                }
                return result;
              }
              /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
              function baseRepeat(string, n) {
                var result = '';
                if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                  return result;
                }
                // Leverage the exponentiation by squaring algorithm for a faster repeat.
                // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                do {
                  if (n % 2) {
                    result += string;
                  }
                  n = nativeFloor(n / 2);
                  if (n) {
                    string += string;
                  }
                } while (n);
                return result;
              }
              /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + '');
              }
              /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
              function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                  return object;
                }
                path = isKey(path, object) ? [path] : castPath(path);
                var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                while (nested != null && ++index < length) {
                  var key = toKey(path[index]), newValue = value;
                  if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                    if (newValue === undefined) {
                      newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                    }
                  }
                  assignValue(nested, key, newValue);
                  nested = nested[key];
                }
                return object;
              }
              /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
              var baseSetData = !metaMap ? identity : function (func, data) {
                  metaMap.set(func, data);
                  return func;
                };
              /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
              var baseSetToString = !nativeDefineProperty ? identity : function (func, string) {
                  return nativeDefineProperty(func, 'toString', {
                    'configurable': true,
                    'enumerable': false,
                    'value': constant(string),
                    'writable': true
                  });
                };
              /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
              function baseSlice(array, start, end) {
                var index = -1, length = array.length;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;
                var result = Array(length);
                while (++index < length) {
                  result[index] = array[index + start];
                }
                return result;
              }
              /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
              function baseSome(collection, predicate) {
                var result;
                baseEach(collection, function (value, index, collection) {
                  result = predicate(value, index, collection);
                  return !result;
                });
                return !!result;
              }
              /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
              function baseSortedIndex(array, value, retHighest) {
                var low = 0, high = array ? array.length : low;
                if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                  while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return baseSortedIndexBy(array, value, identity, retHighest);
              }
              /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
              function baseSortedIndexBy(array, value, iteratee, retHighest) {
                value = iteratee(value);
                var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
                while (low < high) {
                  var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                  if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                  } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                  } else if (valIsNull) {
                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                  } else if (valIsSymbol) {
                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                  } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                  } else {
                    setLow = retHighest ? computed <= value : computed < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
              }
              /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
              function baseSortedUniq(array, iteratee) {
                var index = -1, length = array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index], computed = iteratee ? iteratee(value) : value;
                  if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = value === 0 ? 0 : value;
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
              function baseToNumber(value) {
                if (typeof value == 'number') {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                return +value;
              }
              /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
              function baseToString(value) {
                // Exit early for strings to avoid a performance hit in some environments.
                if (typeof value == 'string') {
                  return value;
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : '';
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
              }
              /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
              function baseUniq(array, iteratee, comparator) {
                var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
                if (comparator) {
                  isCommon = false;
                  includes = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE) {
                  var set = iteratee ? null : createSet(array);
                  if (set) {
                    return setToArray(set);
                  }
                  isCommon = false;
                  includes = cacheHas;
                  seen = new SetCache();
                } else {
                  seen = iteratee ? [] : result;
                }
                outer:
                  while (++index < length) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var seenIndex = seen.length;
                      while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                          continue outer;
                        }
                      }
                      if (iteratee) {
                        seen.push(computed);
                      }
                      result.push(value);
                    } else if (!includes(seen, computed, comparator)) {
                      if (seen !== result) {
                        seen.push(computed);
                      }
                      result.push(value);
                    }
                  }
                return result;
              }
              /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
              function baseUnset(object, path) {
                path = isKey(path, object) ? [path] : castPath(path);
                object = parent(object, path);
                var key = toKey(last(path));
                return !(object != null && hasOwnProperty.call(object, key)) || delete object[key];
              }
              /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
              function baseUpdate(object, path, updater, customizer) {
                return baseSet(object, path, updater(baseGet(object, path)), customizer);
              }
              /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
              function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length, index = fromRight ? length : -1;
                while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                }
                return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
              }
              /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
              function baseWrapperValue(value, actions) {
                var result = value;
                if (result instanceof LazyWrapper) {
                  result = result.value();
                }
                return arrayReduce(actions, function (result, action) {
                  return action.func.apply(action.thisArg, arrayPush([result], action.args));
                }, result);
              }
              /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
              function baseXor(arrays, iteratee, comparator) {
                var index = -1, length = arrays.length;
                while (++index < length) {
                  var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
                }
                return result && result.length ? baseUniq(result, iteratee, comparator) : [];
              }
              /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
              function baseZipObject(props, values, assignFunc) {
                var index = -1, length = props.length, valsLength = values.length, result = {};
                while (++index < length) {
                  var value = index < valsLength ? values[index] : undefined;
                  assignFunc(result, props[index], value);
                }
                return result;
              }
              /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
              function castArrayLikeObject(value) {
                return isArrayLikeObject(value) ? value : [];
              }
              /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
              function castFunction(value) {
                return typeof value == 'function' ? value : identity;
              }
              /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */
              function castPath(value) {
                return isArray(value) ? value : stringToPath(value);
              }
              /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
              var castRest = baseRest;
              /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
              function castSlice(array, start, end) {
                var length = array.length;
                end = end === undefined ? length : end;
                return !start && end >= length ? array : baseSlice(array, start, end);
              }
              /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
              var clearTimeout = ctxClearTimeout || function (id) {
                  return root.clearTimeout(id);
                };
              /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
              function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var result = new buffer.constructor(buffer.length);
                buffer.copy(result);
                return result;
              }
              /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
              function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                return result;
              }
              /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
              function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
              }
              /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */
              function cloneMap(map, isDeep, cloneFunc) {
                var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
                return arrayReduce(array, addMapEntry, new map.constructor());
              }
              /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
              function cloneRegExp(regexp) {
                var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result.lastIndex = regexp.lastIndex;
                return result;
              }
              /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */
              function cloneSet(set, isDeep, cloneFunc) {
                var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
                return arrayReduce(array, addSetEntry, new set.constructor());
              }
              /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
              function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
              }
              /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
              function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
              }
              /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
              function compareAscending(value, other) {
                if (value !== other) {
                  var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                  var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                  if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                    return 1;
                  }
                  if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                    return -1;
                  }
                }
                return 0;
              }
              /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
              function compareMultiple(object, other, orders) {
                var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                while (++index < length) {
                  var result = compareAscending(objCriteria[index], othCriteria[index]);
                  if (result) {
                    if (index >= ordersLength) {
                      return result;
                    }
                    var order = orders[index];
                    return result * (order == 'desc' ? -1 : 1);
                  }
                }
                // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                // that causes it, under certain circumstances, to provide the same value for
                // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                // for more details.
                //
                // This also ensures a stable sort in V8 and other engines.
                // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                return object.index - other.index;
              }
              /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
              function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
                while (++leftIndex < leftLength) {
                  result[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[holders[argsIndex]] = args[argsIndex];
                  }
                }
                while (rangeLength--) {
                  result[leftIndex++] = args[argsIndex++];
                }
                return result;
              }
              /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
              function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
                while (++argsIndex < rangeLength) {
                  result[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                  result[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                  }
                }
                return result;
              }
              /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
              function copyArray(source, array) {
                var index = -1, length = source.length;
                array || (array = Array(length));
                while (++index < length) {
                  array[index] = source[index];
                }
                return array;
              }
              /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
              function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index = -1, length = props.length;
                while (++index < length) {
                  var key = props[index];
                  var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                  if (newValue === undefined) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue(object, key, newValue);
                  } else {
                    assignValue(object, key, newValue);
                  }
                }
                return object;
              }
              /**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
              function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
              }
              /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
              function createAggregator(setter, initializer) {
                return function (collection, iteratee) {
                  var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                  return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                };
              }
              /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
              function createAssigner(assigner) {
                return baseRest(function (object, sources) {
                  var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                  customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                  }
                  object = Object(object);
                  while (++index < length) {
                    var source = sources[index];
                    if (source) {
                      assigner(object, source, index, customizer);
                    }
                  }
                  return object;
                });
              }
              /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
              function createBaseEach(eachFunc, fromRight) {
                return function (collection, iteratee) {
                  if (collection == null) {
                    return collection;
                  }
                  if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee);
                  }
                  var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                  while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }
              /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
              function createBaseFor(fromRight) {
                return function (object, iteratee, keysFunc) {
                  var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                  while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }
              /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return fn.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
              }
              /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
              function createCaseFirst(methodName) {
                return function (string) {
                  string = toString(string);
                  var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
                  var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                  var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
                  return chr[methodName]() + trailing;
                };
              }
              /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
              function createCompounder(callback) {
                return function (string) {
                  return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                };
              }
              /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
              function createCtor(Ctor) {
                return function () {
                  // Use a `switch` statement to work with class constructors. See
                  // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                  // for more details.
                  var args = arguments;
                  switch (args.length) {
                  case 0:
                    return new Ctor();
                  case 1:
                    return new Ctor(args[0]);
                  case 2:
                    return new Ctor(args[0], args[1]);
                  case 3:
                    return new Ctor(args[0], args[1], args[2]);
                  case 4:
                    return new Ctor(args[0], args[1], args[2], args[3]);
                  case 5:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                  case 6:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                  case 7:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                  }
                  var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                  // Mimic the constructor's `return` behavior.
                  // See https://es5.github.io/#x13.2.2 for more details.
                  return isObject(result) ? result : thisBinding;
                };
              }
              /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                  length -= holders.length;
                  if (length < arity) {
                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                  }
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return apply(fn, this, args);
                }
                return wrapper;
              }
              /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
              function createFind(findIndexFunc) {
                return function (collection, predicate, fromIndex) {
                  var iterable = Object(collection);
                  if (!isArrayLike(collection)) {
                    var iteratee = getIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function (key) {
                      return iteratee(iterable[key], key, iterable);
                    };
                  }
                  var index = findIndexFunc(collection, predicate, fromIndex);
                  return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                };
              }
              /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
              function createFlow(fromRight) {
                return flatRest(function (funcs) {
                  var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                  if (fromRight) {
                    funcs.reverse();
                  }
                  while (index--) {
                    var func = funcs[index];
                    if (typeof func != 'function') {
                      throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                      var wrapper = new LodashWrapper([], true);
                    }
                  }
                  index = wrapper ? index : length;
                  while (++index < length) {
                    func = funcs[index];
                    var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;
                    if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                      wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                      wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                  }
                  return function () {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                      return wrapper.plant(value).value();
                    }
                    var index = 0, result = length ? funcs[index].apply(this, args) : value;
                    while (++index < length) {
                      result = funcs[index].call(this, result);
                    }
                    return result;
                  };
                });
              }
              /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array(length), index = length;
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  if (isCurried) {
                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                  }
                  if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                  }
                  if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                  }
                  length -= holdersCount;
                  if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                  }
                  var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                  length = args.length;
                  if (argPos) {
                    args = reorder(args, argPos);
                  } else if (isFlip && length > 1) {
                    args.reverse();
                  }
                  if (isAry && ary < length) {
                    args.length = ary;
                  }
                  if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtor(fn);
                  }
                  return fn.apply(thisBinding, args);
                }
                return wrapper;
              }
              /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
              function createInverter(setter, toIteratee) {
                return function (object, iteratee) {
                  return baseInverter(object, setter, toIteratee(iteratee), {});
                };
              }
              /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
              function createMathOperation(operator, defaultValue) {
                return function (value, other) {
                  var result;
                  if (value === undefined && other === undefined) {
                    return defaultValue;
                  }
                  if (value !== undefined) {
                    result = value;
                  }
                  if (other !== undefined) {
                    if (result === undefined) {
                      return other;
                    }
                    if (typeof value == 'string' || typeof other == 'string') {
                      value = baseToString(value);
                      other = baseToString(other);
                    } else {
                      value = baseToNumber(value);
                      other = baseToNumber(other);
                    }
                    result = operator(value, other);
                  }
                  return result;
                };
              }
              /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
              function createOver(arrayFunc) {
                return flatRest(function (iteratees) {
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  return baseRest(function (args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function (iteratee) {
                      return apply(iteratee, thisArg, args);
                    });
                  });
                });
              }
              /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
              function createPadding(length, chars) {
                chars = chars === undefined ? ' ' : baseToString(chars);
                var charsLength = chars.length;
                if (charsLength < 2) {
                  return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
              }
              /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
              function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                  }
                  while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                  }
                  return apply(fn, isBind ? thisArg : this, args);
                }
                return wrapper;
              }
              /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
              function createRange(fromRight) {
                return function (start, end, step) {
                  if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                    end = step = undefined;
                  }
                  // Ensure the sign of `-0` is preserved.
                  start = toFinite(start);
                  if (end === undefined) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
                  return baseRange(start, end, step, fromRight);
                };
              }
              /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
              function createRelationalOperation(operator) {
                return function (value, other) {
                  if (!(typeof value == 'string' && typeof other == 'string')) {
                    value = toNumber(value);
                    other = toNumber(other);
                  }
                  return operator(value, other);
                };
              }
              /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
                bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!(bitmask & CURRY_BOUND_FLAG)) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [
                    func,
                    bitmask,
                    thisArg,
                    newPartials,
                    newHolders,
                    newPartialsRight,
                    newHoldersRight,
                    argPos,
                    ary,
                    arity
                  ];
                var result = wrapFunc.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return setWrapToString(result, func, bitmask);
              }
              /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
              function createRound(methodName) {
                var func = Math[methodName];
                return function (number, precision) {
                  number = toNumber(number);
                  precision = nativeMin(toInteger(precision), 292);
                  if (precision) {
                    // Shift with exponential notation to avoid floating-point issues.
                    // See [MDN](https://mdn.io/round#Examples) for more details.
                    var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
                    pair = (toString(value) + 'e').split('e');
                    return +(pair[0] + 'e' + (+pair[1] - precision));
                  }
                  return func(number);
                };
              }
              /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
              var createSet = !(Set && 1 / setToArray(new Set([
                  ,
                  -0
                ]))[1] == INFINITY) ? noop : function (values) {
                  return new Set(values);
                };
              /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
              function createToPairs(keysFunc) {
                return function (object) {
                  var tag = getTag(object);
                  if (tag == mapTag) {
                    return mapToArray(object);
                  }
                  if (tag == setTag) {
                    return setToPairs(object);
                  }
                  return baseToPairs(object, keysFunc(object));
                };
              }
              /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     *   512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                var isBindKey = bitmask & BIND_KEY_FLAG;
                if (!isBindKey && typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                  bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                  partials = holders = undefined;
                }
                ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                arity = arity === undefined ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;
                if (bitmask & PARTIAL_RIGHT_FLAG) {
                  var partialsRight = partials, holdersRight = holders;
                  partials = holders = undefined;
                }
                var data = isBindKey ? undefined : getData(func);
                var newData = [
                    func,
                    bitmask,
                    thisArg,
                    partials,
                    holders,
                    partialsRight,
                    holdersRight,
                    argPos,
                    ary,
                    arity
                  ];
                if (data) {
                  mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
                  bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
                }
                if (!bitmask || bitmask == BIND_FLAG) {
                  var result = createBind(func, bitmask, thisArg);
                } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
                  result = createCurry(func, bitmask, arity);
                } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
                  result = createPartial(func, bitmask, thisArg, partials);
                } else {
                  result = createHybrid.apply(undefined, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result, newData), func, bitmask);
              }
              /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
              function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
                stack.set(array, other);
                stack.set(other, array);
                // Ignore non-index properties.
                while (++index < arrLength) {
                  var arrValue = array[index], othValue = other[index];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                  }
                  if (compared !== undefined) {
                    if (compared) {
                      continue;
                    }
                    result = false;
                    break;
                  }
                  // Recursively compare arrays (susceptible to call stack limits).
                  if (seen) {
                    if (!arraySome(other, function (othValue, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                          return seen.push(othIndex);
                        }
                      })) {
                      result = false;
                      break;
                    }
                  } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                    result = false;
                    break;
                  }
                }
                stack['delete'](array);
                stack['delete'](other);
                return result;
              }
              /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
              function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
                switch (tag) {
                case dataViewTag:
                  if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                    return false;
                  }
                  object = object.buffer;
                  other = other.buffer;
                case arrayBufferTag:
                  if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                    return false;
                  }
                  return true;
                case boolTag:
                case dateTag:
                case numberTag:
                  // Coerce booleans to `1` or `0` and dates to milliseconds.
                  // Invalid dates are coerced to `NaN`.
                  return eq(+object, +other);
                case errorTag:
                  return object.name == other.name && object.message == other.message;
                case regexpTag:
                case stringTag:
                  // Coerce regexes to strings and treat strings, primitives and objects,
                  // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                  // for more details.
                  return object == other + '';
                case mapTag:
                  var convert = mapToArray;
                case setTag:
                  var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                  convert || (convert = setToArray);
                  if (object.size != other.size && !isPartial) {
                    return false;
                  }
                  // Assume cyclic values are equal.
                  var stacked = stack.get(object);
                  if (stacked) {
                    return stacked == other;
                  }
                  bitmask |= UNORDERED_COMPARE_FLAG;
                  // Recursively compare objects (susceptible to call stack limits).
                  stack.set(object, other);
                  var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
                  stack['delete'](object);
                  return result;
                case symbolTag:
                  if (symbolValueOf) {
                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                  }
                }
                return false;
              }
              /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
              function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index = objLength;
                while (index--) {
                  var key = objProps[index];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                  }
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                  key = objProps[index];
                  var objValue = object[key], othValue = other[key];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                  }
                  // Recursively compare objects (susceptible to call stack limits).
                  if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
                    result = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == 'constructor');
                }
                if (result && !skipCtor) {
                  var objCtor = object.constructor, othCtor = other.constructor;
                  // Non `Object` object instances with different constructors are not equal.
                  if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    result = false;
                  }
                }
                stack['delete'](object);
                stack['delete'](other);
                return result;
              }
              /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
              function flatRest(func) {
                return setToString(overRest(func, undefined, flatten), func + '');
              }
              /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
              function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
              }
              /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
              var getData = !metaMap ? noop : function (func) {
                  return metaMap.get(func);
                };
              /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
              function getFuncName(func) {
                var result = func.name + '', array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
                while (length--) {
                  var data = array[length], otherFunc = data.func;
                  if (otherFunc == null || otherFunc == func) {
                    return data.name;
                  }
                }
                return result;
              }
              /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
              function getHolder(func) {
                var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                return object.placeholder;
              }
              /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
              function getIteratee() {
                var result = lodash.iteratee || iteratee;
                result = result === iteratee ? baseIteratee : result;
                return arguments.length ? result(arguments[0], arguments[1]) : result;
              }
              /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
              function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
              }
              /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
              function getMatchData(object) {
                var result = keys(object), length = result.length;
                while (length--) {
                  var key = result[length], value = object[key];
                  result[length] = [
                    key,
                    value,
                    isStrictComparable(value)
                  ];
                }
                return result;
              }
              /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined;
              }
              /**
     * Creates an array of the own enumerable symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
              var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
              /**
     * Creates an array of the own and inherited enumerable symbol properties
     * of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
              var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
                  var result = [];
                  while (object) {
                    arrayPush(result, getSymbols(object));
                    object = getPrototype(object);
                  }
                  return result;
                };
              /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
              var getTag = baseGetTag;
              // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
              if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
                getTag = function (value) {
                  var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
                  if (ctorString) {
                    switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                    }
                  }
                  return result;
                };
              }
              /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
              function getView(start, end, transforms) {
                var index = -1, length = transforms.length;
                while (++index < length) {
                  var data = transforms[index], size = data.size;
                  switch (data.type) {
                  case 'drop':
                    start += size;
                    break;
                  case 'dropRight':
                    end -= size;
                    break;
                  case 'take':
                    end = nativeMin(end, start + size);
                    break;
                  case 'takeRight':
                    start = nativeMax(start, end - size);
                    break;
                  }
                }
                return {
                  'start': start,
                  'end': end
                };
              }
              /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
              function getWrapDetails(source) {
                var match = source.match(reWrapDetails);
                return match ? match[1].split(reSplitDetails) : [];
              }
              /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
              function hasPath(object, path, hasFunc) {
                path = isKey(path, object) ? [path] : castPath(path);
                var index = -1, length = path.length, result = false;
                while (++index < length) {
                  var key = toKey(path[index]);
                  if (!(result = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result || ++index != length) {
                  return result;
                }
                length = object ? object.length : 0;
                return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
              }
              /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
              function initCloneArray(array) {
                var length = array.length, result = array.constructor(length);
                // Add properties assigned by `RegExp#exec`.
                if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                  result.index = array.index;
                  result.input = array.input;
                }
                return result;
              }
              /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
              function initCloneObject(object) {
                return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
              }
              /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
              function initCloneByTag(object, tag, cloneFunc, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                case arrayBufferTag:
                  return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                  return new Ctor(+object);
                case dataViewTag:
                  return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                  return cloneTypedArray(object, isDeep);
                case mapTag:
                  return cloneMap(object, isDeep, cloneFunc);
                case numberTag:
                case stringTag:
                  return new Ctor(object);
                case regexpTag:
                  return cloneRegExp(object);
                case setTag:
                  return cloneSet(object, isDeep, cloneFunc);
                case symbolTag:
                  return cloneSymbol(object);
                }
              }
              /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
              function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                  return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
                details = details.join(length > 2 ? ', ' : ' ');
                return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
              }
              /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
              function isFlattenable(value) {
                return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
              }
              /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
              function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
              }
              /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
              function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index;
                if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
                  return eq(object[index], value);
                }
                return false;
              }
              /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
              function isKey(value, object) {
                if (isArray(value)) {
                  return false;
                }
                var type = typeof value;
                if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
                  return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
              }
              /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
              function isKeyable(value) {
                var type = typeof value;
                return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
              }
              /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
              function isLaziable(func) {
                var funcName = getFuncName(func), other = lodash[funcName];
                if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                  return false;
                }
                if (func === other) {
                  return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
              }
              /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
              var isMaskable = coreJsData ? isFunction : stubFalse;
              /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
              function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
                return value === proto;
              }
              /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
              function isStrictComparable(value) {
                return value === value && !isObject(value);
              }
              /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
              function matchesStrictComparable(key, srcValue) {
                return function (object) {
                  if (object == null) {
                    return false;
                  }
                  return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
                };
              }
              /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
              function memoizeCapped(func) {
                var result = memoize(func, function (key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                      cache.clear();
                    }
                    return key;
                  });
                var cache = result.cache;
                return result;
              }
              /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
              function mergeData(data, source) {
                var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
                var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && source[7].length <= source[8] && bitmask == CURRY_FLAG;
                // Exit early if metadata can't be merged.
                if (!(isCommon || isCombo)) {
                  return data;
                }
                // Use source `thisArg` if available.
                if (srcBitmask & BIND_FLAG) {
                  data[2] = source[2];
                  // Set when currying a bound function.
                  newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
                }
                // Compose partial arguments.
                var value = source[3];
                if (value) {
                  var partials = data[3];
                  data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                  data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                }
                // Compose partial right arguments.
                value = source[5];
                if (value) {
                  partials = data[5];
                  data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                  data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                }
                // Use source `argPos` if available.
                value = source[7];
                if (value) {
                  data[7] = value;
                }
                // Use source `ary` if it's smaller.
                if (srcBitmask & ARY_FLAG) {
                  data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                }
                // Use source `arity` if one is not provided.
                if (data[9] == null) {
                  data[9] = source[9];
                }
                // Use source `func` and merge bitmasks.
                data[0] = source[0];
                data[1] = newBitmask;
                return data;
              }
              /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
              function mergeDefaults(objValue, srcValue, key, object, source, stack) {
                if (isObject(objValue) && isObject(srcValue)) {
                  // Recursively merge objects and arrays (susceptible to call stack limits).
                  stack.set(srcValue, objValue);
                  baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
                  stack['delete'](srcValue);
                }
                return objValue;
              }
              /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
              function nativeKeysIn(object) {
                var result = [];
                if (object != null) {
                  for (var key in Object(object)) {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
              function overRest(func, start, transform) {
                start = nativeMax(start === undefined ? func.length - 1 : start, 0);
                return function () {
                  var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                  while (++index < length) {
                    array[index] = args[start + index];
                  }
                  index = -1;
                  var otherArgs = Array(start + 1);
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = transform(array);
                  return apply(func, this, otherArgs);
                };
              }
              /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
              function parent(object, path) {
                return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              }
              /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
              function reorder(array, indexes) {
                var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                while (length--) {
                  var index = indexes[length];
                  array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                }
                return array;
              }
              /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
              var setData = shortOut(baseSetData);
              /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
              var setTimeout = ctxSetTimeout || function (func, wait) {
                  return root.setTimeout(func, wait);
                };
              /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
              var setToString = shortOut(baseSetToString);
              /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
              function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + '';
                return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
              }
              /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
              function shortOut(func) {
                var count = 0, lastCalled = 0;
                return function () {
                  var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(undefined, arguments);
                };
              }
              /**
     * A specialized version of `arrayShuffle` which mutates `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns `array`.
     */
              function shuffleSelf(array) {
                var index = -1, length = array.length, lastIndex = length - 1;
                while (++index < length) {
                  var rand = baseRandom(index, lastIndex), value = array[rand];
                  array[rand] = array[index];
                  array[index] = value;
                }
                return array;
              }
              /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
              var stringToPath = memoizeCapped(function (string) {
                  string = toString(string);
                  var result = [];
                  if (reLeadingDot.test(string)) {
                    result.push('');
                  }
                  string.replace(rePropName, function (match, number, quote, string) {
                    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
                  });
                  return result;
                });
              /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
              function toKey(value) {
                if (typeof value == 'string' || isSymbol(value)) {
                  return value;
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
              }
              /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + '';
                  } catch (e) {
                  }
                }
                return '';
              }
              /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
              function updateWrapDetails(details, bitmask) {
                arrayEach(wrapFlags, function (pair) {
                  var value = '_.' + pair[0];
                  if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                    details.push(value);
                  }
                });
                return details.sort();
              }
              /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
              function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                  return wrapper.clone();
                }
                var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                result.__actions__ = copyArray(wrapper.__actions__);
                result.__index__ = wrapper.__index__;
                result.__values__ = wrapper.__values__;
                return result;
              }
              /*------------------------------------------------------------------------*/
              /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
              function chunk(array, size, guard) {
                if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
                  size = 1;
                } else {
                  size = nativeMax(toInteger(size), 0);
                }
                var length = array ? array.length : 0;
                if (!length || size < 1) {
                  return [];
                }
                var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
                while (index < length) {
                  result[resIndex++] = baseSlice(array, index, index += size);
                }
                return result;
              }
              /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
              function compact(array) {
                var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (value) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
              function concat() {
                var length = arguments.length;
                if (!length) {
                  return [];
                }
                var args = Array(length - 1), array = arguments[0], index = length;
                while (index--) {
                  args[index - 1] = arguments[index];
                }
                return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
              }
              /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
              var difference = baseRest(function (array, values) {
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
                });
              /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
              var differenceBy = baseRest(function (array, values) {
                  var iteratee = last(values);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
                });
              /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
              var differenceWith = baseRest(function (array, values) {
                  var comparator = last(values);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
                });
              /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
              function drop(array, n, guard) {
                var length = array ? array.length : 0;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
              function dropRight(array, n, guard) {
                var length = array ? array.length : 0;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
              function dropRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
              }
              /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
              function dropWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
              }
              /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
              function fill(array, value, start, end) {
                var length = array ? array.length : 0;
                if (!length) {
                  return [];
                }
                if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                  start = 0;
                  end = length;
                }
                return baseFill(array, value, start, end);
              }
              /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
              function findIndex(array, predicate, fromIndex) {
                var length = array ? array.length : 0;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index);
              }
              /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
              function findLastIndex(array, predicate, fromIndex) {
                var length = array ? array.length : 0;
                if (!length) {
                  return -1;
                }
                var index = length - 1;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index, true);
              }
              /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
              function flatten(array) {
                var length = array ? array.length : 0;
                return length ? baseFlatten(array, 1) : [];
              }
              /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
              function flattenDeep(array) {
                var length = array ? array.length : 0;
                return length ? baseFlatten(array, INFINITY) : [];
              }
              /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
              function flattenDepth(array, depth) {
                var length = array ? array.length : 0;
                if (!length) {
                  return [];
                }
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
              }
              /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
              function fromPairs(pairs) {
                var index = -1, length = pairs ? pairs.length : 0, result = {};
                while (++index < length) {
                  var pair = pairs[index];
                  result[pair[0]] = pair[1];
                }
                return result;
              }
              /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
              function head(array) {
                return array && array.length ? array[0] : undefined;
              }
              /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
              function indexOf(array, value, fromIndex) {
                var length = array ? array.length : 0;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseIndexOf(array, value, index);
              }
              /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
              function initial(array) {
                var length = array ? array.length : 0;
                return length ? baseSlice(array, 0, -1) : [];
              }
              /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
              var intersection = baseRest(function (arrays) {
                  var mapped = arrayMap(arrays, castArrayLikeObject);
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                });
              /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
              var intersectionBy = baseRest(function (arrays) {
                  var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  if (iteratee === last(mapped)) {
                    iteratee = undefined;
                  } else {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
                });
              /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
              var intersectionWith = baseRest(function (arrays) {
                  var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  if (comparator === last(mapped)) {
                    comparator = undefined;
                  } else {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
                });
              /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
              function join(array, separator) {
                return array ? nativeJoin.call(array, separator) : '';
              }
              /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
              function last(array) {
                var length = array ? array.length : 0;
                return length ? array[length - 1] : undefined;
              }
              /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
              function lastIndexOf(array, value, fromIndex) {
                var length = array ? array.length : 0;
                if (!length) {
                  return -1;
                }
                var index = length;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                }
                return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
              }
              /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
              function nth(array, n) {
                return array && array.length ? baseNth(array, toInteger(n)) : undefined;
              }
              /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
              var pull = baseRest(pullAll);
              /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
              function pullAll(array, values) {
                return array && array.length && values && values.length ? basePullAll(array, values) : array;
              }
              /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
              function pullAllBy(array, values, iteratee) {
                return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
              }
              /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
              function pullAllWith(array, values, comparator) {
                return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
              }
              /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
              var pullAt = flatRest(function (array, indexes) {
                  var length = array ? array.length : 0, result = baseAt(array, indexes);
                  basePullAt(array, arrayMap(indexes, function (index) {
                    return isIndex(index, length) ? +index : index;
                  }).sort(compareAscending));
                  return result;
                });
              /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
              function remove(array, predicate) {
                var result = [];
                if (!(array && array.length)) {
                  return result;
                }
                var index = -1, indexes = [], length = array.length;
                predicate = getIteratee(predicate, 3);
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                  }
                }
                basePullAt(array, indexes);
                return result;
              }
              /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
              function reverse(array) {
                return array ? nativeReverse.call(array) : array;
              }
              /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
              function slice(array, start, end) {
                var length = array ? array.length : 0;
                if (!length) {
                  return [];
                }
                if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                  start = 0;
                  end = length;
                } else {
                  start = start == null ? 0 : toInteger(start);
                  end = end === undefined ? length : toInteger(end);
                }
                return baseSlice(array, start, end);
              }
              /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
              function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
              }
              /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
              function sortedIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
              }
              /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
              function sortedIndexOf(array, value) {
                var length = array ? array.length : 0;
                if (length) {
                  var index = baseSortedIndex(array, value);
                  if (index < length && eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
              function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
              }
              /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
              function sortedLastIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
              }
              /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
              function sortedLastIndexOf(array, value) {
                var length = array ? array.length : 0;
                if (length) {
                  var index = baseSortedIndex(array, value, true) - 1;
                  if (eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
              function sortedUniq(array) {
                return array && array.length ? baseSortedUniq(array) : [];
              }
              /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
              function sortedUniqBy(array, iteratee) {
                return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
              }
              /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
              function tail(array) {
                var length = array ? array.length : 0;
                return length ? baseSlice(array, 1, length) : [];
              }
              /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
              function take(array, n, guard) {
                if (!(array && array.length)) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
              function takeRight(array, n, guard) {
                var length = array ? array.length : 0;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
              function takeRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
              }
              /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
              function takeWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
              }
              /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
              var union = baseRest(function (arrays) {
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                });
              /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
              var unionBy = baseRest(function (arrays) {
                  var iteratee = last(arrays);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
                });
              /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
              var unionWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined;
                  }
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
                });
              /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
              function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
              }
              /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
              function uniqBy(array, iteratee) {
                return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
              }
              /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
              function uniqWith(array, comparator) {
                return array && array.length ? baseUniq(array, undefined, comparator) : [];
              }
              /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
              function unzip(array) {
                if (!(array && array.length)) {
                  return [];
                }
                var length = 0;
                array = arrayFilter(array, function (group) {
                  if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                  }
                });
                return baseTimes(length, function (index) {
                  return arrayMap(array, baseProperty(index));
                });
              }
              /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
              function unzipWith(array, iteratee) {
                if (!(array && array.length)) {
                  return [];
                }
                var result = unzip(array);
                if (iteratee == null) {
                  return result;
                }
                return arrayMap(result, function (group) {
                  return apply(iteratee, undefined, group);
                });
              }
              /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
              var without = baseRest(function (array, values) {
                  return isArrayLikeObject(array) ? baseDifference(array, values) : [];
                });
              /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
              var xor = baseRest(function (arrays) {
                  return baseXor(arrayFilter(arrays, isArrayLikeObject));
                });
              /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
              var xorBy = baseRest(function (arrays) {
                  var iteratee = last(arrays);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                });
              /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
              var xorWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined;
                  }
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                });
              /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
              var zip = baseRest(unzip);
              /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
              function zipObject(props, values) {
                return baseZipObject(props || [], values || [], assignValue);
              }
              /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
              function zipObjectDeep(props, values) {
                return baseZipObject(props || [], values || [], baseSet);
              }
              /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
              var zipWith = baseRest(function (arrays) {
                  var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
                  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
                  return unzipWith(arrays, iteratee);
                });
              /*------------------------------------------------------------------------*/
              /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
              function chain(value) {
                var result = lodash(value);
                result.__chain__ = true;
                return result;
              }
              /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
              function tap(value, interceptor) {
                interceptor(value);
                return value;
              }
              /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
              function thru(value, interceptor) {
                return interceptor(value);
              }
              /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths of elements to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
              var wrapperAt = flatRest(function (paths) {
                  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) {
                      return baseAt(object, paths);
                    };
                  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                    return this.thru(interceptor);
                  }
                  value = value.slice(start, +start + (length ? 1 : 0));
                  value.__actions__.push({
                    'func': thru,
                    'args': [interceptor],
                    'thisArg': undefined
                  });
                  return new LodashWrapper(value, this.__chain__).thru(function (array) {
                    if (length && !array.length) {
                      array.push(undefined);
                    }
                    return array;
                  });
                });
              /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
              function wrapperChain() {
                return chain(this);
              }
              /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
              function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
              }
              /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
              function wrapperNext() {
                if (this.__values__ === undefined) {
                  this.__values__ = toArray(this.value());
                }
                var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
                return {
                  'done': done,
                  'value': value
                };
              }
              /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
              function wrapperToIterator() {
                return this;
              }
              /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
              function wrapperPlant(value) {
                var result, parent = this;
                while (parent instanceof baseLodash) {
                  var clone = wrapperClone(parent);
                  clone.__index__ = 0;
                  clone.__values__ = undefined;
                  if (result) {
                    previous.__wrapped__ = clone;
                  } else {
                    result = clone;
                  }
                  var previous = clone;
                  parent = parent.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result;
              }
              /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
              function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                  var wrapped = value;
                  if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                  }
                  wrapped = wrapped.reverse();
                  wrapped.__actions__.push({
                    'func': thru,
                    'args': [reverse],
                    'thisArg': undefined
                  });
                  return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
              }
              /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
              function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
              var countBy = createAggregator(function (result, value, key) {
                  if (hasOwnProperty.call(result, key)) {
                    ++result[key];
                  } else {
                    baseAssignValue(result, key, 1);
                  }
                });
              /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
              function every(collection, predicate, guard) {
                var func = isArray(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
              function filter(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, getIteratee(predicate, 3));
              }
              /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
              var find = createFind(findIndex);
              /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
              var findLast = createFind(findLastIndex);
              /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
              function flatMap(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), 1);
              }
              /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
              function flatMapDeep(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), INFINITY);
              }
              /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
              function flatMapDepth(collection, iteratee, depth) {
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(map(collection, iteratee), depth);
              }
              /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
              function forEach(collection, iteratee) {
                var func = isArray(collection) ? arrayEach : baseEach;
                return func(collection, getIteratee(iteratee, 3));
              }
              /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
              function forEachRight(collection, iteratee) {
                var func = isArray(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee, 3));
              }
              /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
              var groupBy = createAggregator(function (result, value, key) {
                  if (hasOwnProperty.call(result, key)) {
                    result[key].push(value);
                  } else {
                    baseAssignValue(result, key, [value]);
                  }
                });
              /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
              function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike(collection) ? collection : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                var length = collection.length;
                if (fromIndex < 0) {
                  fromIndex = nativeMax(length + fromIndex, 0);
                }
                return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
              }
              /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
              var invokeMap = baseRest(function (collection, path, args) {
                  var index = -1, isFunc = typeof path == 'function', isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
                  baseEach(collection, function (value) {
                    var func = isFunc ? path : isProp && value != null ? value[path] : undefined;
                    result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
                  });
                  return result;
                });
              /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
              var keyBy = createAggregator(function (result, value, key) {
                  baseAssignValue(result, key, value);
                });
              /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
              function map(collection, iteratee) {
                var func = isArray(collection) ? arrayMap : baseMap;
                return func(collection, getIteratee(iteratee, 3));
              }
              /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
              function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                  return [];
                }
                if (!isArray(iteratees)) {
                  iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined : orders;
                if (!isArray(orders)) {
                  orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
              }
              /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
              var partition = createAggregator(function (result, value, key) {
                  result[key ? 0 : 1].push(value);
                }, function () {
                  return [
                    [],
                    []
                  ];
                });
              /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
              function reduce(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
              }
              /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
              function reduceRight(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
              }
              /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
              function reject(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
              }
              /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
              function sample(collection) {
                return arraySample(isArrayLike(collection) ? collection : values(collection));
              }
              /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
              function sampleSize(collection, n, guard) {
                if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return arraySampleSize(isArrayLike(collection) ? collection : values(collection), n);
              }
              /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
              function shuffle(collection) {
                return shuffleSelf(isArrayLike(collection) ? copyArray(collection) : values(collection));
              }
              /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
              function size(collection) {
                if (collection == null) {
                  return 0;
                }
                if (isArrayLike(collection)) {
                  return isString(collection) ? stringSize(collection) : collection.length;
                }
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                  return collection.size;
                }
                return baseKeys(collection).length;
              }
              /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
              function some(collection, predicate, guard) {
                var func = isArray(collection) ? arraySome : baseSome;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
              var sortBy = baseRest(function (collection, iteratees) {
                  if (collection == null) {
                    return [];
                  }
                  var length = iteratees.length;
                  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                    iteratees = [];
                  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                    iteratees = [iteratees[0]];
                  }
                  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                });
              /*------------------------------------------------------------------------*/
              /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
              var now = ctxNow || function () {
                  return root.Date.now();
                };
              /*------------------------------------------------------------------------*/
              /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
              function after(n, func) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function () {
                  if (--n < 1) {
                    return func.apply(this, arguments);
                  }
                };
              }
              /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
              function ary(func, n, guard) {
                n = guard ? undefined : n;
                n = func && n == null ? func.length : n;
                return createWrap(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
              }
              /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
              function before(n, func) {
                var result;
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function () {
                  if (--n > 0) {
                    result = func.apply(this, arguments);
                  }
                  if (n <= 1) {
                    func = undefined;
                  }
                  return result;
                };
              }
              /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
              var bind = baseRest(function (func, thisArg, partials) {
                  var bitmask = BIND_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bind));
                    bitmask |= PARTIAL_FLAG;
                  }
                  return createWrap(func, bitmask, thisArg, partials, holders);
                });
              /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
              var bindKey = baseRest(function (object, key, partials) {
                  var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bindKey));
                    bitmask |= PARTIAL_FLAG;
                  }
                  return createWrap(key, bitmask, object, partials, holders);
                });
              /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
              function curry(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                result.placeholder = curry.placeholder;
                return result;
              }
              /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
              function curryRight(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                result.placeholder = curryRight.placeholder;
                return result;
              }
              /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
              function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                  leading = !!options.leading;
                  maxing = 'maxWait' in options;
                  maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                  trailing = 'trailing' in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                  var args = lastArgs, thisArg = lastThis;
                  lastArgs = lastThis = undefined;
                  lastInvokeTime = time;
                  result = func.apply(thisArg, args);
                  return result;
                }
                function leadingEdge(time) {
                  // Reset any `maxWait` timer.
                  lastInvokeTime = time;
                  // Start the timer for the trailing edge.
                  timerId = setTimeout(timerExpired, wait);
                  // Invoke the leading edge.
                  return leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                  return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                }
                function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                  // Either this is the first call, activity has stopped and we're at the
                  // trailing edge, the system time has gone backwards and we're treating
                  // it as the trailing edge, or we've hit the `maxWait` limit.
                  return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) {
                    return trailingEdge(time);
                  }
                  // Restart the timer.
                  timerId = setTimeout(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                  timerId = undefined;
                  // Only invoke if we have `lastArgs` which means `func` has been
                  // debounced at least once.
                  if (trailing && lastArgs) {
                    return invokeFunc(time);
                  }
                  lastArgs = lastThis = undefined;
                  return result;
                }
                function cancel() {
                  if (timerId !== undefined) {
                    clearTimeout(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = undefined;
                }
                function flush() {
                  return timerId === undefined ? result : trailingEdge(now());
                }
                function debounced() {
                  var time = now(), isInvoking = shouldInvoke(time);
                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time;
                  if (isInvoking) {
                    if (timerId === undefined) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      // Handle invocations in a tight loop.
                      timerId = setTimeout(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === undefined) {
                    timerId = setTimeout(timerExpired, wait);
                  }
                  return result;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }
              /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
              var defer = baseRest(function (func, args) {
                  return baseDelay(func, 1, args);
                });
              /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
              var delay = baseRest(function (func, wait, args) {
                  return baseDelay(func, toNumber(wait) || 0, args);
                });
              /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
              function flip(func) {
                return createWrap(func, FLIP_FLAG);
              }
              /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
              function memoize(func, resolver) {
                if (typeof func != 'function' || resolver && typeof resolver != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var memoized = function () {
                  var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                  if (cache.has(key)) {
                    return cache.get(key);
                  }
                  var result = func.apply(this, args);
                  memoized.cache = cache.set(key, result) || cache;
                  return result;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
              }
              // Expose `MapCache`.
              memoize.Cache = MapCache;
              /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
              function negate(predicate) {
                if (typeof predicate != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return function () {
                  var args = arguments;
                  switch (args.length) {
                  case 0:
                    return !predicate.call(this);
                  case 1:
                    return !predicate.call(this, args[0]);
                  case 2:
                    return !predicate.call(this, args[0], args[1]);
                  case 3:
                    return !predicate.call(this, args[0], args[1], args[2]);
                  }
                  return !predicate.apply(this, args);
                };
              }
              /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
              function once(func) {
                return before(2, func);
              }
              /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
              var overArgs = castRest(function (func, transforms) {
                  transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                  var funcsLength = transforms.length;
                  return baseRest(function (args) {
                    var index = -1, length = nativeMin(args.length, funcsLength);
                    while (++index < length) {
                      args[index] = transforms[index].call(this, args[index]);
                    }
                    return apply(func, this, args);
                  });
                });
              /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
              var partial = baseRest(function (func, partials) {
                  var holders = replaceHolders(partials, getHolder(partial));
                  return createWrap(func, PARTIAL_FLAG, undefined, partials, holders);
                });
              /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
              var partialRight = baseRest(function (func, partials) {
                  var holders = replaceHolders(partials, getHolder(partialRight));
                  return createWrap(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                });
              /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
              var rearg = flatRest(function (func, indexes) {
                  return createWrap(func, REARG_FLAG, undefined, undefined, undefined, indexes);
                });
              /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
              function rest(func, start) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start === undefined ? start : toInteger(start);
                return baseRest(func, start);
              }
              /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
              function spread(func, start) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
                return baseRest(function (args) {
                  var array = args[start], otherArgs = castSlice(args, 0, start);
                  if (array) {
                    arrayPush(otherArgs, array);
                  }
                  return apply(func, this, otherArgs);
                });
              }
              /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
              function throttle(func, wait, options) {
                var leading = true, trailing = true;
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                if (isObject(options)) {
                  leading = 'leading' in options ? !!options.leading : leading;
                  trailing = 'trailing' in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                  'leading': leading,
                  'maxWait': wait,
                  'trailing': trailing
                });
              }
              /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
              function unary(func) {
                return ary(func, 1);
              }
              /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
              function wrap(value, wrapper) {
                wrapper = wrapper == null ? identity : wrapper;
                return partial(wrapper, value);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
              function castArray() {
                if (!arguments.length) {
                  return [];
                }
                var value = arguments[0];
                return isArray(value) ? value : [value];
              }
              /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
              function clone(value) {
                return baseClone(value, false, true);
              }
              /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
              function cloneWith(value, customizer) {
                return baseClone(value, false, true, customizer);
              }
              /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
              function cloneDeep(value) {
                return baseClone(value, true, true);
              }
              /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
              function cloneDeepWith(value, customizer) {
                return baseClone(value, true, true, customizer);
              }
              /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
              function conformsTo(object, source) {
                return source == null || baseConformsTo(object, source, keys(source));
              }
              /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }
              /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
              var gt = createRelationalOperation(baseGt);
              /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
              var gte = createRelationalOperation(function (value, other) {
                  return value >= other;
                });
              /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
              function isArguments(value) {
                // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
              }
              /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
              var isArray = Array.isArray;
              /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
              var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
              /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
              }
              /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
              function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }
              /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
              function isBoolean(value) {
                return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
              }
              /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
              var isBuffer = nativeIsBuffer || stubFalse;
              /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
              var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
              /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
              function isElement(value) {
                return value != null && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
              }
              /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
              function isEmpty(value) {
                if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
                  return !value.length;
                }
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                  return !value.size;
                }
                if (isPrototype(value)) {
                  return !nativeKeys(value).length;
                }
                for (var key in value) {
                  if (hasOwnProperty.call(value, key)) {
                    return false;
                  }
                }
                return true;
              }
              /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are **not** supported.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
              function isEqual(value, other) {
                return baseIsEqual(value, other);
              }
              /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
              function isEqualWith(value, other, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                var result = customizer ? customizer(value, other) : undefined;
                return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
              }
              /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
              function isError(value) {
                if (!isObjectLike(value)) {
                  return false;
                }
                return objectToString.call(value) == errorTag || typeof value.message == 'string' && typeof value.name == 'string';
              }
              /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
              function isFinite(value) {
                return typeof value == 'number' && nativeIsFinite(value);
              }
              /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
              function isFunction(value) {
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 8-9 which returns 'object' for typed array and other constructors.
                var tag = isObject(value) ? objectToString.call(value) : '';
                return tag == funcTag || tag == genTag;
              }
              /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
              function isInteger(value) {
                return typeof value == 'number' && value == toInteger(value);
              }
              /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
              function isLength(value) {
                return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }
              /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
              function isObject(value) {
                var type = typeof value;
                return value != null && (type == 'object' || type == 'function');
              }
              /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
              function isObjectLike(value) {
                return value != null && typeof value == 'object';
              }
              /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
              var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
              /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
              function isMatch(object, source) {
                return object === source || baseIsMatch(object, source, getMatchData(source));
              }
              /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
              function isMatchWith(object, source, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return baseIsMatch(object, source, getMatchData(source), customizer);
              }
              /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
              function isNaN(value) {
                // An `NaN` primitive is the only value that is not equal to itself.
                // Perform the `toStringTag` check first to avoid errors with some
                // ActiveX objects in IE.
                return isNumber(value) && value != +value;
              }
              /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
              function isNative(value) {
                if (isMaskable(value)) {
                  throw new Error('This method is not supported with core-js. Try https://github.com/es-shims.');
                }
                return baseIsNative(value);
              }
              /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
              function isNull(value) {
                return value === null;
              }
              /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
              function isNil(value) {
                return value == null;
              }
              /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
              function isNumber(value) {
                return typeof value == 'number' || isObjectLike(value) && objectToString.call(value) == numberTag;
              }
              /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
              function isPlainObject(value) {
                if (!isObjectLike(value) || objectToString.call(value) != objectTag) {
                  return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                  return true;
                }
                var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
              }
              /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
              var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
              /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
              function isSafeInteger(value) {
                return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
              }
              /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
              var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
              /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
              function isString(value) {
                return typeof value == 'string' || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
              }
              /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
              function isSymbol(value) {
                return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
              }
              /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
              /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
              function isUndefined(value) {
                return value === undefined;
              }
              /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
              function isWeakMap(value) {
                return isObjectLike(value) && getTag(value) == weakMapTag;
              }
              /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
              function isWeakSet(value) {
                return isObjectLike(value) && objectToString.call(value) == weakSetTag;
              }
              /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
              var lt = createRelationalOperation(baseLt);
              /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
              var lte = createRelationalOperation(function (value, other) {
                  return value <= other;
                });
              /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
              function toArray(value) {
                if (!value) {
                  return [];
                }
                if (isArrayLike(value)) {
                  return isString(value) ? stringToArray(value) : copyArray(value);
                }
                if (iteratorSymbol && value[iteratorSymbol]) {
                  return iteratorToArray(value[iteratorSymbol]());
                }
                var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                return func(value);
              }
              /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }
              /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
              function toInteger(value) {
                var result = toFinite(value), remainder = result % 1;
                return result === result ? remainder ? result - remainder : result : 0;
              }
              /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
              function toLength(value) {
                return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
              }
              /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
              function toNumber(value) {
                if (typeof value == 'number') {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                  value = isObject(other) ? other + '' : other;
                }
                if (typeof value != 'string') {
                  return value === 0 ? value : +value;
                }
                value = value.replace(reTrim, '');
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
              }
              /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
              function toPlainObject(value) {
                return copyObject(value, keysIn(value));
              }
              /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
              function toSafeInteger(value) {
                return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
              }
              /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
              function toString(value) {
                return value == null ? '' : baseToString(value);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
              var assign = createAssigner(function (object, source) {
                  if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object);
                    return;
                  }
                  for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                      assignValue(object, key, source[key]);
                    }
                  }
                });
              /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
              var assignIn = createAssigner(function (object, source) {
                  copyObject(source, keysIn(source), object);
                });
              /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
              var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
                  copyObject(source, keysIn(source), object, customizer);
                });
              /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
              var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
                  copyObject(source, keys(source), object, customizer);
                });
              /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths of elements to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
              var at = flatRest(baseAt);
              /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
              function create(prototype, properties) {
                var result = baseCreate(prototype);
                return properties ? baseAssign(result, properties) : result;
              }
              /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
              var defaults = baseRest(function (args) {
                  args.push(undefined, assignInDefaults);
                  return apply(assignInWith, undefined, args);
                });
              /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
              var defaultsDeep = baseRest(function (args) {
                  args.push(undefined, mergeDefaults);
                  return apply(mergeWith, undefined, args);
                });
              /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
              function findKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
              }
              /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
              function findLastKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
              }
              /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
              function forIn(object, iteratee) {
                return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
              }
              /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
              function forInRight(object, iteratee) {
                return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
              }
              /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
              function forOwn(object, iteratee) {
                return object && baseForOwn(object, getIteratee(iteratee, 3));
              }
              /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
              function forOwnRight(object, iteratee) {
                return object && baseForOwnRight(object, getIteratee(iteratee, 3));
              }
              /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
              function functions(object) {
                return object == null ? [] : baseFunctions(object, keys(object));
              }
              /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
              function functionsIn(object) {
                return object == null ? [] : baseFunctions(object, keysIn(object));
              }
              /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
              function get(object, path, defaultValue) {
                var result = object == null ? undefined : baseGet(object, path);
                return result === undefined ? defaultValue : result;
              }
              /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
              function has(object, path) {
                return object != null && hasPath(object, path, baseHas);
              }
              /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
              function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
              }
              /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
              var invert = createInverter(function (result, value, key) {
                  result[value] = key;
                }, constant(identity));
              /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
              var invertBy = createInverter(function (result, value, key) {
                  if (hasOwnProperty.call(result, value)) {
                    result[value].push(key);
                  } else {
                    result[value] = [key];
                  }
                }, getIteratee);
              /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
              var invoke = baseRest(baseInvoke);
              /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }
              /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
              function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
              }
              /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
              function mapKeys(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);
                baseForOwn(object, function (value, key, object) {
                  baseAssignValue(result, iteratee(value, key, object), value);
                });
                return result;
              }
              /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
              function mapValues(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);
                baseForOwn(object, function (value, key, object) {
                  baseAssignValue(result, key, iteratee(value, key, object));
                });
                return result;
              }
              /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
              var merge = createAssigner(function (object, source, srcIndex) {
                  baseMerge(object, source, srcIndex);
                });
              /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
              var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
                  baseMerge(object, source, srcIndex, customizer);
                });
              /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable string keyed properties of `object` that are
     * not omitted.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [props] The property identifiers to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
              var omit = flatRest(function (object, props) {
                  if (object == null) {
                    return {};
                  }
                  props = arrayMap(props, toKey);
                  return basePick(object, baseDifference(getAllKeysIn(object), props));
                });
              /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
              function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
              }
              /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [props] The property identifiers to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
              var pick = flatRest(function (object, props) {
                  return object == null ? {} : basePick(object, arrayMap(props, toKey));
                });
              /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
              function pickBy(object, predicate) {
                return object == null ? {} : basePickBy(object, getAllKeysIn(object), getIteratee(predicate));
              }
              /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
              function result(object, path, defaultValue) {
                path = isKey(path, object) ? [path] : castPath(path);
                var index = -1, length = path.length;
                // Ensure the loop is entered when path is empty.
                if (!length) {
                  object = undefined;
                  length = 1;
                }
                while (++index < length) {
                  var value = object == null ? undefined : object[toKey(path[index])];
                  if (value === undefined) {
                    index = length;
                    value = defaultValue;
                  }
                  object = isFunction(value) ? value.call(object) : value;
                }
                return object;
              }
              /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
              function set(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
              }
              /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
              function setWith(object, path, value, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return object == null ? object : baseSet(object, path, value, customizer);
              }
              /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
              var toPairs = createToPairs(keys);
              /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
              var toPairsIn = createToPairs(keysIn);
              /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
              function transform(object, iteratee, accumulator) {
                var isArr = isArray(object) || isTypedArray(object);
                iteratee = getIteratee(iteratee, 4);
                if (accumulator == null) {
                  if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) {
                      accumulator = isArray(object) ? new Ctor() : [];
                    } else {
                      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                    }
                  } else {
                    accumulator = {};
                  }
                }
                (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                  return iteratee(accumulator, value, index, object);
                });
                return accumulator;
              }
              /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
              function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
              }
              /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
              function update(object, path, updater) {
                return object == null ? object : baseUpdate(object, path, castFunction(updater));
              }
              /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
              function updateWith(object, path, updater, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
              }
              /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
              function values(object) {
                return object ? baseValues(object, keys(object)) : [];
              }
              /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
              function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn(object));
              }
              /*------------------------------------------------------------------------*/
              /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
              function clamp(number, lower, upper) {
                if (upper === undefined) {
                  upper = lower;
                  lower = undefined;
                }
                if (upper !== undefined) {
                  upper = toNumber(upper);
                  upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined) {
                  lower = toNumber(lower);
                  lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber(number), lower, upper);
              }
              /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
              function inRange(number, start, end) {
                start = toFinite(start);
                if (end === undefined) {
                  end = start;
                  start = 0;
                } else {
                  end = toFinite(end);
                }
                number = toNumber(number);
                return baseInRange(number, start, end);
              }
              /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
              function random(lower, upper, floating) {
                if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                  upper = floating = undefined;
                }
                if (floating === undefined) {
                  if (typeof upper == 'boolean') {
                    floating = upper;
                    upper = undefined;
                  } else if (typeof lower == 'boolean') {
                    floating = lower;
                    lower = undefined;
                  }
                }
                if (lower === undefined && upper === undefined) {
                  lower = 0;
                  upper = 1;
                } else {
                  lower = toFinite(lower);
                  if (upper === undefined) {
                    upper = lower;
                    lower = 0;
                  } else {
                    upper = toFinite(upper);
                  }
                }
                if (lower > upper) {
                  var temp = lower;
                  lower = upper;
                  upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                  var rand = nativeRandom();
                  return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
                }
                return baseRandom(lower, upper);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
              var camelCase = createCompounder(function (result, word, index) {
                  word = word.toLowerCase();
                  return result + (index ? capitalize(word) : word);
                });
              /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
              function capitalize(string) {
                return upperFirst(toString(string).toLowerCase());
              }
              /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
              function deburr(string) {
                string = toString(string);
                return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
              }
              /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
              function endsWith(string, target, position) {
                string = toString(string);
                target = baseToString(target);
                var length = string.length;
                position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
                var end = position;
                position -= target.length;
                return position >= 0 && string.slice(position, end) == target;
              }
              /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
              function escape(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
              }
              /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
              function escapeRegExp(string) {
                string = toString(string);
                return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
              }
              /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
              var kebabCase = createCompounder(function (result, word, index) {
                  return result + (index ? '-' : '') + word.toLowerCase();
                });
              /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
              var lowerCase = createCompounder(function (result, word, index) {
                  return result + (index ? ' ' : '') + word.toLowerCase();
                });
              /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
              var lowerFirst = createCaseFirst('toLowerCase');
              /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
              function pad(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                if (!length || strLength >= length) {
                  return string;
                }
                var mid = (length - strLength) / 2;
                return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
              }
              /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
              function padEnd(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
              }
              /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
              function padStart(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
              }
              /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
              function parseInt(string, radix, guard) {
                if (guard || radix == null) {
                  radix = 0;
                } else if (radix) {
                  radix = +radix;
                }
                return nativeParseInt(toString(string), radix || 0);
              }
              /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
              function repeat(string, n, guard) {
                if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return baseRepeat(toString(string), n);
              }
              /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
              function replace() {
                var args = arguments, string = toString(args[0]);
                return args.length < 3 ? string : string.replace(args[1], args[2]);
              }
              /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
              var snakeCase = createCompounder(function (result, word, index) {
                  return result + (index ? '_' : '') + word.toLowerCase();
                });
              /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
              function split(string, separator, limit) {
                if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                  separator = limit = undefined;
                }
                limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                  return [];
                }
                string = toString(string);
                if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
                  separator = baseToString(separator);
                  if (!separator && hasUnicode(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                  }
                }
                return string.split(separator, limit);
              }
              /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
              var startCase = createCompounder(function (result, word, index) {
                  return result + (index ? ' ' : '') + upperFirst(word);
                });
              /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
              function startsWith(string, target, position) {
                string = toString(string);
                position = baseClamp(toInteger(position), 0, string.length);
                target = baseToString(target);
                return string.slice(position, position + target.length) == target;
              }
              /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
              function template(string, options, guard) {
                // Based on John Resig's `tmpl` implementation
                // (http://ejohn.org/blog/javascript-micro-templating/)
                // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                var settings = lodash.templateSettings;
                if (guard && isIterateeCall(string, options, guard)) {
                  options = undefined;
                }
                string = toString(string);
                options = assignInWith({}, options, settings, assignInDefaults);
                var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
                // Compile the regexp to match each delimiter.
                var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
                // Use a sourceURL for easier debugging.
                var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
                string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                  interpolateValue || (interpolateValue = esTemplateValue);
                  // Escape characters that can't be included in string literals.
                  source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                  // Replace delimiters with snippets.
                  if (escapeValue) {
                    isEscaping = true;
                    source += '\' +\n__e(' + escapeValue + ') +\n\'';
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += '\';\n' + evaluateValue + ';\n__p += \'';
                  }
                  if (interpolateValue) {
                    source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                  }
                  index = offset + match.length;
                  // The JS engine embedded in Adobe products needs `match` returned in
                  // order to produce the correct `offset` value.
                  return match;
                });
                source += '\';\n';
                // If `variable` is not specified wrap a with-statement around the generated
                // code to add the data object to the top of the scope chain.
                var variable = options.variable;
                if (!variable) {
                  source = 'with (obj) {\n' + source + '\n}\n';
                }
                // Cleanup code by stripping empty strings.
                source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
                // Frame code as the function body.
                source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + 'var __t, __p = \'\'' + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
                var result = attempt(function () {
                    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
                  });
                // Provide the compiled function's source by its `toString` method or
                // the `source` property as a convenience for inlining compiled templates.
                result.source = source;
                if (isError(result)) {
                  throw result;
                }
                return result;
              }
              /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
              function toLower(value) {
                return toString(value).toLowerCase();
              }
              /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
              function toUpper(value) {
                return toString(value).toUpperCase();
              }
              /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
              function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrim, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice(strSymbols, start, end).join('');
              }
              /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
              function trimEnd(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimEnd, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                return castSlice(strSymbols, 0, end).join('');
              }
              /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
              function trimStart(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimStart, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                return castSlice(strSymbols, start).join('');
              }
              /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
              function truncate(string, options) {
                var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                if (isObject(options)) {
                  var separator = 'separator' in options ? options.separator : separator;
                  length = 'length' in options ? toInteger(options.length) : length;
                  omission = 'omission' in options ? baseToString(options.omission) : omission;
                }
                string = toString(string);
                var strLength = string.length;
                if (hasUnicode(string)) {
                  var strSymbols = stringToArray(string);
                  strLength = strSymbols.length;
                }
                if (length >= strLength) {
                  return string;
                }
                var end = length - stringSize(omission);
                if (end < 1) {
                  return omission;
                }
                var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
                if (separator === undefined) {
                  return result + omission;
                }
                if (strSymbols) {
                  end += result.length - end;
                }
                if (isRegExp(separator)) {
                  if (string.slice(end).search(separator)) {
                    var match, substring = result;
                    if (!separator.global) {
                      separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                      var newEnd = match.index;
                    }
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                  }
                } else if (string.indexOf(baseToString(separator), end) != end) {
                  var index = result.lastIndexOf(separator);
                  if (index > -1) {
                    result = result.slice(0, index);
                  }
                }
                return result + omission;
              }
              /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
              function unescape(string) {
                string = toString(string);
                return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
              }
              /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
              var upperCase = createCompounder(function (result, word, index) {
                  return result + (index ? ' ' : '') + word.toUpperCase();
                });
              /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
              var upperFirst = createCaseFirst('toUpperCase');
              /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
              function words(string, pattern, guard) {
                string = toString(string);
                pattern = guard ? undefined : pattern;
                if (pattern === undefined) {
                  return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                }
                return string.match(pattern) || [];
              }
              /*------------------------------------------------------------------------*/
              /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
              var attempt = baseRest(function (func, args) {
                  try {
                    return apply(func, undefined, args);
                  } catch (e) {
                    return isError(e) ? e : new Error(e);
                  }
                });
              /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
              var bindAll = flatRest(function (object, methodNames) {
                  arrayEach(methodNames, function (key) {
                    key = toKey(key);
                    baseAssignValue(object, key, bind(object[key], object));
                  });
                  return object;
                });
              /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
              function cond(pairs) {
                var length = pairs ? pairs.length : 0, toIteratee = getIteratee();
                pairs = !length ? [] : arrayMap(pairs, function (pair) {
                  if (typeof pair[1] != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  return [
                    toIteratee(pair[0]),
                    pair[1]
                  ];
                });
                return baseRest(function (args) {
                  var index = -1;
                  while (++index < length) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) {
                      return apply(pair[1], this, args);
                    }
                  }
                });
              }
              /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
              function conforms(source) {
                return baseConforms(baseClone(source, true));
              }
              /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
              function constant(value) {
                return function () {
                  return value;
                };
              }
              /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
              function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
              }
              /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
              var flow = createFlow();
              /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
              var flowRight = createFlow(true);
              /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
              function identity(value) {
                return value;
              }
              /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
              function iteratee(func) {
                return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
              }
              /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
              function matches(source) {
                return baseMatches(baseClone(source, true));
              }
              /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
              function matchesProperty(path, srcValue) {
                return baseMatchesProperty(path, baseClone(srcValue, true));
              }
              /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
              var method = baseRest(function (path, args) {
                  return function (object) {
                    return baseInvoke(object, path, args);
                  };
                });
              /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
              var methodOf = baseRest(function (object, args) {
                  return function (path) {
                    return baseInvoke(object, path, args);
                  };
                });
              /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
              function mixin(object, source, options) {
                var props = keys(source), methodNames = baseFunctions(source, props);
                if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                  options = source;
                  source = object;
                  object = this;
                  methodNames = baseFunctions(source, keys(source));
                }
                var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
                arrayEach(methodNames, function (methodName) {
                  var func = source[methodName];
                  object[methodName] = func;
                  if (isFunc) {
                    object.prototype[methodName] = function () {
                      var chainAll = this.__chain__;
                      if (chain || chainAll) {
                        var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                        actions.push({
                          'func': func,
                          'args': arguments,
                          'thisArg': object
                        });
                        result.__chain__ = chainAll;
                        return result;
                      }
                      return func.apply(object, arrayPush([this.value()], arguments));
                    };
                  }
                });
                return object;
              }
              /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
              function noConflict() {
                if (root._ === this) {
                  root._ = oldDash;
                }
                return this;
              }
              /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
              function noop() {
              }
              /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
              function nthArg(n) {
                n = toInteger(n);
                return baseRest(function (args) {
                  return baseNth(args, n);
                });
              }
              /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
              var over = createOver(arrayMap);
              /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
              var overEvery = createOver(arrayEvery);
              /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
              var overSome = createOver(arraySome);
              /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
              function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
              }
              /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
              function propertyOf(object) {
                return function (path) {
                  return object == null ? undefined : baseGet(object, path);
                };
              }
              /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
              var range = createRange();
              /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
              var rangeRight = createRange(true);
              /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
              function stubArray() {
                return [];
              }
              /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
              function stubFalse() {
                return false;
              }
              /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
              function stubObject() {
                return {};
              }
              /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
              function stubString() {
                return '';
              }
              /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
              function stubTrue() {
                return true;
              }
              /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
              function times(n, iteratee) {
                n = toInteger(n);
                if (n < 1 || n > MAX_SAFE_INTEGER) {
                  return [];
                }
                var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                iteratee = getIteratee(iteratee);
                n -= MAX_ARRAY_LENGTH;
                var result = baseTimes(length, iteratee);
                while (++index < n) {
                  iteratee(index);
                }
                return result;
              }
              /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
              function toPath(value) {
                if (isArray(value)) {
                  return arrayMap(value, toKey);
                }
                return isSymbol(value) ? [value] : copyArray(stringToPath(value));
              }
              /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
              function uniqueId(prefix) {
                var id = ++idCounter;
                return toString(prefix) + id;
              }
              /*------------------------------------------------------------------------*/
              /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
              var add = createMathOperation(function (augend, addend) {
                  return augend + addend;
                }, 0);
              /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
              var ceil = createRound('ceil');
              /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
              var divide = createMathOperation(function (dividend, divisor) {
                  return dividend / divisor;
                }, 1);
              /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
              var floor = createRound('floor');
              /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
              function max(array) {
                return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
              }
              /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
              function maxBy(array, iteratee) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
              }
              /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
              function mean(array) {
                return baseMean(array, identity);
              }
              /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
              function meanBy(array, iteratee) {
                return baseMean(array, getIteratee(iteratee, 2));
              }
              /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
              function min(array) {
                return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
              }
              /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
              function minBy(array, iteratee) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
              }
              /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
              var multiply = createMathOperation(function (multiplier, multiplicand) {
                  return multiplier * multiplicand;
                }, 1);
              /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
              var round = createRound('round');
              /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
              var subtract = createMathOperation(function (minuend, subtrahend) {
                  return minuend - subtrahend;
                }, 0);
              /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
              function sum(array) {
                return array && array.length ? baseSum(array, identity) : 0;
              }
              /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
              function sumBy(array, iteratee) {
                return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
              }
              /*------------------------------------------------------------------------*/
              // Add methods that return wrapped values in chain sequences.
              lodash.after = after;
              lodash.ary = ary;
              lodash.assign = assign;
              lodash.assignIn = assignIn;
              lodash.assignInWith = assignInWith;
              lodash.assignWith = assignWith;
              lodash.at = at;
              lodash.before = before;
              lodash.bind = bind;
              lodash.bindAll = bindAll;
              lodash.bindKey = bindKey;
              lodash.castArray = castArray;
              lodash.chain = chain;
              lodash.chunk = chunk;
              lodash.compact = compact;
              lodash.concat = concat;
              lodash.cond = cond;
              lodash.conforms = conforms;
              lodash.constant = constant;
              lodash.countBy = countBy;
              lodash.create = create;
              lodash.curry = curry;
              lodash.curryRight = curryRight;
              lodash.debounce = debounce;
              lodash.defaults = defaults;
              lodash.defaultsDeep = defaultsDeep;
              lodash.defer = defer;
              lodash.delay = delay;
              lodash.difference = difference;
              lodash.differenceBy = differenceBy;
              lodash.differenceWith = differenceWith;
              lodash.drop = drop;
              lodash.dropRight = dropRight;
              lodash.dropRightWhile = dropRightWhile;
              lodash.dropWhile = dropWhile;
              lodash.fill = fill;
              lodash.filter = filter;
              lodash.flatMap = flatMap;
              lodash.flatMapDeep = flatMapDeep;
              lodash.flatMapDepth = flatMapDepth;
              lodash.flatten = flatten;
              lodash.flattenDeep = flattenDeep;
              lodash.flattenDepth = flattenDepth;
              lodash.flip = flip;
              lodash.flow = flow;
              lodash.flowRight = flowRight;
              lodash.fromPairs = fromPairs;
              lodash.functions = functions;
              lodash.functionsIn = functionsIn;
              lodash.groupBy = groupBy;
              lodash.initial = initial;
              lodash.intersection = intersection;
              lodash.intersectionBy = intersectionBy;
              lodash.intersectionWith = intersectionWith;
              lodash.invert = invert;
              lodash.invertBy = invertBy;
              lodash.invokeMap = invokeMap;
              lodash.iteratee = iteratee;
              lodash.keyBy = keyBy;
              lodash.keys = keys;
              lodash.keysIn = keysIn;
              lodash.map = map;
              lodash.mapKeys = mapKeys;
              lodash.mapValues = mapValues;
              lodash.matches = matches;
              lodash.matchesProperty = matchesProperty;
              lodash.memoize = memoize;
              lodash.merge = merge;
              lodash.mergeWith = mergeWith;
              lodash.method = method;
              lodash.methodOf = methodOf;
              lodash.mixin = mixin;
              lodash.negate = negate;
              lodash.nthArg = nthArg;
              lodash.omit = omit;
              lodash.omitBy = omitBy;
              lodash.once = once;
              lodash.orderBy = orderBy;
              lodash.over = over;
              lodash.overArgs = overArgs;
              lodash.overEvery = overEvery;
              lodash.overSome = overSome;
              lodash.partial = partial;
              lodash.partialRight = partialRight;
              lodash.partition = partition;
              lodash.pick = pick;
              lodash.pickBy = pickBy;
              lodash.property = property;
              lodash.propertyOf = propertyOf;
              lodash.pull = pull;
              lodash.pullAll = pullAll;
              lodash.pullAllBy = pullAllBy;
              lodash.pullAllWith = pullAllWith;
              lodash.pullAt = pullAt;
              lodash.range = range;
              lodash.rangeRight = rangeRight;
              lodash.rearg = rearg;
              lodash.reject = reject;
              lodash.remove = remove;
              lodash.rest = rest;
              lodash.reverse = reverse;
              lodash.sampleSize = sampleSize;
              lodash.set = set;
              lodash.setWith = setWith;
              lodash.shuffle = shuffle;
              lodash.slice = slice;
              lodash.sortBy = sortBy;
              lodash.sortedUniq = sortedUniq;
              lodash.sortedUniqBy = sortedUniqBy;
              lodash.split = split;
              lodash.spread = spread;
              lodash.tail = tail;
              lodash.take = take;
              lodash.takeRight = takeRight;
              lodash.takeRightWhile = takeRightWhile;
              lodash.takeWhile = takeWhile;
              lodash.tap = tap;
              lodash.throttle = throttle;
              lodash.thru = thru;
              lodash.toArray = toArray;
              lodash.toPairs = toPairs;
              lodash.toPairsIn = toPairsIn;
              lodash.toPath = toPath;
              lodash.toPlainObject = toPlainObject;
              lodash.transform = transform;
              lodash.unary = unary;
              lodash.union = union;
              lodash.unionBy = unionBy;
              lodash.unionWith = unionWith;
              lodash.uniq = uniq;
              lodash.uniqBy = uniqBy;
              lodash.uniqWith = uniqWith;
              lodash.unset = unset;
              lodash.unzip = unzip;
              lodash.unzipWith = unzipWith;
              lodash.update = update;
              lodash.updateWith = updateWith;
              lodash.values = values;
              lodash.valuesIn = valuesIn;
              lodash.without = without;
              lodash.words = words;
              lodash.wrap = wrap;
              lodash.xor = xor;
              lodash.xorBy = xorBy;
              lodash.xorWith = xorWith;
              lodash.zip = zip;
              lodash.zipObject = zipObject;
              lodash.zipObjectDeep = zipObjectDeep;
              lodash.zipWith = zipWith;
              // Add aliases.
              lodash.entries = toPairs;
              lodash.entriesIn = toPairsIn;
              lodash.extend = assignIn;
              lodash.extendWith = assignInWith;
              // Add methods to `lodash.prototype`.
              mixin(lodash, lodash);
              /*------------------------------------------------------------------------*/
              // Add methods that return unwrapped values in chain sequences.
              lodash.add = add;
              lodash.attempt = attempt;
              lodash.camelCase = camelCase;
              lodash.capitalize = capitalize;
              lodash.ceil = ceil;
              lodash.clamp = clamp;
              lodash.clone = clone;
              lodash.cloneDeep = cloneDeep;
              lodash.cloneDeepWith = cloneDeepWith;
              lodash.cloneWith = cloneWith;
              lodash.conformsTo = conformsTo;
              lodash.deburr = deburr;
              lodash.defaultTo = defaultTo;
              lodash.divide = divide;
              lodash.endsWith = endsWith;
              lodash.eq = eq;
              lodash.escape = escape;
              lodash.escapeRegExp = escapeRegExp;
              lodash.every = every;
              lodash.find = find;
              lodash.findIndex = findIndex;
              lodash.findKey = findKey;
              lodash.findLast = findLast;
              lodash.findLastIndex = findLastIndex;
              lodash.findLastKey = findLastKey;
              lodash.floor = floor;
              lodash.forEach = forEach;
              lodash.forEachRight = forEachRight;
              lodash.forIn = forIn;
              lodash.forInRight = forInRight;
              lodash.forOwn = forOwn;
              lodash.forOwnRight = forOwnRight;
              lodash.get = get;
              lodash.gt = gt;
              lodash.gte = gte;
              lodash.has = has;
              lodash.hasIn = hasIn;
              lodash.head = head;
              lodash.identity = identity;
              lodash.includes = includes;
              lodash.indexOf = indexOf;
              lodash.inRange = inRange;
              lodash.invoke = invoke;
              lodash.isArguments = isArguments;
              lodash.isArray = isArray;
              lodash.isArrayBuffer = isArrayBuffer;
              lodash.isArrayLike = isArrayLike;
              lodash.isArrayLikeObject = isArrayLikeObject;
              lodash.isBoolean = isBoolean;
              lodash.isBuffer = isBuffer;
              lodash.isDate = isDate;
              lodash.isElement = isElement;
              lodash.isEmpty = isEmpty;
              lodash.isEqual = isEqual;
              lodash.isEqualWith = isEqualWith;
              lodash.isError = isError;
              lodash.isFinite = isFinite;
              lodash.isFunction = isFunction;
              lodash.isInteger = isInteger;
              lodash.isLength = isLength;
              lodash.isMap = isMap;
              lodash.isMatch = isMatch;
              lodash.isMatchWith = isMatchWith;
              lodash.isNaN = isNaN;
              lodash.isNative = isNative;
              lodash.isNil = isNil;
              lodash.isNull = isNull;
              lodash.isNumber = isNumber;
              lodash.isObject = isObject;
              lodash.isObjectLike = isObjectLike;
              lodash.isPlainObject = isPlainObject;
              lodash.isRegExp = isRegExp;
              lodash.isSafeInteger = isSafeInteger;
              lodash.isSet = isSet;
              lodash.isString = isString;
              lodash.isSymbol = isSymbol;
              lodash.isTypedArray = isTypedArray;
              lodash.isUndefined = isUndefined;
              lodash.isWeakMap = isWeakMap;
              lodash.isWeakSet = isWeakSet;
              lodash.join = join;
              lodash.kebabCase = kebabCase;
              lodash.last = last;
              lodash.lastIndexOf = lastIndexOf;
              lodash.lowerCase = lowerCase;
              lodash.lowerFirst = lowerFirst;
              lodash.lt = lt;
              lodash.lte = lte;
              lodash.max = max;
              lodash.maxBy = maxBy;
              lodash.mean = mean;
              lodash.meanBy = meanBy;
              lodash.min = min;
              lodash.minBy = minBy;
              lodash.stubArray = stubArray;
              lodash.stubFalse = stubFalse;
              lodash.stubObject = stubObject;
              lodash.stubString = stubString;
              lodash.stubTrue = stubTrue;
              lodash.multiply = multiply;
              lodash.nth = nth;
              lodash.noConflict = noConflict;
              lodash.noop = noop;
              lodash.now = now;
              lodash.pad = pad;
              lodash.padEnd = padEnd;
              lodash.padStart = padStart;
              lodash.parseInt = parseInt;
              lodash.random = random;
              lodash.reduce = reduce;
              lodash.reduceRight = reduceRight;
              lodash.repeat = repeat;
              lodash.replace = replace;
              lodash.result = result;
              lodash.round = round;
              lodash.runInContext = runInContext;
              lodash.sample = sample;
              lodash.size = size;
              lodash.snakeCase = snakeCase;
              lodash.some = some;
              lodash.sortedIndex = sortedIndex;
              lodash.sortedIndexBy = sortedIndexBy;
              lodash.sortedIndexOf = sortedIndexOf;
              lodash.sortedLastIndex = sortedLastIndex;
              lodash.sortedLastIndexBy = sortedLastIndexBy;
              lodash.sortedLastIndexOf = sortedLastIndexOf;
              lodash.startCase = startCase;
              lodash.startsWith = startsWith;
              lodash.subtract = subtract;
              lodash.sum = sum;
              lodash.sumBy = sumBy;
              lodash.template = template;
              lodash.times = times;
              lodash.toFinite = toFinite;
              lodash.toInteger = toInteger;
              lodash.toLength = toLength;
              lodash.toLower = toLower;
              lodash.toNumber = toNumber;
              lodash.toSafeInteger = toSafeInteger;
              lodash.toString = toString;
              lodash.toUpper = toUpper;
              lodash.trim = trim;
              lodash.trimEnd = trimEnd;
              lodash.trimStart = trimStart;
              lodash.truncate = truncate;
              lodash.unescape = unescape;
              lodash.uniqueId = uniqueId;
              lodash.upperCase = upperCase;
              lodash.upperFirst = upperFirst;
              // Add aliases.
              lodash.each = forEach;
              lodash.eachRight = forEachRight;
              lodash.first = head;
              mixin(lodash, function () {
                var source = {};
                baseForOwn(lodash, function (func, methodName) {
                  if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                    source[methodName] = func;
                  }
                });
                return source;
              }(), { 'chain': false });
              /*------------------------------------------------------------------------*/
              /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
              lodash.VERSION = VERSION;
              // Assign default placeholders.
              arrayEach([
                'bind',
                'bindKey',
                'curry',
                'curryRight',
                'partial',
                'partialRight'
              ], function (methodName) {
                lodash[methodName].placeholder = lodash;
              });
              // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
              arrayEach([
                'drop',
                'take'
              ], function (methodName, index) {
                LazyWrapper.prototype[methodName] = function (n) {
                  var filtered = this.__filtered__;
                  if (filtered && !index) {
                    return new LazyWrapper(this);
                  }
                  n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                  var result = this.clone();
                  if (filtered) {
                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                  } else {
                    result.__views__.push({
                      'size': nativeMin(n, MAX_ARRAY_LENGTH),
                      'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                    });
                  }
                  return result;
                };
                LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                  return this.reverse()[methodName](n).reverse();
                };
              });
              // Add `LazyWrapper` methods that accept an `iteratee` value.
              arrayEach([
                'filter',
                'map',
                'takeWhile'
              ], function (methodName, index) {
                var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                LazyWrapper.prototype[methodName] = function (iteratee) {
                  var result = this.clone();
                  result.__iteratees__.push({
                    'iteratee': getIteratee(iteratee, 3),
                    'type': type
                  });
                  result.__filtered__ = result.__filtered__ || isFilter;
                  return result;
                };
              });
              // Add `LazyWrapper` methods for `_.head` and `_.last`.
              arrayEach([
                'head',
                'last'
              ], function (methodName, index) {
                var takeName = 'take' + (index ? 'Right' : '');
                LazyWrapper.prototype[methodName] = function () {
                  return this[takeName](1).value()[0];
                };
              });
              // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
              arrayEach([
                'initial',
                'tail'
              ], function (methodName, index) {
                var dropName = 'drop' + (index ? '' : 'Right');
                LazyWrapper.prototype[methodName] = function () {
                  return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                };
              });
              LazyWrapper.prototype.compact = function () {
                return this.filter(identity);
              };
              LazyWrapper.prototype.find = function (predicate) {
                return this.filter(predicate).head();
              };
              LazyWrapper.prototype.findLast = function (predicate) {
                return this.reverse().find(predicate);
              };
              LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
                if (typeof path == 'function') {
                  return new LazyWrapper(this);
                }
                return this.map(function (value) {
                  return baseInvoke(value, path, args);
                });
              });
              LazyWrapper.prototype.reject = function (predicate) {
                return this.filter(negate(getIteratee(predicate)));
              };
              LazyWrapper.prototype.slice = function (start, end) {
                start = toInteger(start);
                var result = this;
                if (result.__filtered__ && (start > 0 || end < 0)) {
                  return new LazyWrapper(result);
                }
                if (start < 0) {
                  result = result.takeRight(-start);
                } else if (start) {
                  result = result.drop(start);
                }
                if (end !== undefined) {
                  end = toInteger(end);
                  result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                }
                return result;
              };
              LazyWrapper.prototype.takeRightWhile = function (predicate) {
                return this.reverse().takeWhile(predicate).reverse();
              };
              LazyWrapper.prototype.toArray = function () {
                return this.take(MAX_ARRAY_LENGTH);
              };
              // Add `LazyWrapper` methods to `lodash.prototype`.
              baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                if (!lodashFunc) {
                  return;
                }
                lodash.prototype[methodName] = function () {
                  var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                  var interceptor = function (value) {
                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                    return isTaker && chainAll ? result[0] : result;
                  };
                  if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                    // Avoid lazy use if the iteratee has a "length" value other than `1`.
                    isLazy = useLazy = false;
                  }
                  var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                  if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    result.__actions__.push({
                      'func': thru,
                      'args': [interceptor],
                      'thisArg': undefined
                    });
                    return new LodashWrapper(result, chainAll);
                  }
                  if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                  }
                  result = this.thru(interceptor);
                  return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
                };
              });
              // Add `Array` methods to `lodash.prototype`.
              arrayEach([
                'pop',
                'push',
                'shift',
                'sort',
                'splice',
                'unshift'
              ], function (methodName) {
                var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                lodash.prototype[methodName] = function () {
                  var args = arguments;
                  if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                  }
                  return this[chainName](function (value) {
                    return func.apply(isArray(value) ? value : [], args);
                  });
                };
              });
              // Map minified method names to their real names.
              baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                var lodashFunc = lodash[methodName];
                if (lodashFunc) {
                  var key = lodashFunc.name + '', names = realNames[key] || (realNames[key] = []);
                  names.push({
                    'name': methodName,
                    'func': lodashFunc
                  });
                }
              });
              realNames[createHybrid(undefined, BIND_KEY_FLAG).name] = [{
                  'name': 'wrapper',
                  'func': undefined
                }];
              // Add methods to `LazyWrapper`.
              LazyWrapper.prototype.clone = lazyClone;
              LazyWrapper.prototype.reverse = lazyReverse;
              LazyWrapper.prototype.value = lazyValue;
              // Add chain sequence methods to the `lodash` wrapper.
              lodash.prototype.at = wrapperAt;
              lodash.prototype.chain = wrapperChain;
              lodash.prototype.commit = wrapperCommit;
              lodash.prototype.next = wrapperNext;
              lodash.prototype.plant = wrapperPlant;
              lodash.prototype.reverse = wrapperReverse;
              lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
              // Add lazy aliases.
              lodash.prototype.first = lodash.prototype.head;
              if (iteratorSymbol) {
                lodash.prototype[iteratorSymbol] = wrapperToIterator;
              }
              return lodash;
            }
            /*--------------------------------------------------------------------------*/
            // Export lodash.
            var _ = runInContext();
            // Some AMD build optimizers, like r.js, check for condition patterns like:
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
              // Expose Lodash on the global object to prevent errors when Lodash is
              // loaded by a script tag in the presence of an AMD loader.
              // See http://requirejs.org/docs/errors.html#mismatch for more details.
              // Use `_.noConflict` to remove Lodash from the global object.
              root._ = _;
              // Define as an anonymous module so, through path mapping, it can be
              // referenced as the "underscore" module.
              define(function () {
                return _;
              });
            }  // Check for `exports` after `define` in case a build optimizer adds it.
            else if (freeModule) {
              // Export for Node.js.
              (freeModule.exports = _)._ = _;
              // Export for CommonJS support.
              freeExports._ = _;
            } else {
              // Export to the global object.
              root._ = _;
            }
          }.call(this));
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    110: [
      function (require, module, exports) {
        /**
 * Helpers.
 */
        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var y = d * 365.25;
        /**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */
        module.exports = function (val, options) {
          options = options || {};
          if ('string' == typeof val)
            return parse(val);
          return options.long ? long(val) : short(val);
        };
        /**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */
        function parse(str) {
          str = '' + str;
          if (str.length > 10000)
            return;
          var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
          if (!match)
            return;
          var n = parseFloat(match[1]);
          var type = (match[2] || 'ms').toLowerCase();
          switch (type) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * y;
          case 'days':
          case 'day':
          case 'd':
            return n * d;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * h;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * m;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * s;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n;
          }
        }
        /**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function short(ms) {
          if (ms >= d)
            return Math.round(ms / d) + 'd';
          if (ms >= h)
            return Math.round(ms / h) + 'h';
          if (ms >= m)
            return Math.round(ms / m) + 'm';
          if (ms >= s)
            return Math.round(ms / s) + 's';
          return ms + 'ms';
        }
        /**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function long(ms) {
          return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
        }
        /**
 * Pluralization helper.
 */
        function plural(ms, n, name) {
          if (ms < n)
            return;
          if (ms < n * 1.5)
            return Math.floor(ms / n) + ' ' + name;
          return Math.ceil(ms / n) + ' ' + name + 's';
        }
      },
      {}
    ],
    111: [
      function (require, module, exports) {
        'use strict';
        // modified from https://github.com/es-shims/es5-shim
        var has = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var slice = Array.prototype.slice;
        var isArgs = require('./isArguments');
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
        var hasProtoEnumBug = isEnumerable.call(function () {
          }, 'prototype');
        var dontEnums = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor'
          ];
        var equalsConstructorPrototype = function (o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        var excludedKeys = {
            $console: true,
            $external: true,
            $frame: true,
            $frameElement: true,
            $frames: true,
            $innerHeight: true,
            $innerWidth: true,
            $outerHeight: true,
            $outerWidth: true,
            $pageXOffset: true,
            $pageYOffset: true,
            $parent: true,
            $scrollLeft: true,
            $scrollTop: true,
            $scrollX: true,
            $scrollY: true,
            $self: true,
            $webkitIndexedDB: true,
            $webkitStorageInfo: true,
            $window: true
          };
        var hasAutomationEqualityBug = function () {
            /* global window */
            if (typeof window === 'undefined') {
              return false;
            }
            for (var k in window) {
              try {
                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                  try {
                    equalsConstructorPrototype(window[k]);
                  } catch (e) {
                    return true;
                  }
                }
              } catch (e) {
                return true;
              }
            }
            return false;
          }();
        var equalsConstructorPrototypeIfNotBuggy = function (o) {
          /* global window */
          if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        var keysShim = function keys(object) {
          var isObject = object !== null && typeof object === 'object';
          var isFunction = toStr.call(object) === '[object Function]';
          var isArguments = isArgs(object);
          var isString = isObject && toStr.call(object) === '[object String]';
          var theKeys = [];
          if (!isObject && !isFunction && !isArguments) {
            throw new TypeError('Object.keys called on a non-object');
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object) {
              if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
        keysShim.shim = function shimObjectKeys() {
          if (Object.keys) {
            var keysWorksWithArguments = function () {
                // Safari 5.0 bug
                return (Object.keys(arguments) || '').length === 2;
              }(1, 2);
            if (!keysWorksWithArguments) {
              var originalKeys = Object.keys;
              Object.keys = function keys(object) {
                if (isArgs(object)) {
                  return originalKeys(slice.call(object));
                } else {
                  return originalKeys(object);
                }
              };
            }
          } else {
            Object.keys = keysShim;
          }
          return Object.keys || keysShim;
        };
        module.exports = keysShim;
      },
      { './isArguments': 112 }
    ],
    112: [
      function (require, module, exports) {
        'use strict';
        var toStr = Object.prototype.toString;
        module.exports = function isArguments(value) {
          var str = toStr.call(value);
          var isArgs = str === '[object Arguments]';
          if (!isArgs) {
            isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
          }
          return isArgs;
        };
      },
      {}
    ],
    113: [
      function (require, module, exports) {
        /**!
 * Ono v2.2.1
 *
 * @link https://github.com/BigstickCarpet/ono
 * @license MIT
 */
        'use strict';
        var util = require('util'), slice = Array.prototype.slice, vendorSpecificErrorProperties = [
            'name',
            'message',
            'description',
            'number',
            'fileName',
            'lineNumber',
            'columnNumber',
            'sourceURL',
            'line',
            'column',
            'stack'
          ];
        module.exports = create(Error);
        module.exports.error = create(Error);
        module.exports.eval = create(EvalError);
        module.exports.range = create(RangeError);
        module.exports.reference = create(ReferenceError);
        module.exports.syntax = create(SyntaxError);
        module.exports.type = create(TypeError);
        module.exports.uri = create(URIError);
        module.exports.formatter = util.format;
        /**
 * Creates a new {@link ono} function that creates the given Error class.
 *
 * @param {Class} Klass - The Error subclass to create
 * @returns {ono}
 */
        function create(Klass) {
          /**
   * @param {Error}   [err]     - The original error, if any
   * @param {object}  [props]   - An object whose properties will be added to the error object
   * @param {string}  [message] - The error message. May contain {@link util#format} placeholders
   * @param {...*}    [params]  - Parameters that map to the `message` placeholders
   * @returns {Error}
   */
          return function ono(err, props, message, params) {
            var formattedMessage;
            var formatter = module.exports.formatter;
            if (typeof err === 'string') {
              formattedMessage = formatter.apply(null, arguments);
              err = props = undefined;
            } else if (typeof props === 'string') {
              formattedMessage = formatter.apply(null, slice.call(arguments, 1));
            } else {
              formattedMessage = formatter.apply(null, slice.call(arguments, 2));
            }
            if (!(err instanceof Error)) {
              props = err;
              err = undefined;
            }
            if (err) {
              // The inner-error's message will be added to the new message
              formattedMessage += (formattedMessage ? ' \n' : '') + err.message;
            }
            // Create the new error
            // NOTE: DON'T move this to a separate function! We don't want to pollute the stack trace
            var newError = new Klass(formattedMessage);
            // Extend the new error with the additional properties
            extendError(newError, err);
            // Copy properties of the original error
            extendToJSON(newError);
            // Replace the original toJSON method
            extend(newError, props);
            // Copy custom properties, possibly including a custom toJSON method
            return newError;
          };
        }
        /**
 * Extends the targetError with the properties of the source error.
 *
 * @param {Error}   targetError - The error object to extend
 * @param {?Error}  sourceError - The source error object, if any
 */
        function extendError(targetError, sourceError) {
          if (sourceError) {
            extendStack(targetError, sourceError);
            extend(targetError, sourceError, true);
          }
        }
        /**
 * JavaScript engines differ in how errors are serialized to JSON - especially when it comes
 * to custom error properties and stack traces.  So we add our own toJSON method that ALWAYS
 * outputs every property of the error.
 */
        function extendToJSON(error) {
          error.toJSON = errorToJSON;
          // Also add an inspect() method, for compatibility with Node.js' `util.inspect()` method
          error.inspect = errorToString;
        }
        /**
 * Extends the target object with the properties of the source object.
 *
 * @param {object}  target - The object to extend
 * @param {?source} source - The object whose properties are copied
 * @param {boolean} omitVendorSpecificProperties - Skip vendor-specific Error properties
 */
        function extend(target, source, omitVendorSpecificProperties) {
          if (source && typeof source === 'object') {
            var keys = Object.keys(source);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              // Don't bother trying to copy read-only vendor-specific Error properties
              if (omitVendorSpecificProperties && vendorSpecificErrorProperties.indexOf(key) >= 0) {
                continue;
              }
              try {
                target[key] = source[key];
              } catch (e) {
              }
            }
          }
        }
        /**
 * Custom JSON serializer for Error objects.
 * Returns all built-in error properties, as well as extended properties.
 *
 * @returns {object}
 */
        function errorToJSON() {
          // jshint -W040
          var json = {};
          // Get all the properties of this error
          var keys = Object.keys(this);
          // Also include vendor-specific properties from the prototype
          keys = keys.concat(vendorSpecificErrorProperties);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this[key];
            var type = typeof value;
            if (type !== 'undefined' && type !== 'function') {
              json[key] = value;
            }
          }
          return json;
        }
        /**
 * Serializes Error objects as human-readable JSON strings for debugging/logging purposes.
 *
 * @returns {string}
 */
        function errorToString() {
          // jshint -W040
          return JSON.stringify(this, null, 2).replace(/\\n/g, '\n');
        }
        /**
 * Extend the error stack to include its cause
 */
        function extendStack(targetError, sourceError) {
          if (hasLazyStack(sourceError)) {
            extendStackProperty(targetError, sourceError);
          } else {
            var stack = sourceError.stack;
            if (stack) {
              targetError.stack += ' \n\n' + sourceError.stack;
            }
          }
        }
        /**
 * Does a one-time determination of whether this JavaScript engine
 * supports lazy `Error.stack` properties.
 */
        var supportsLazyStack = function () {
            return !!(Object.getOwnPropertyDescriptor && Object.defineProperty && (typeof navigator === 'undefined' || !/Android/.test(navigator.userAgent)));
          }();
        /**
 * Does this error have a lazy stack property?
 *
 * @returns {boolean}
 */
        function hasLazyStack(err) {
          if (!supportsLazyStack) {
            return false;
          }
          var descriptor = Object.getOwnPropertyDescriptor(err, 'stack');
          if (!descriptor) {
            return false;
          }
          return typeof descriptor.get === 'function';
        }
        /**
 * Extend the error stack to include its cause, lazily
 */
        function extendStackProperty(targetError, sourceError) {
          var sourceStack = Object.getOwnPropertyDescriptor(sourceError, 'stack');
          if (sourceStack) {
            var targetStack = Object.getOwnPropertyDescriptor(targetError, 'stack');
            Object.defineProperty(targetError, 'stack', {
              get: function () {
                return targetStack.get.apply(targetError) + ' \n\n' + sourceError.stack;
              },
              enumerable: false,
              configurable: true
            });
          }
        }
      },
      { 'util': 150 }
    ],
    114: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
            module.exports = nextTick;
          } else {
            module.exports = process.nextTick;
          }
          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== 'function') {
              throw new TypeError('"callback" argument must be a function');
            }
            var len = arguments.length;
            var args, i;
            switch (len) {
            case 0:
            case 1:
              return process.nextTick(fn);
            case 2:
              return process.nextTick(function afterTickOne() {
                fn.call(null, arg1);
              });
            case 3:
              return process.nextTick(function afterTickTwo() {
                fn.call(null, arg1, arg2);
              });
            case 4:
              return process.nextTick(function afterTickThree() {
                fn.call(null, arg1, arg2, arg3);
              });
            default:
              args = new Array(len - 1);
              i = 0;
              while (i < args.length) {
                args[i++] = arguments[i];
              }
              return process.nextTick(function afterTick() {
                fn.apply(null, args);
              });
            }
          }
        }.call(this, require('_process')));
      },
      { '_process': 115 }
    ],
    115: [
      function (require, module, exports) {
        // shim for using process in browser
        var process = module.exports = {};
        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout() {
          throw new Error('clearTimeout has not been defined');
        }
        (function () {
          try {
            if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        }());
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = '';
        // empty string to avoid regexp issues
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.binding = function (name) {
          throw new Error('process.binding is not supported');
        };
        process.cwd = function () {
          return '/';
        };
        process.chdir = function (dir) {
          throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
          return 0;
        };
      },
      {}
    ],
    116: [
      function (require, module, exports) {
        (function (global) {
          /*! https://mths.be/punycode v1.4.1 by @mathias */
          ;
          (function (root) {
            /** Detect free variables */
            var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
            var freeModule = typeof module == 'object' && module && !module.nodeType && module;
            var freeGlobal = typeof global == 'object' && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
              root = freeGlobal;
            }
            /**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
            var punycode,
              /** Highest positive signed 32-bit float value */
              maxInt = 2147483647,
              // aka. 0x7FFFFFFF or 2^31-1
              /** Bootstring parameters */
              base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128,
              // 0x80
              delimiter = '-',
              // '\x2D'
              /** Regular expressions */
              regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/,
              // unprintable ASCII chars + non-ASCII chars
              regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
              // RFC 3490 separators
              /** Error messages */
              errors = {
                'overflow': 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input'
              },
              /** Convenience shortcuts */
              baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode,
              /** Temporary variable */
              key;
            /*--------------------------------------------------------------------------*/
            /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
            function error(type) {
              throw new RangeError(errors[type]);
            }
            /**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
            function map(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }
            /**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
            function mapDomain(string, fn) {
              var parts = string.split('@');
              var result = '';
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '.');
              var labels = string.split('.');
              var encoded = map(labels, fn).join('.');
              return result + encoded;
            }
            /**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
            function ucs2decode(string) {
              var output = [], counter = 0, length = string.length, value, extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 55296 && value <= 56319 && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++);
                  if ((extra & 64512) == 56320) {
                    // low surrogate
                    output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }
            /**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
            function ucs2encode(array) {
              return map(array, function (value) {
                var output = '';
                if (value > 65535) {
                  value -= 65536;
                  output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                  value = 56320 | value & 1023;
                }
                output += stringFromCharCode(value);
                return output;
              }).join('');
            }
            /**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }
            /**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }
            /**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }
            /**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
            function decode(input) {
              // Don't use UCS-2
              var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t,
                /** Cached calculation results */
                baseMinusT;
              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.
              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }
              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 128) {
                  error('not-basic');
                }
                output.push(input.charCodeAt(j));
              }
              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.
              for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; k += base) {
                  if (index >= inputLength) {
                    error('invalid-input');
                  }
                  digit = basicToDigit(input.charCodeAt(index++));
                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                  }
                  i += digit * w;
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (digit < t) {
                    break;
                  }
                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                  }
                  w *= baseMinusT;
                }
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error('overflow');
                }
                n += floor(i / out);
                i %= out;
                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
              }
              return ucs2encode(output);
            }
            /**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
            function encode(input) {
              var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne, baseMinusT, qMinusT;
              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input);
              // Cache the length
              inputLength = input.length;
              // Initialize the state
              n = initialN;
              delta = 0;
              bias = initialBias;
              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 128) {
                  output.push(stringFromCharCode(currentValue));
                }
              }
              handledCPCount = basicLength = output.length;
              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.
              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter);
              }
              // Main encoding loop:
              while (handledCPCount < inputLength) {
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }
                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow');
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                  }
                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base;; k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                      q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }
                ++delta;
                ++n;
              }
              return output.join('');
            }
            /**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
            function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
              });
            }
            /**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
            function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
              });
            }
            /*--------------------------------------------------------------------------*/
            /** Define the public API */
            punycode = {
              'version': '1.4.1',
              'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
              },
              'decode': decode,
              'encode': encode,
              'toASCII': toASCII,
              'toUnicode': toUnicode
            };
            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
              define('punycode', function () {
                return punycode;
              });
            } else if (freeExports && freeModule) {
              if (module.exports == freeExports) {
                // in Node.js, io.js, or RingoJS v0.8.0+
                freeModule.exports = punycode;
              } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
              }
            } else {
              // in Rhino or a web browser
              root.punycode = punycode;
            }
          }(this));
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    117: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        'use strict';
        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function (qs, sep, eq, options) {
          sep = sep || '&';
          eq = eq || '=';
          var obj = {};
          if (typeof qs !== 'string' || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1000;
          if (options && typeof options.maxKeys === 'number') {
            maxKeys = options.maxKeys;
          }
          var len = qs.length;
          // maxKeys <= 0 means that we should not limit keys count
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, '%20'), idx = x.indexOf(eq), kstr, vstr, k, v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = '';
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [
                obj[k],
                v
              ];
            }
          }
          return obj;
        };
        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
          };
      },
      {}
    ],
    118: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        'use strict';
        var stringifyPrimitive = function (v) {
          switch (typeof v) {
          case 'string':
            return v;
          case 'boolean':
            return v ? 'true' : 'false';
          case 'number':
            return isFinite(v) ? v : '';
          default:
            return '';
          }
        };
        module.exports = function (obj, sep, eq, name) {
          sep = sep || '&';
          eq = eq || '=';
          if (obj === null) {
            obj = undefined;
          }
          if (typeof obj === 'object') {
            return map(objectKeys(obj), function (k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function (v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name)
            return '';
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
          };
        function map(xs, f) {
          if (xs.map)
            return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }
        var objectKeys = Object.keys || function (obj) {
            var res = [];
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                res.push(key);
            }
            return res;
          };
      },
      {}
    ],
    119: [
      function (require, module, exports) {
        'use strict';
        exports.decode = exports.parse = require('./decode');
        exports.encode = exports.stringify = require('./encode');
      },
      {
        './decode': 117,
        './encode': 118
      }
    ],
    120: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        module.exports = Stream;
        var EE = require('events').EventEmitter;
        var inherits = require('inherits');
        inherits(Stream, EE);
        Stream.Readable = require('readable-stream/readable.js');
        Stream.Writable = require('readable-stream/writable.js');
        Stream.Duplex = require('readable-stream/duplex.js');
        Stream.Transform = require('readable-stream/transform.js');
        Stream.PassThrough = require('readable-stream/passthrough.js');
        // Backwards-compat with node 0.4.x
        Stream.Stream = Stream;
        // old-style streams.  Note that the pipe method (the only relevant
        // part of this class) is overridden in the Readable class.
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function (dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on('data', ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on('drain', ondrain);
          // If the 'end' option is not supplied, dest.end() will be called when
          // source gets the 'end' or 'close' events.  Only dest.end() once.
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on('end', onend);
            source.on('close', onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === 'function')
              dest.destroy();
          }
          // don't leave dangling pipes when there are errors.
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, 'error') === 0) {
              throw er;  // Unhandled stream error in pipe.
            }
          }
          source.on('error', onerror);
          dest.on('error', onerror);
          // remove all the event listeners that were added.
          function cleanup() {
            source.removeListener('data', ondata);
            dest.removeListener('drain', ondrain);
            source.removeListener('end', onend);
            source.removeListener('close', onclose);
            source.removeListener('error', onerror);
            dest.removeListener('error', onerror);
            source.removeListener('end', cleanup);
            source.removeListener('close', cleanup);
            dest.removeListener('close', cleanup);
          }
          source.on('end', cleanup);
          source.on('close', cleanup);
          dest.on('close', cleanup);
          dest.emit('pipe', source);
          // Allow for unix-like usage: A.pipe(B).pipe(C)
          return dest;
        };
      },
      {
        'events': 49,
        'inherits': 54,
        'readable-stream/duplex.js': 122,
        'readable-stream/passthrough.js': 129,
        'readable-stream/readable.js': 130,
        'readable-stream/transform.js': 131,
        'readable-stream/writable.js': 132
      }
    ],
    121: [
      function (require, module, exports) {
        arguments[4][42][0].apply(exports, arguments);
      },
      { 'dup': 42 }
    ],
    122: [
      function (require, module, exports) {
        module.exports = require('./lib/_stream_duplex.js');
      },
      { './lib/_stream_duplex.js': 123 }
    ],
    123: [
      function (require, module, exports) {
        // a duplex stream is just a stream that is both readable and writable.
        // Since JS doesn't have multiple prototypal inheritance, this class
        // prototypally inherits from Readable, and then parasitically from
        // Writable.
        'use strict';
        /*<replacement>*/
        var objectKeys = Object.keys || function (obj) {
            var keys = [];
            for (var key in obj) {
              keys.push(key);
            }
            return keys;
          };
        /*</replacement>*/
        module.exports = Duplex;
        /*<replacement>*/
        var processNextTick = require('process-nextick-args');
        /*</replacement>*/
        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/
        var Readable = require('./_stream_readable');
        var Writable = require('./_stream_writable');
        util.inherits(Duplex, Readable);
        var keys = objectKeys(Writable.prototype);
        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options && options.readable === false)
            this.readable = false;
          if (options && options.writable === false)
            this.writable = false;
          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;
          this.once('end', onend);
        }
        // the no-half-open enforcer
        function onend() {
          // if we allow half-open state, or if the writable side ended,
          // then we're ok.
          if (this.allowHalfOpen || this._writableState.ended)
            return;
          // no more data can be written.
          // But allow more writes to happen in this tick.
          processNextTick(onEndNT, this);
        }
        function onEndNT(self) {
          self.end();
        }
        function forEach(xs, f) {
          for (var i = 0, l = xs.length; i < l; i++) {
            f(xs[i], i);
          }
        }
      },
      {
        './_stream_readable': 125,
        './_stream_writable': 127,
        'core-util-is': 45,
        'inherits': 54,
        'process-nextick-args': 114
      }
    ],
    124: [
      function (require, module, exports) {
        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.
        'use strict';
        module.exports = PassThrough;
        var Transform = require('./_stream_transform');
        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function (chunk, encoding, cb) {
          cb(null, chunk);
        };
      },
      {
        './_stream_transform': 126,
        'core-util-is': 45,
        'inherits': 54
      }
    ],
    125: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          module.exports = Readable;
          /*<replacement>*/
          var processNextTick = require('process-nextick-args');
          /*</replacement>*/
          /*<replacement>*/
          var isArray = require('isarray');
          /*</replacement>*/
          Readable.ReadableState = ReadableState;
          /*<replacement>*/
          var EE = require('events').EventEmitter;
          var EElistenerCount = function (emitter, type) {
            return emitter.listeners(type).length;
          };
          /*</replacement>*/
          /*<replacement>*/
          var Stream;
          (function () {
            try {
              Stream = require('st' + 'ream');
            } catch (_) {
            } finally {
              if (!Stream)
                Stream = require('events').EventEmitter;
            }
          }());
          /*</replacement>*/
          var Buffer = require('buffer').Buffer;
          /*<replacement>*/
          var bufferShim = require('buffer-shims');
          /*</replacement>*/
          /*<replacement>*/
          var util = require('core-util-is');
          util.inherits = require('inherits');
          /*</replacement>*/
          /*<replacement>*/
          var debugUtil = require('util');
          var debug = void 0;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog('stream');
          } else {
            debug = function () {
            };
          }
          /*</replacement>*/
          var BufferList = require('./internal/streams/BufferList');
          var StringDecoder;
          util.inherits(Readable, Stream);
          function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === 'function') {
              return emitter.prependListener(event, fn);
            } else {
              // This is a hack to make sure that our error handler is attached before any
              // userland ones.  NEVER DO THIS. This is here only because this code needs
              // to continue to work with older versions of Node.js that do not include
              // the prependListener() method. The goal is to eventually remove this hack.
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [
                  fn,
                  emitter._events[event]
                ];
            }
          }
          var Duplex;
          function ReadableState(options, stream) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {};
            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode;
            if (stream instanceof Duplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
            // cast to ints.
            this.highWaterMark = ~~this.highWaterMark;
            // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;
            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            // when piping, we only care about 'readable' events that happen
            // after read()ing all the bytes and not getting any pushback.
            this.ranOut = false;
            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0;
            // if true, a maybeReadMore has been scheduled
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          var Duplex;
          function Readable(options) {
            Duplex = Duplex || require('./_stream_duplex');
            if (!(this instanceof Readable))
              return new Readable(options);
            this._readableState = new ReadableState(options, this);
            // legacy
            this.readable = true;
            if (options && typeof options.read === 'function')
              this._read = options.read;
            Stream.call(this);
          }
          // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.
          Readable.prototype.push = function (chunk, encoding) {
            var state = this._readableState;
            if (!state.objectMode && typeof chunk === 'string') {
              encoding = encoding || state.defaultEncoding;
              if (encoding !== state.encoding) {
                chunk = bufferShim.from(chunk, encoding);
                encoding = '';
              }
            }
            return readableAddChunk(this, state, chunk, encoding, false);
          };
          // Unshift should *always* be something directly out of read()
          Readable.prototype.unshift = function (chunk) {
            var state = this._readableState;
            return readableAddChunk(this, state, chunk, '', true);
          };
          Readable.prototype.isPaused = function () {
            return this._readableState.flowing === false;
          };
          function readableAddChunk(stream, state, chunk, encoding, addToFront) {
            var er = chunkInvalid(state, chunk);
            if (er) {
              stream.emit('error', er);
            } else if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (state.ended && !addToFront) {
                var e = new Error('stream.push() after EOF');
                stream.emit('error', e);
              } else if (state.endEmitted && addToFront) {
                var _e = new Error('stream.unshift() after end event');
                stream.emit('error', _e);
              } else {
                var skipAdd;
                if (state.decoder && !addToFront && !encoding) {
                  chunk = state.decoder.write(chunk);
                  skipAdd = !state.objectMode && chunk.length === 0;
                }
                if (!addToFront)
                  state.reading = false;
                // Don't add to the buffer if we've decoded to an empty string chunk and
                // we're not in object mode
                if (!skipAdd) {
                  // if we want the data now, just emit it.
                  if (state.flowing && state.length === 0 && !state.sync) {
                    stream.emit('data', chunk);
                    stream.read(0);
                  } else {
                    // update the buffer info.
                    state.length += state.objectMode ? 1 : chunk.length;
                    if (addToFront)
                      state.buffer.unshift(chunk);
                    else
                      state.buffer.push(chunk);
                    if (state.needReadable)
                      emitReadable(stream);
                  }
                }
                maybeReadMore(stream, state);
              }
            } else if (!addToFront) {
              state.reading = false;
            }
            return needMoreData(state);
          }
          // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.
          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }
          // backwards compatibility.
          Readable.prototype.setEncoding = function (enc) {
            if (!StringDecoder)
              StringDecoder = require('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
          };
          // Don't raise the hwm > 8MB
          var MAX_HWM = 8388608;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            // If we're asking for more than the current hwm, then raise the hwm.
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            // Don't have enough
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          // you can override either this method, or the async _read(n) below.
          Readable.prototype.read = function (n) {
            debug('read', n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              debug('read: emitReadable', state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.
            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable;
            debug('need readable', doRead);
            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug('length less than watermark', doRead);
            }
            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
              doRead = false;
              debug('reading or ended', doRead);
            } else if (doRead) {
              debug('do read');
              state.reading = true;
              state.sync = true;
              // if the length is currently zero, then we *need* a readable event.
              if (state.length === 0)
                state.needReadable = true;
              // call internal read method
              this._read(state.highWaterMark);
              state.sync = false;
              // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
            }
            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended)
                state.needReadable = true;
              // If we tried to read() past the EOF, then emit end on the next tick.
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit('data', ret);
            return ret;
          };
          function chunkInvalid(state, chunk) {
            var er = null;
            if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }
            return er;
          }
          function onEofChunk(stream, state) {
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream);
          }
          // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug('emitReadable', state.flowing);
              state.emittedReadable = true;
              if (state.sync)
                processNextTick(emitReadable_, stream);
              else
                emitReadable_(stream);
            }
          }
          function emitReadable_(stream) {
            debug('emit readable');
            stream.emit('readable');
            flow(stream);
          }
          // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              processNextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              debug('maybeReadMore read 0');
              stream.read(0);
              if (len === state.length)
                // didn't get any data, stop spinning.
                break;
              else
                len = state.length;
            }
            state.readingMore = false;
          }
          // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.
          Readable.prototype._read = function (n) {
            this.emit('error', new Error('not implemented'));
          };
          Readable.prototype.pipe = function (dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;
            case 1:
              state.pipes = [
                state.pipes,
                dest
              ];
              break;
            default:
              state.pipes.push(dest);
              break;
            }
            state.pipesCount += 1;
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : cleanup;
            if (state.endEmitted)
              processNextTick(endFn);
            else
              src.once('end', endFn);
            dest.on('unpipe', onunpipe);
            function onunpipe(readable) {
              debug('onunpipe');
              if (readable === src) {
                cleanup();
              }
            }
            function onend() {
              debug('onend');
              dest.end();
            }
            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug('cleanup');
              // cleanup event handlers once the pipe is broken
              dest.removeListener('close', onclose);
              dest.removeListener('finish', onfinish);
              dest.removeListener('drain', ondrain);
              dest.removeListener('error', onerror);
              dest.removeListener('unpipe', onunpipe);
              src.removeListener('end', onend);
              src.removeListener('end', cleanup);
              src.removeListener('data', ondata);
              cleanedUp = true;
              // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.
            var increasedAwaitDrain = false;
            src.on('data', ondata);
            function ondata(chunk) {
              debug('ondata');
              increasedAwaitDrain = false;
              var ret = dest.write(chunk);
              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug('false write response, pause', src._readableState.awaitDrain);
                  src._readableState.awaitDrain++;
                  increasedAwaitDrain = true;
                }
                src.pause();
              }
            }
            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
              debug('onerror', er);
              unpipe();
              dest.removeListener('error', onerror);
              if (EElistenerCount(dest, 'error') === 0)
                dest.emit('error', er);
            }
            // Make sure our error handler is attached before userland ones.
            prependListener(dest, 'error', onerror);
            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
              dest.removeListener('finish', onfinish);
              unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
              debug('onfinish');
              dest.removeListener('close', onclose);
              unpipe();
            }
            dest.once('finish', onfinish);
            function unpipe() {
              debug('unpipe');
              src.unpipe(dest);
            }
            // tell the dest that it's being piped to
            dest.emit('pipe', src);
            // start the flow if it hasn't been started already.
            if (!state.flowing) {
              debug('pipe resume');
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function () {
              var state = src._readableState;
              debug('pipeOnDrain', state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function (dest) {
            var state = this._readableState;
            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0)
              return this;
            // just one destination.  most common case.
            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              // got a match.
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit('unpipe', this);
              return this;
            }
            // slow case. multiple pipe destinations.
            if (!dest) {
              // remove all.
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var _i = 0; _i < len; _i++) {
                dests[_i].emit('unpipe', this);
              }
              return this;
            }
            // try to find the right one.
            var i = indexOf(state.pipes, dest);
            if (i === -1)
              return this;
            state.pipes.splice(i, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit('unpipe', this);
            return this;
          };
          // set up data events if they are asked for
          // Ensure readable listeners eventually get something
          Readable.prototype.on = function (ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === 'data') {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false)
                this.resume();
            } else if (ev === 'readable') {
              var state = this._readableState;
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.emittedReadable = false;
                if (!state.reading) {
                  processNextTick(nReadingNextTick, this);
                } else if (state.length) {
                  emitReadable(this, state);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          function nReadingNextTick(self) {
            debug('readable nexttick read 0');
            self.read(0);
          }
          // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.
          Readable.prototype.resume = function () {
            var state = this._readableState;
            if (!state.flowing) {
              debug('resume');
              state.flowing = true;
              resume(this, state);
            }
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              processNextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            if (!state.reading) {
              debug('resume read 0');
              stream.read(0);
            }
            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit('resume');
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function () {
            debug('call pause flowing=%j', this._readableState.flowing);
            if (false !== this._readableState.flowing) {
              debug('pause');
              this._readableState.flowing = false;
              this.emit('pause');
            }
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug('flow', state.flowing);
            while (state.flowing && stream.read() !== null) {
            }
          }
          // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.
          Readable.prototype.wrap = function (stream) {
            var state = this._readableState;
            var paused = false;
            var self = this;
            stream.on('end', function () {
              debug('wrapped end');
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  self.push(chunk);
              }
              self.push(null);
            });
            stream.on('data', function (chunk) {
              debug('wrapped data');
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              // don't skip over falsy values in objectMode
              if (state.objectMode && (chunk === null || chunk === undefined))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = self.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === 'function') {
                this[i] = function (method) {
                  return function () {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            // proxy certain important events.
            var events = [
                'error',
                'close',
                'destroy',
                'pause',
                'resume'
              ];
            forEach(events, function (ev) {
              stream.on(ev, self.emit.bind(self, ev));
            });
            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            self._read = function (n) {
              debug('wrapped _read', n);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return self;
          };
          // exposed for testing purposes only.
          Readable._fromList = fromList;
          // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder)
                ret = state.buffer.join('');
              else if (state.buffer.length === 1)
                ret = state.buffer.head.data;
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder);
            }
            return ret;
          }
          // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n);
              list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift();
            } else {
              // result spans more than one buffer
              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            }
            return ret;
          }
          // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBuffer(n, list) {
            var ret = bufferShim.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream');
            if (!state.endEmitted) {
              state.ended = true;
              processNextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit('end');
            }
          }
          function forEach(xs, f) {
            for (var i = 0, l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }.call(this, require('_process')));
      },
      {
        './_stream_duplex': 123,
        './internal/streams/BufferList': 128,
        '_process': 115,
        'buffer': 41,
        'buffer-shims': 40,
        'core-util-is': 45,
        'events': 49,
        'inherits': 54,
        'isarray': 121,
        'process-nextick-args': 114,
        'string_decoder/': 137,
        'util': 38
      }
    ],
    126: [
      function (require, module, exports) {
        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.
        'use strict';
        module.exports = Transform;
        var Duplex = require('./_stream_duplex');
        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/
        util.inherits(Transform, Duplex);
        function TransformState(stream) {
          this.afterTransform = function (er, data) {
            return afterTransform(stream, er, data);
          };
          this.needTransform = false;
          this.transforming = false;
          this.writecb = null;
          this.writechunk = null;
          this.writeencoding = null;
        }
        function afterTransform(stream, er, data) {
          var ts = stream._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb)
            return stream.emit('error', new Error('no writecb in Transform class'));
          ts.writechunk = null;
          ts.writecb = null;
          if (data !== null && data !== undefined)
            stream.push(data);
          cb(er);
          var rs = stream._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = new TransformState(this);
          // when the writable side finishes, then flush out anything remaining.
          var stream = this;
          // start out asking for a readable event once data is transformed.
          this._readableState.needReadable = true;
          // we have implemented the _read method, and done the other things
          // that Readable wants before the first _read call, so unset the
          // sync guard flag.
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === 'function')
              this._transform = options.transform;
            if (typeof options.flush === 'function')
              this._flush = options.flush;
          }
          this.once('prefinish', function () {
            if (typeof this._flush === 'function')
              this._flush(function (er) {
                done(stream, er);
              });
            else
              done(stream);
          });
        }
        Transform.prototype.push = function (chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function (chunk, encoding, cb) {
          throw new Error('Not implemented');
        };
        Transform.prototype._write = function (chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.
        Transform.prototype._read = function (n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true;
          }
        };
        function done(stream, er) {
          if (er)
            return stream.emit('error', er);
          // if there's nothing in the write buffer, then that means
          // that nothing more will ever be provided
          var ws = stream._writableState;
          var ts = stream._transformState;
          if (ws.length)
            throw new Error('Calling transform done when ws.length != 0');
          if (ts.transforming)
            throw new Error('Calling transform done when still transforming');
          return stream.push(null);
        }
      },
      {
        './_stream_duplex': 123,
        'core-util-is': 45,
        'inherits': 54
      }
    ],
    127: [
      function (require, module, exports) {
        (function (process) {
          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.
          'use strict';
          module.exports = Writable;
          /*<replacement>*/
          var processNextTick = require('process-nextick-args');
          /*</replacement>*/
          /*<replacement>*/
          var asyncWrite = !process.browser && [
              'v0.10',
              'v0.9.'
            ].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
          /*</replacement>*/
          Writable.WritableState = WritableState;
          /*<replacement>*/
          var util = require('core-util-is');
          util.inherits = require('inherits');
          /*</replacement>*/
          /*<replacement>*/
          var internalUtil = { deprecate: require('util-deprecate') };
          /*</replacement>*/
          /*<replacement>*/
          var Stream;
          (function () {
            try {
              Stream = require('st' + 'ream');
            } catch (_) {
            } finally {
              if (!Stream)
                Stream = require('events').EventEmitter;
            }
          }());
          /*</replacement>*/
          var Buffer = require('buffer').Buffer;
          /*<replacement>*/
          var bufferShim = require('buffer-shims');
          /*</replacement>*/
          util.inherits(Writable, Stream);
          function nop() {
          }
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          }
          var Duplex;
          function WritableState(options, stream) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {};
            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode;
            if (stream instanceof Duplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
            // cast to ints.
            this.highWaterMark = ~~this.highWaterMark;
            this.needDrain = false;
            // at the start of calling end()
            this.ending = false;
            // when end() has been called, and returned
            this.ended = false;
            // when 'finish' is emitted
            this.finished = false;
            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0;
            // a flag to see when we're in the middle of a write.
            this.writing = false;
            // when true all writes will be buffered until .uncork() call
            this.corked = 0;
            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;
            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false;
            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function (er) {
              onwrite(stream, er);
            };
            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null;
            // the amount that is being written when _write is called.
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0;
            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false;
            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false;
            // count buffered requests
            this.bufferedRequestCount = 0;
            // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function writableStateGetBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function () {
            try {
              Object.defineProperty(WritableState.prototype, 'buffer', {
                get: internalUtil.deprecate(function () {
                  return this.getBuffer();
                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
              });
            } catch (_) {
            }
          }());
          var Duplex;
          function Writable(options) {
            Duplex = Duplex || require('./_stream_duplex');
            // Writable ctor is applied to Duplexes, though they're not
            // instanceof Writable, they're instanceof Readable.
            if (!(this instanceof Writable) && !(this instanceof Duplex))
              return new Writable(options);
            this._writableState = new WritableState(options, this);
            // legacy.
            this.writable = true;
            if (options) {
              if (typeof options.write === 'function')
                this._write = options.write;
              if (typeof options.writev === 'function')
                this._writev = options.writev;
            }
            Stream.call(this);
          }
          // Otherwise people can pipe Writable streams, which is just wrong.
          Writable.prototype.pipe = function () {
            this.emit('error', new Error('Cannot pipe, not readable'));
          };
          function writeAfterEnd(stream, cb) {
            var er = new Error('write after end');
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit('error', er);
            processNextTick(cb, er);
          }
          // If we get something that is not a buffer, string, null, or undefined,
          // and we're not in objectMode, then that's an error.
          // Otherwise stream chunks are all considered to be of length=1, and the
          // watermarks determine how many objects to keep in the buffer, rather than
          // how many bytes or characters.
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;
            // Always throw error if a null is written
            // if we are not in object mode then throw
            // if it is not a buffer, string, or undefined.
            if (chunk === null) {
              er = new TypeError('May not write null values to stream');
            } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }
            if (er) {
              stream.emit('error', er);
              processNextTick(cb, er);
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function (chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== 'function')
              cb = nop;
            if (state.ended)
              writeAfterEnd(this, cb);
            else if (validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function () {
            var state = this._writableState;
            state.corked++;
          };
          Writable.prototype.uncork = function () {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === 'string')
              encoding = encoding.toLowerCase();
            if (!([
                'hex',
                'utf8',
                'utf-8',
                'ascii',
                'binary',
                'base64',
                'ucs2',
                'ucs-2',
                'utf16le',
                'utf-16le',
                'raw'
              ].indexOf((encoding + '').toLowerCase()) > -1))
              throw new TypeError('Unknown encoding: ' + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = bufferShim.from(chunk, encoding);
            }
            return chunk;
          }
          // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.
          function writeOrBuffer(stream, state, chunk, encoding, cb) {
            chunk = decodeChunk(state, chunk, encoding);
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync)
              processNextTick(cb, er);
            else
              cb(er);
            stream._writableState.errorEmitted = true;
            stream.emit('error', er);
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state);
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb);  /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          }
          // if there's something in the buffer waiting, then process it
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              while (entry) {
                buffer[count] = entry;
                entry = entry.next;
                count += 1;
              }
              doWrite(stream, state, true, state.length, buffer, '', holder.finish);
              // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequestCount = 0;
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function (chunk, encoding, cb) {
            cb(new Error('not implemented'));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function (chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== undefined)
              this.write(chunk, encoding);
            // .end() fully uncorks
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished)
              endWritable(this, state, cb);
          };
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function prefinish(stream, state) {
            if (!state.prefinished) {
              state.prefinished = true;
              stream.emit('prefinish');
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              if (state.pendingcb === 0) {
                prefinish(stream, state);
                state.finished = true;
                stream.emit('finish');
              } else {
                prefinish(stream, state);
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                processNextTick(cb);
              else
                stream.once('finish', cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          // It seems a linked list but it is not
          // there will be only 2 of these for each stream
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function (err) {
              var entry = _this.entry;
              _this.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              if (state.corkedRequestsFree) {
                state.corkedRequestsFree.next = _this;
              } else {
                state.corkedRequestsFree = _this;
              }
            };
          }
        }.call(this, require('_process')));
      },
      {
        './_stream_duplex': 123,
        '_process': 115,
        'buffer': 41,
        'buffer-shims': 40,
        'core-util-is': 45,
        'events': 49,
        'inherits': 54,
        'process-nextick-args': 114,
        'util-deprecate': 147
      }
    ],
    128: [
      function (require, module, exports) {
        'use strict';
        var Buffer = require('buffer').Buffer;
        /*<replacement>*/
        var bufferShim = require('buffer-shims');
        /*</replacement>*/
        module.exports = BufferList;
        function BufferList() {
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        BufferList.prototype.push = function (v) {
          var entry = {
              data: v,
              next: null
            };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        };
        BufferList.prototype.unshift = function (v) {
          var entry = {
              data: v,
              next: this.head
            };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        };
        BufferList.prototype.shift = function () {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        };
        BufferList.prototype.clear = function () {
          this.head = this.tail = null;
          this.length = 0;
        };
        BufferList.prototype.join = function (s) {
          if (this.length === 0)
            return '';
          var p = this.head;
          var ret = '' + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        };
        BufferList.prototype.concat = function (n) {
          if (this.length === 0)
            return bufferShim.alloc(0);
          if (this.length === 1)
            return this.head.data;
          var ret = bufferShim.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            p.data.copy(ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        };
      },
      {
        'buffer': 41,
        'buffer-shims': 40
      }
    ],
    129: [
      function (require, module, exports) {
        module.exports = require('./lib/_stream_passthrough.js');
      },
      { './lib/_stream_passthrough.js': 124 }
    ],
    130: [
      function (require, module, exports) {
        (function (process) {
          var Stream = function () {
              try {
                return require('st' + 'ream');  // hack to fix a circular dependency issue when used with browserify
              } catch (_) {
              }
            }();
          exports = module.exports = require('./lib/_stream_readable.js');
          exports.Stream = Stream || exports;
          exports.Readable = exports;
          exports.Writable = require('./lib/_stream_writable.js');
          exports.Duplex = require('./lib/_stream_duplex.js');
          exports.Transform = require('./lib/_stream_transform.js');
          exports.PassThrough = require('./lib/_stream_passthrough.js');
          if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
            module.exports = Stream;
          }
        }.call(this, require('_process')));
      },
      {
        './lib/_stream_duplex.js': 123,
        './lib/_stream_passthrough.js': 124,
        './lib/_stream_readable.js': 125,
        './lib/_stream_transform.js': 126,
        './lib/_stream_writable.js': 127,
        '_process': 115
      }
    ],
    131: [
      function (require, module, exports) {
        module.exports = require('./lib/_stream_transform.js');
      },
      { './lib/_stream_transform.js': 126 }
    ],
    132: [
      function (require, module, exports) {
        module.exports = require('./lib/_stream_writable.js');
      },
      { './lib/_stream_writable.js': 127 }
    ],
    133: [
      function (require, module, exports) {
        var ClientRequest = require('./lib/request');
        var extend = require('xtend');
        var statusCodes = require('builtin-status-codes');
        var url = require('url');
        var http = exports;
        http.request = function (opts, cb) {
          if (typeof opts === 'string')
            opts = url.parse(opts);
          else
            opts = extend(opts);
          var protocol = opts.protocol || '';
          var host = opts.hostname || opts.host;
          var port = opts.port;
          var path = opts.path || '/';
          // Necessary for IPv6 addresses
          if (host && host.indexOf(':') !== -1)
            host = '[' + host + ']';
          // This may be a relative url. The browser should always be able to interpret it correctly.
          opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
          opts.method = (opts.method || 'GET').toUpperCase();
          opts.headers = opts.headers || {};
          // Also valid opts.auth, opts.mode
          var req = new ClientRequest(opts);
          if (cb)
            req.on('response', cb);
          return req;
        };
        http.get = function get(opts, cb) {
          var req = http.request(opts, cb);
          req.end();
          return req;
        };
        http.Agent = function () {
        };
        http.Agent.defaultMaxSockets = 4;
        http.STATUS_CODES = statusCodes;
        http.METHODS = [
          'CHECKOUT',
          'CONNECT',
          'COPY',
          'DELETE',
          'GET',
          'HEAD',
          'LOCK',
          'M-SEARCH',
          'MERGE',
          'MKACTIVITY',
          'MKCOL',
          'MOVE',
          'NOTIFY',
          'OPTIONS',
          'PATCH',
          'POST',
          'PROPFIND',
          'PROPPATCH',
          'PURGE',
          'PUT',
          'REPORT',
          'SEARCH',
          'SUBSCRIBE',
          'TRACE',
          'UNLOCK',
          'UNSUBSCRIBE'
        ];
      },
      {
        './lib/request': 135,
        'builtin-status-codes': 43,
        'url': 146,
        'xtend': 215
      }
    ],
    134: [
      function (require, module, exports) {
        (function (global) {
          exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream);
          exports.blobConstructor = false;
          try {
            new Blob([new ArrayBuffer(1)]);
            exports.blobConstructor = true;
          } catch (e) {
          }
          var xhr = new global.XMLHttpRequest();
          // If location.host is empty, e.g. if this page/worker was loaded
          // from a Blob, then use example.com to avoid an error
          xhr.open('GET', global.location.host ? '/' : 'https://example.com');
          function checkTypeSupport(type) {
            try {
              xhr.responseType = type;
              return xhr.responseType === type;
            } catch (e) {
            }
            return false;
          }
          // For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
          // Safari 7.1 appears to have fixed this bug.
          var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';
          var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);
          exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer');
          // These next two tests unavoidably show warnings in Chrome. Since fetch will always
          // be used if it's available, just return false for these to avoid the warnings.
          exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');
          exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport('moz-chunked-arraybuffer');
          exports.overrideMimeType = isFunction(xhr.overrideMimeType);
          exports.vbArray = isFunction(global.VBArray);
          function isFunction(value) {
            return typeof value === 'function';
          }
          xhr = null;
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    135: [
      function (require, module, exports) {
        (function (process, global, Buffer) {
          // var Base64 = require('Base64')
          var capability = require('./capability');
          var foreach = require('foreach');
          var indexOf = require('indexof');
          var inherits = require('inherits');
          var keys = require('object-keys');
          var response = require('./response');
          var stream = require('stream');
          var IncomingMessage = response.IncomingMessage;
          var rStates = response.readyStates;
          function decideMode(preferBinary) {
            if (capability.fetch) {
              return 'fetch';
            } else if (capability.mozchunkedarraybuffer) {
              return 'moz-chunked-arraybuffer';
            } else if (capability.msstream) {
              return 'ms-stream';
            } else if (capability.arraybuffer && preferBinary) {
              return 'arraybuffer';
            } else if (capability.vbArray && preferBinary) {
              return 'text:vbarray';
            } else {
              return 'text';
            }
          }
          var ClientRequest = module.exports = function (opts) {
              var self = this;
              stream.Writable.call(self);
              self._opts = opts;
              self._body = [];
              self._headers = {};
              if (opts.auth)
                self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
              foreach(keys(opts.headers), function (name) {
                self.setHeader(name, opts.headers[name]);
              });
              var preferBinary;
              if (opts.mode === 'prefer-streaming') {
                // If streaming is a high priority but binary compatibility and
                // the accuracy of the 'content-type' header aren't
                preferBinary = false;
              } else if (opts.mode === 'allow-wrong-content-type') {
                // If streaming is more important than preserving the 'content-type' header
                preferBinary = !capability.overrideMimeType;
              } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
                // Use binary if text streaming may corrupt data or the content-type header, or for speed
                preferBinary = true;
              } else {
                throw new Error('Invalid value for opts.mode');
              }
              self._mode = decideMode(preferBinary);
              self.on('finish', function () {
                self._onFinish();
              });
            };
          inherits(ClientRequest, stream.Writable);
          ClientRequest.prototype.setHeader = function (name, value) {
            var self = this;
            var lowerName = name.toLowerCase();
            // This check is not necessary, but it prevents warnings from browsers about setting unsafe
            // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
            // http-browserify did it, so I will too.
            if (indexOf(unsafeHeaders, lowerName) !== -1)
              return;
            self._headers[lowerName] = {
              name: name,
              value: value
            };
          };
          ClientRequest.prototype.getHeader = function (name) {
            var self = this;
            return self._headers[name.toLowerCase()].value;
          };
          ClientRequest.prototype.removeHeader = function (name) {
            var self = this;
            delete self._headers[name.toLowerCase()];
          };
          ClientRequest.prototype._onFinish = function () {
            var self = this;
            if (self._destroyed)
              return;
            var opts = self._opts;
            var headersObj = self._headers;
            var body;
            if (opts.method === 'POST' || opts.method === 'PUT') {
              if (capability.blobConstructor) {
                body = new global.Blob(self._body.map(function (buffer) {
                  return buffer.toArrayBuffer();
                }), { type: (headersObj['content-type'] || {}).value || '' });
              } else {
                // get utf8 string
                body = Buffer.concat(self._body).toString();
              }
            }
            if (self._mode === 'fetch') {
              var headers = keys(headersObj).map(function (name) {
                  return [
                    headersObj[name].name,
                    headersObj[name].value
                  ];
                });
              global.fetch(self._opts.url, {
                method: self._opts.method,
                headers: headers,
                body: body,
                mode: 'cors',
                credentials: opts.withCredentials ? 'include' : 'same-origin'
              }).then(function (response) {
                self._fetchResponse = response;
                self._connect();
              }).then(undefined, function (reason) {
                self.emit('error', reason);
              });
            } else {
              var xhr = self._xhr = new global.XMLHttpRequest();
              try {
                xhr.open(self._opts.method, self._opts.url, true);
              } catch (err) {
                process.nextTick(function () {
                  self.emit('error', err);
                });
                return;
              }
              // Can't set responseType on really old browsers
              if ('responseType' in xhr)
                xhr.responseType = self._mode.split(':')[0];
              if ('withCredentials' in xhr)
                xhr.withCredentials = !!opts.withCredentials;
              if (self._mode === 'text' && 'overrideMimeType' in xhr)
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              foreach(keys(headersObj), function (name) {
                xhr.setRequestHeader(headersObj[name].name, headersObj[name].value);
              });
              self._response = null;
              xhr.onreadystatechange = function () {
                switch (xhr.readyState) {
                case rStates.LOADING:
                case rStates.DONE:
                  self._onXHRProgress();
                  break;
                }
              };
              // Necessary for streaming in Firefox, since xhr.response is ONLY defined
              // in onprogress, not in onreadystatechange with xhr.readyState = 3
              if (self._mode === 'moz-chunked-arraybuffer') {
                xhr.onprogress = function () {
                  self._onXHRProgress();
                };
              }
              xhr.onerror = function () {
                if (self._destroyed)
                  return;
                self.emit('error', new Error('XHR error'));
              };
              try {
                xhr.send(body);
              } catch (err) {
                process.nextTick(function () {
                  self.emit('error', err);
                });
                return;
              }
            }
          };
          /**
 * Checks if xhr.status is readable. Even though the spec says it should
 * be available in readyState 3, accessing it throws an exception in IE8
 */
          function statusValid(xhr) {
            try {
              return xhr.status !== null;
            } catch (e) {
              return false;
            }
          }
          ClientRequest.prototype._onXHRProgress = function () {
            var self = this;
            if (!statusValid(self._xhr) || self._destroyed)
              return;
            if (!self._response)
              self._connect();
            self._response._onXHRProgress();
          };
          ClientRequest.prototype._connect = function () {
            var self = this;
            if (self._destroyed)
              return;
            self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode);
            self.emit('response', self._response);
          };
          ClientRequest.prototype._write = function (chunk, encoding, cb) {
            var self = this;
            self._body.push(chunk);
            cb();
          };
          ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
            var self = this;
            self._destroyed = true;
            if (self._response)
              self._response._destroyed = true;
            if (self._xhr)
              self._xhr.abort();
          };
          ClientRequest.prototype.end = function (data, encoding, cb) {
            var self = this;
            if (typeof data === 'function') {
              cb = data;
              data = undefined;
            }
            stream.Writable.prototype.end.call(self, data, encoding, cb);
          };
          ClientRequest.prototype.flushHeaders = function () {
          };
          ClientRequest.prototype.setTimeout = function () {
          };
          ClientRequest.prototype.setNoDelay = function () {
          };
          ClientRequest.prototype.setSocketKeepAlive = function () {
          };
          // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
          var unsafeHeaders = [
              'accept-charset',
              'accept-encoding',
              'access-control-request-headers',
              'access-control-request-method',
              'connection',
              'content-length',
              'cookie',
              'cookie2',
              'date',
              'dnt',
              'expect',
              'host',
              'keep-alive',
              'origin',
              'referer',
              'te',
              'trailer',
              'transfer-encoding',
              'upgrade',
              'user-agent',
              'via'
            ];
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('buffer').Buffer));
      },
      {
        './capability': 134,
        './response': 136,
        '_process': 115,
        'buffer': 41,
        'foreach': 50,
        'indexof': 53,
        'inherits': 54,
        'object-keys': 111,
        'stream': 120
      }
    ],
    136: [
      function (require, module, exports) {
        (function (process, global, Buffer) {
          var capability = require('./capability');
          var foreach = require('foreach');
          var inherits = require('inherits');
          var stream = require('stream');
          var rStates = exports.readyStates = {
              UNSENT: 0,
              OPENED: 1,
              HEADERS_RECEIVED: 2,
              LOADING: 3,
              DONE: 4
            };
          var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
              var self = this;
              stream.Readable.call(self);
              self._mode = mode;
              self.headers = {};
              self.rawHeaders = [];
              self.trailers = {};
              self.rawTrailers = [];
              // Fake the 'close' event, but only once 'end' fires
              self.on('end', function () {
                // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
                process.nextTick(function () {
                  self.emit('close');
                });
              });
              if (mode === 'fetch') {
                self._fetchResponse = response;
                self.statusCode = response.status;
                self.statusMessage = response.statusText;
                // backwards compatible version of for (<item> of <iterable>):
                // for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
                for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
                  self.headers[header[0].toLowerCase()] = header[1];
                  self.rawHeaders.push(header[0], header[1]);
                }
                // TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
                var reader = response.body.getReader();
                function read() {
                  reader.read().then(function (result) {
                    if (self._destroyed)
                      return;
                    if (result.done) {
                      self.push(null);
                      return;
                    }
                    self.push(new Buffer(result.value));
                    read();
                  });
                }
                read();
              } else {
                self._xhr = xhr;
                self._pos = 0;
                self.statusCode = xhr.status;
                self.statusMessage = xhr.statusText;
                var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                foreach(headers, function (header) {
                  var matches = header.match(/^([^:]+):\s*(.*)/);
                  if (matches) {
                    var key = matches[1].toLowerCase();
                    if (self.headers[key] !== undefined)
                      self.headers[key] += ', ' + matches[2];
                    else
                      self.headers[key] = matches[2];
                    self.rawHeaders.push(matches[1], matches[2]);
                  }
                });
                self._charset = 'x-user-defined';
                if (!capability.overrideMimeType) {
                  var mimeType = self.rawHeaders['mime-type'];
                  if (mimeType) {
                    var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                    if (charsetMatch) {
                      self._charset = charsetMatch[1].toLowerCase();
                    }
                  }
                  if (!self._charset)
                    self._charset = 'utf-8';
                }
              }
            };
          inherits(IncomingMessage, stream.Readable);
          IncomingMessage.prototype._read = function () {
          };
          IncomingMessage.prototype._onXHRProgress = function () {
            var self = this;
            var xhr = self._xhr;
            var response = null;
            switch (self._mode) {
            case 'text:vbarray':
              // For IE9
              if (xhr.readyState !== rStates.DONE)
                break;
              try {
                // This fails in IE8
                response = new global.VBArray(xhr.responseBody).toArray();
              } catch (e) {
              }
              if (response !== null) {
                self.push(new Buffer(response));
                break;
              }
            // Falls through in IE8	
            case 'text':
              try {
                // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
                response = xhr.responseText;
              } catch (e) {
                self._mode = 'text:vbarray';
                break;
              }
              if (response.length > self._pos) {
                var newData = response.substr(self._pos);
                if (self._charset === 'x-user-defined') {
                  var buffer = new Buffer(newData.length);
                  for (var i = 0; i < newData.length; i++)
                    buffer[i] = newData.charCodeAt(i) & 255;
                  self.push(buffer);
                } else {
                  self.push(newData, self._charset);
                }
                self._pos = response.length;
              }
              break;
            case 'arraybuffer':
              if (xhr.readyState !== rStates.DONE)
                break;
              response = xhr.response;
              self.push(new Buffer(new Uint8Array(response)));
              break;
            case 'moz-chunked-arraybuffer':
              // take whole
              response = xhr.response;
              if (xhr.readyState !== rStates.LOADING || !response)
                break;
              self.push(new Buffer(new Uint8Array(response)));
              break;
            case 'ms-stream':
              response = xhr.response;
              if (xhr.readyState !== rStates.LOADING)
                break;
              var reader = new global.MSStreamReader();
              reader.onprogress = function () {
                if (reader.result.byteLength > self._pos) {
                  self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
                  self._pos = reader.result.byteLength;
                }
              };
              reader.onload = function () {
                self.push(null);
              };
              // reader.onerror = ??? // TODO: this
              reader.readAsArrayBuffer(response);
              break;
            }
            // The ms-stream case handles end separately in reader.onload()
            if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
              self.push(null);
            }
          };
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('buffer').Buffer));
      },
      {
        './capability': 134,
        '_process': 115,
        'buffer': 41,
        'foreach': 50,
        'inherits': 54,
        'stream': 120
      }
    ],
    137: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        var Buffer = require('buffer').Buffer;
        var isBufferEncoding = Buffer.isEncoding || function (encoding) {
            switch (encoding && encoding.toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
            case 'raw':
              return true;
            default:
              return false;
            }
          };
        function assertEncoding(encoding) {
          if (encoding && !isBufferEncoding(encoding)) {
            throw new Error('Unknown encoding: ' + encoding);
          }
        }
        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters. CESU-8 is handled as part of the UTF-8 encoding.
        //
        // @TODO Handling all encodings inside a single object makes it very difficult
        // to reason about this code, so it should be split up in the future.
        // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
        // points as used by CESU-8.
        var StringDecoder = exports.StringDecoder = function (encoding) {
            this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
            assertEncoding(encoding);
            switch (this.encoding) {
            case 'utf8':
              // CESU-8 represents each of Surrogate Pair by 3-bytes
              this.surrogateSize = 3;
              break;
            case 'ucs2':
            case 'utf16le':
              // UTF-16 represents each of Surrogate Pair by 2-bytes
              this.surrogateSize = 2;
              this.detectIncompleteChar = utf16DetectIncompleteChar;
              break;
            case 'base64':
              // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
              this.surrogateSize = 3;
              this.detectIncompleteChar = base64DetectIncompleteChar;
              break;
            default:
              this.write = passThroughWrite;
              return;
            }
            // Enough space to store all bytes of a single character. UTF-8 needs 4
            // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
            this.charBuffer = new Buffer(6);
            // Number of bytes received for the current incomplete multi-byte character.
            this.charReceived = 0;
            // Number of bytes expected for the current incomplete multi-byte character.
            this.charLength = 0;
          };
        // write decodes the given buffer and returns it as JS string that is
        // guaranteed to not contain any partial multi-byte characters. Any partial
        // character found at the end of the buffer is buffered up, and will be
        // returned when calling write again with the remaining bytes.
        //
        // Note: Converting a Buffer containing an orphan surrogate to a String
        // currently works, but converting a String to a Buffer (via `new Buffer`, or
        // Buffer#write) will replace incomplete surrogates with the unicode
        // replacement character. See https://codereview.chromium.org/121173009/ .
        StringDecoder.prototype.write = function (buffer) {
          var charStr = '';
          // if our last write ended with an incomplete multibyte character
          while (this.charLength) {
            // determine how many remaining bytes this buffer has to offer for this char
            var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
            // add the new bytes to the char buffer
            buffer.copy(this.charBuffer, this.charReceived, 0, available);
            this.charReceived += available;
            if (this.charReceived < this.charLength) {
              // still not enough chars in this buffer? wait for more ...
              return '';
            }
            // remove bytes belonging to the current character from the buffer
            buffer = buffer.slice(available, buffer.length);
            // get the character that was split
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
            // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 55296 && charCode <= 56319) {
              this.charLength += this.surrogateSize;
              charStr = '';
              continue;
            }
            this.charReceived = this.charLength = 0;
            // if there are no more bytes in this buffer, just emit our char
            if (buffer.length === 0) {
              return charStr;
            }
            break;
          }
          // determine and set charLength / charReceived
          this.detectIncompleteChar(buffer);
          var end = buffer.length;
          if (this.charLength) {
            // buffer the incomplete character bytes we got
            buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
            end -= this.charReceived;
          }
          charStr += buffer.toString(this.encoding, 0, end);
          var end = charStr.length - 1;
          var charCode = charStr.charCodeAt(end);
          // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
          if (charCode >= 55296 && charCode <= 56319) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            buffer.copy(this.charBuffer, 0, 0, size);
            return charStr.substring(0, end);
          }
          // or just emit the charStr
          return charStr;
        };
        // detectIncompleteChar determines if there is an incomplete UTF-8 character at
        // the end of the given buffer. If so, it sets this.charLength to the byte
        // length that character, and sets this.charReceived to the number of bytes
        // that are available for this character.
        StringDecoder.prototype.detectIncompleteChar = function (buffer) {
          // determine how many bytes we have to check at the end of this buffer
          var i = buffer.length >= 3 ? 3 : buffer.length;
          // Figure out if one of the last i bytes of our buffer announces an
          // incomplete char.
          for (; i > 0; i--) {
            var c = buffer[buffer.length - i];
            // See http://en.wikipedia.org/wiki/UTF-8#Description
            // 110XXXXX
            if (i == 1 && c >> 5 == 6) {
              this.charLength = 2;
              break;
            }
            // 1110XXXX
            if (i <= 2 && c >> 4 == 14) {
              this.charLength = 3;
              break;
            }
            // 11110XXX
            if (i <= 3 && c >> 3 == 30) {
              this.charLength = 4;
              break;
            }
          }
          this.charReceived = i;
        };
        StringDecoder.prototype.end = function (buffer) {
          var res = '';
          if (buffer && buffer.length)
            res = this.write(buffer);
          if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
          }
          return res;
        };
        function passThroughWrite(buffer) {
          return buffer.toString(this.encoding);
        }
        function utf16DetectIncompleteChar(buffer) {
          this.charReceived = buffer.length % 2;
          this.charLength = this.charReceived ? 2 : 0;
        }
        function base64DetectIncompleteChar(buffer) {
          this.charReceived = buffer.length % 3;
          this.charLength = this.charReceived ? 3 : 0;
        }
      },
      { 'buffer': 41 }
    ],
    138: [
      function (require, module, exports) {
        module.exports = [
          'get',
          'put',
          'post',
          'delete',
          'options',
          'head',
          'patch'
        ];
      },
      {}
    ],
    139: [
      function (require, module, exports) {
        /** !
 * Swagger Parser v4.0.0-beta.2
 *
 * @link https://github.com/BigstickCarpet/swagger-parser
 * @license MIT
 */
        'use strict';
        var validateSchema = require('./validate-schema'), validateSpec = require('./validate-spec'), util = require('./util'), Options = require('./options'), Promise = require('./promise'), maybe = require('call-me-maybe'), ono = require('ono'), $RefParser = require('json-schema-ref-parser'), dereference = require('json-schema-ref-parser/lib/dereference');
        module.exports = SwaggerParser;
        /**
 * This class parses a Swagger 2.0 API, resolves its JSON references and their resolved values,
 * and provides methods for traversing, dereferencing, and validating the API.
 *
 * @constructor
 * @extends $RefParser
 */
        function SwaggerParser() {
          $RefParser.apply(this, arguments);
        }
        util.inherits(SwaggerParser, $RefParser);
        SwaggerParser.YAML = $RefParser.YAML;
        SwaggerParser.parse = $RefParser.parse;
        SwaggerParser.resolve = $RefParser.resolve;
        SwaggerParser.bundle = $RefParser.bundle;
        SwaggerParser.dereference = $RefParser.dereference;
        /**
 * Alias {@link $RefParser#schema} as {@link SwaggerParser#api}
 */
        Object.defineProperty(SwaggerParser.prototype, 'api', {
          configurable: true,
          enumerable: true,
          get: function () {
            return this.schema;
          }
        });
        /**
 * Parses the given Swagger API.
 * This method does not resolve any JSON references.
 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
 *
 * @param {string|object} api - The file path or URL of the Swagger API. Or a Swagger object.
 * @param {ParserOptions} [options] - Options that determine how the API is parsed
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.
 * @returns {Promise} - The returned promise resolves with the parsed API object.
 */
        SwaggerParser.prototype.parse = function (api, options, callback) {
          var args = normalizeArgs(arguments);
          return $RefParser.prototype.parse.call(this, args.path, args.api, args.options).then(function (schema) {
            var supportedSwaggerVersions = ['2.0'];
            // Verify that the parsed object is a Swagger API
            if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {
              throw ono.syntax('%s is not a valid Swagger API definition', args.path || args.api);
            } else if (typeof schema.swagger === 'number') {
              // This is a very common mistake, so give a helpful error message
              throw ono.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
            } else if (typeof schema.info.version === 'number') {
              // This is a very common mistake, so give a helpful error message
              throw ono.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
            } else if (supportedSwaggerVersions.indexOf(schema.swagger) === -1) {
              throw ono.syntax('Unsupported Swagger version: %d. Swagger Parser only supports version %s', schema.swagger, supportedSwaggerVersions.join(', '));
            }
            // Looks good!
            return maybe(args.callback, Promise.resolve(schema));
          }).catch(function (err) {
            return maybe(args.callback, Promise.reject(err));
          });
        };
        /**
 * Parses, dereferences, and validates the given Swagger API.
 * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.
 *
 * @param {string|object} api - The file path or URL of the Swagger API. Or a Swagger object.
 * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.
 * @returns {Promise} - The returned promise resolves with the parsed API object.
 */
        SwaggerParser.validate = function (api, options, callback) {
          var Class = this;
          // eslint-disable-line consistent-this
          var instance = new Class();
          return instance.validate.apply(instance, arguments);
        };
        /**
 * Parses, dereferences, and validates the given Swagger API.
 * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.
 *
 * @param {string|object} api - The file path or URL of the Swagger API. Or a Swagger object.
 * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.
 * @returns {Promise} - The returned promise resolves with the parsed API object.
 */
        SwaggerParser.prototype.validate = function (api, options, callback) {
          var me = this;
          var args = normalizeArgs(arguments);
          // ZSchema doesn't support circular objects, so don't dereference circular $refs yet
          // (see https://github.com/zaggino/z-schema/issues/137)
          var circular$RefOption = args.options.dereference.circular;
          args.options.validate.schema && (args.options.dereference.circular = 'ignore');
          return this.dereference(args.path, args.api, args.options).then(function () {
            // Restore the original options, now that we're done dereferencing
            args.options.dereference.circular = circular$RefOption;
            if (args.options.validate.schema) {
              // Validate the API against the Swagger schema
              // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet
              validateSchema(me.api);
              if (me.$refs.circular) {
                if (circular$RefOption === true) {
                  // The API has circular references,
                  // so we need to do a second-pass to fully-dereference it
                  dereference(me, args.options);
                } else if (circular$RefOption === false) {
                  // The API has circular references, and they're not allowed, so throw an error
                  throw ono.reference('The API contains circular references');
                }
              }
            }
            if (args.options.validate.spec) {
              // Validate the API against the Swagger spec
              validateSpec(me.api);
            }
            return maybe(args.callback, Promise.resolve(me.schema));
          }).catch(function (err) {
            return maybe(args.callback, Promise.reject(err));
          });
        };
        /**
 * The Swagger object
 * https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#swagger-object
 *
 * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject
 */
        /**
 * Normalizes the given arguments, accounting for optional args.
 *
 * @param {Arguments} args
 * @returns {object}
 */
        function normalizeArgs(args) {
          var path, api, options, callback;
          args = Array.prototype.slice.call(args);
          if (typeof args[args.length - 1] === 'function') {
            // The last parameter is a callback function
            callback = args.pop();
          }
          if (typeof args[0] === 'string') {
            // The first parameter is the path
            path = args[0];
            if (typeof args[2] === 'object') {
              // The second parameter is the api, and the third parameter is the options
              api = args[1];
              options = args[2];
            } else {
              // The second parameter is the options
              api = undefined;
              options = args[1];
            }
          } else {
            // The first parameter is the api
            path = '';
            api = args[0];
            options = args[1];
          }
          if (!(options instanceof Options)) {
            options = new Options(options);
          }
          return {
            path: path,
            api: api,
            options: options,
            callback: callback
          };
        }
      },
      {
        './options': 140,
        './promise': 141,
        './util': 142,
        './validate-schema': 143,
        './validate-spec': 144,
        'call-me-maybe': 44,
        'json-schema-ref-parser': 89,
        'json-schema-ref-parser/lib/dereference': 88,
        'ono': 113
      }
    ],
    140: [
      function (require, module, exports) {
        'use strict';
        var $RefParserOptions = require('json-schema-ref-parser/lib/options'), util = require('util');
        module.exports = ParserOptions;
        /**
 * Options that determine how Swagger APIs are parsed, resolved, dereferenced, and validated.
 *
 * @param {object|ParserOptions} [options] - Overridden options
 * @constructor
 * @extends $RefParserOptions
 */
        function ParserOptions(options) {
          $RefParserOptions.call(this, ParserOptions.defaults);
          $RefParserOptions.apply(this, arguments);
        }
        ParserOptions.defaults = {
          validate: {
            schema: { order: 1 },
            spec: { order: 2 }
          }
        };
        util.inherits(ParserOptions, $RefParserOptions);
      },
      {
        'json-schema-ref-parser/lib/options': 90,
        'util': 150
      }
    ],
    141: [
      function (require, module, exports) {
        arguments[4][104][0].apply(exports, arguments);
      },
      {
        'dup': 104,
        'es6-promise': 48
      }
    ],
    142: [
      function (require, module, exports) {
        'use strict';
        var debug = require('debug'), util = require('util');
        exports.format = util.format;
        exports.inherits = util.inherits;
        /**
 * Writes messages to stdout.
 * Log messages are suppressed by default, but can be enabled by setting the DEBUG variable.
 * @type {function}
 */
        exports.debug = debug('swagger:parser');
        /**
 * Regular Expression that matches Swagger path params.
 */
        exports.swaggerParamRegExp = /\{([^\/}]+)}/g;
      },
      {
        'debug': 46,
        'util': 150
      }
    ],
    143: [
      function (require, module, exports) {
        'use strict';
        var util = require('./util'), ono = require('ono'), ZSchema = require('z-schema'), swaggerSchema = require('swagger-schema-official/schema');
        module.exports = validateSchema;
        initializeZSchema();
        /**
 * Validates the given Swagger API against the Swagger 2.0 schema.
 *
 * @param {SwaggerObject} api
 */
        function validateSchema(api) {
          util.debug('Validating against the Swagger 2.0 schema');
          // Validate the API against the Swagger schema
          var isValid = ZSchema.validate(api, swaggerSchema);
          if (isValid) {
            util.debug('    Validated successfully');
          } else {
            var err = ZSchema.getLastError();
            var message = 'Swagger schema validation failed. \n' + formatZSchemaError(err.details);
            throw ono.syntax(err, { details: err.details }, message);
          }
        }
        /**
 * Performs one-time initialization logic to prepare for Swagger Schema validation.
 */
        function initializeZSchema() {
          ZSchema = new ZSchema({
            breakOnFirstError: true,
            noExtraKeywords: true,
            ignoreUnknownFormats: false,
            reportPathAsArray: true
          });
        }
        /**
 * Z-Schema validation errors are a nested tree structure.
 * This function crawls that tree and builds an error message string.
 *
 * @param {object[]}  errors     - The Z-Schema error details
 * @param {string}    [indent]   - The whitespace used to indent the error message
 * @returns {string}
 */
        function formatZSchemaError(errors, indent) {
          indent = indent || '  ';
          var message = '';
          errors.forEach(function (error, index) {
            message += util.format('%s%s at #/%s\n', indent, error.message, error.path.join('/'));
            if (error.inner) {
              message += formatZSchemaError(error.inner, indent + '  ');
            }
          });
          return message;
        }
      },
      {
        './util': 142,
        'ono': 113,
        'swagger-schema-official/schema': 145,
        'z-schema': 225
      }
    ],
    144: [
      function (require, module, exports) {
        'use strict';
        var util = require('./util'), ono = require('ono'), swaggerMethods = require('swagger-methods'), primitiveTypes = [
            'array',
            'boolean',
            'integer',
            'number',
            'string'
          ], schemaTypes = [
            'array',
            'boolean',
            'integer',
            'number',
            'string',
            'object',
            'null',
            undefined
          ];
        module.exports = validateSpec;
        /**
 * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.
 *
 * @param {SwaggerObject} api
 */
        function validateSpec(api) {
          util.debug('Validating against the Swagger 2.0 spec');
          var paths = Object.keys(api.paths || {});
          paths.forEach(function (pathName) {
            var path = api.paths[pathName];
            var pathId = '/paths' + pathName;
            if (path && pathName.indexOf('/') === 0) {
              validatePath(api, path, pathId);
            }
          });
          util.debug('    Validated successfully');
        }
        /**
 * Validates the given path.
 *
 * @param {SwaggerObject} api      - The entire Swagger API object
 * @param {object}        path     - A Path object, from the Swagger API
 * @param {string}        pathId   - A value that uniquely identifies the path
 */
        function validatePath(api, path, pathId) {
          swaggerMethods.forEach(function (operationName) {
            var operation = path[operationName];
            var operationId = pathId + '/' + operationName;
            if (operation) {
              validateParameters(api, path, pathId, operation, operationId);
              var responses = Object.keys(operation.responses || {});
              responses.forEach(function (responseName) {
                var response = operation.responses[responseName];
                var responseId = operationId + '/responses/' + responseName;
                validateResponse(responseName, response, responseId);
              });
            }
          });
        }
        /**
 * Validates the parameters for the given operation.
 *
 * @param {SwaggerObject} api           - The entire Swagger API object
 * @param {object}        path          - A Path object, from the Swagger API
 * @param {string}        pathId        - A value that uniquely identifies the path
 * @param {object}        operation     - An Operation object, from the Swagger API
 * @param {string}        operationId   - A value that uniquely identifies the operation
 */
        function validateParameters(api, path, pathId, operation, operationId) {
          var pathParams = path.parameters || [];
          var operationParams = operation.parameters || [];
          // Check for duplicate path parameters
          try {
            checkForDuplicates(pathParams);
          } catch (e) {
            throw ono.syntax(e, 'Validation failed. %s has duplicate parameters', pathId);
          }
          // Check for duplicate operation parameters
          try {
            checkForDuplicates(operationParams);
          } catch (e) {
            throw ono.syntax(e, 'Validation failed. %s has duplicate parameters', operationId);
          }
          // Combine the path and operation parameters,
          // with the operation params taking precedence over the path params
          var params = pathParams.reduce(function (combinedParams, value) {
              var duplicate = combinedParams.some(function (param) {
                  return param.in === value.in && param.name === value.name;
                });
              if (!duplicate) {
                combinedParams.push(value);
              }
              return combinedParams;
            }, operationParams.slice());
          validateBodyParameters(params, operationId);
          validatePathParameters(params, pathId, operationId);
          validateParameterTypes(params, api, operation, operationId);
        }
        /**
 * Validates body and formData parameters for the given operation.
 *
 * @param   {object[]}  params       -  An array of Parameter objects
 * @param   {string}    operationId  -  A value that uniquely identifies the operation
 */
        function validateBodyParameters(params, operationId) {
          var bodyParams = params.filter(function (param) {
              return param.in === 'body';
            });
          var formParams = params.filter(function (param) {
              return param.in === 'formData';
            });
          // There can only be one "body" parameter
          if (bodyParams.length > 1) {
            throw ono.syntax('Validation failed. %s has %d body parameters. Only one is allowed.', operationId, bodyParams.length);
          } else if (bodyParams.length > 0 && formParams.length > 0) {
            // "body" params and "formData" params are mutually exclusive
            throw ono.syntax('Validation failed. %s has body parameters and formData parameters. Only one or the other is allowed.', operationId);
          }
        }
        /**
 * Validates path parameters for the given path.
 *
 * @param   {object[]}  params        - An array of Parameter objects
 * @param   {string}    pathId        - A value that uniquely identifies the path
 * @param   {string}    operationId   - A value that uniquely identifies the operation
 */
        function validatePathParameters(params, pathId, operationId) {
          // Find all {placeholders} in the path string
          var placeholders = pathId.match(util.swaggerParamRegExp) || [];
          // Check for duplicates
          for (var i = 0; i < placeholders.length; i++) {
            for (var j = i + 1; j < placeholders.length; j++) {
              if (placeholders[i] === placeholders[j]) {
                throw ono.syntax('Validation failed. %s has multiple path placeholders named %s', operationId, placeholders[i]);
              }
            }
          }
          params.filter(function (param) {
            return param.in === 'path';
          }).forEach(function (param) {
            if (param.required !== true) {
              throw ono.syntax('Validation failed. Path parameters cannot be optional. Set required=true for the "%s" parameter at %s', param.name, operationId);
            }
            var match = placeholders.indexOf('{' + param.name + '}');
            if (match === -1) {
              throw ono.syntax('Validation failed. %s has a path parameter named "%s", ' + 'but there is no corresponding {%s} in the path string', operationId, param.name, param.name);
            }
            placeholders.splice(match, 1);
          });
          if (placeholders.length > 0) {
            throw ono.syntax('Validation failed. %s is missing path parameter(s) for %s', operationId, placeholders);
          }
        }
        /**
 * Validates data types of parameters for the given operation.
 *
 * @param   {object[]}  params       -  An array of Parameter objects
 * @param   {object}    api          -  The entire Swagger API object
 * @param   {object}    operation    -  An Operation object, from the Swagger API
 * @param   {string}    operationId  -  A value that uniquely identifies the operation
 */
        function validateParameterTypes(params, api, operation, operationId) {
          params.forEach(function (param) {
            var parameterId = operationId + '/parameters/' + param.name;
            var schema, validTypes;
            switch (param.in) {
            case 'body':
              schema = param.schema;
              validTypes = schemaTypes;
              break;
            case 'formData':
              schema = param;
              validTypes = primitiveTypes.concat('file');
              break;
            default:
              schema = param;
              validTypes = primitiveTypes;
            }
            validateSchema(schema, parameterId, validTypes);
            if (schema.type === 'file') {
              // "file" params require specific "consumes" types
              var consumes = operation.consumes || api.consumes || [];
              if (consumes.indexOf('multipart/form-data') === -1 && consumes.indexOf('application/x-www-form-urlencoded') === -1) {
                throw ono.syntax('Validation failed. %s has a file parameter, so it must consume multipart/form-data ' + 'or application/x-www-form-urlencoded', operationId);
              }
            }
          });
        }
        /**
 * Checks the given parameter list for duplicates, and throws an error if found.
 *
 * @param   {object[]}  params  - An array of Parameter objects
 */
        function checkForDuplicates(params) {
          for (var i = 0; i < params.length - 1; i++) {
            var outer = params[i];
            for (var j = i + 1; j < params.length; j++) {
              var inner = params[j];
              if (outer.name === inner.name && outer.in === inner.in) {
                throw ono.syntax('Validation failed. Found multiple %s parameters named "%s"', outer.in, outer.name);
              }
            }
          }
        }
        /**
 * Validates the given response object.
 *
 * @param   {string}    code        -  The HTTP response code (or "default")
 * @param   {object}    response    -  A Response object, from the Swagger API
 * @param   {string}    responseId  -  A value that uniquely identifies the response
 */
        function validateResponse(code, response, responseId) {
          if (code !== 'default' && (code < 100 || code > 599)) {
            throw ono.syntax('Validation failed. %s has an invalid response code (%s)', responseId, code);
          }
          var headers = Object.keys(response.headers || {});
          headers.forEach(function (headerName) {
            var header = response.headers[headerName];
            var headerId = responseId + '/headers/' + headerName;
            validateSchema(header, headerId, primitiveTypes);
          });
          if (response.schema) {
            var validTypes = schemaTypes.concat('file');
            if (validTypes.indexOf(response.schema.type) === -1) {
              throw ono.syntax('Validation failed. %s has an invalid response schema type (%s)', responseId, response.schema.type);
            }
          }
        }
        /**
 * Validates the given Swagger schema object.
 *
 * @param {object}    schema      - A Schema object, from the Swagger API
 * @param {string}    schemaId    - A value that uniquely identifies the schema object
 * @param {string[]}  validTypes  - An array of the allowed schema types
 */
        function validateSchema(schema, schemaId, validTypes) {
          if (validTypes.indexOf(schema.type) === -1) {
            throw ono.syntax('Validation failed. %s has an invalid type (%s)', schemaId, schema.type);
          }
          if (schema.type === 'array' && !schema.items) {
            throw ono.syntax('Validation failed. %s is an array, so it must include an "items" schema', schemaId);
          }
        }
      },
      {
        './util': 142,
        'ono': 113,
        'swagger-methods': 138
      }
    ],
    145: [
      function (require, module, exports) {
        module.exports = {
          'title': 'A JSON Schema for Swagger 2.0 API.',
          'id': 'http://swagger.io/v2/schema.json#',
          '$schema': 'http://json-schema.org/draft-04/schema#',
          'type': 'object',
          'required': [
            'swagger',
            'info',
            'paths'
          ],
          'additionalProperties': false,
          'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
          'properties': {
            'swagger': {
              'type': 'string',
              'enum': ['2.0'],
              'description': 'The Swagger version of this document.'
            },
            'info': { '$ref': '#/definitions/info' },
            'host': {
              'type': 'string',
              'pattern': '^[^{}/ :\\\\]+(?::\\d+)?$',
              'description': 'The host (name or ip) of the API. Example: \'swagger.io\''
            },
            'basePath': {
              'type': 'string',
              'pattern': '^/',
              'description': 'The base path to the API. Example: \'/api\'.'
            },
            'schemes': { '$ref': '#/definitions/schemesList' },
            'consumes': {
              'description': 'A list of MIME types accepted by the API.',
              '$ref': '#/definitions/mediaTypeList'
            },
            'produces': {
              'description': 'A list of MIME types the API can produce.',
              '$ref': '#/definitions/mediaTypeList'
            },
            'paths': { '$ref': '#/definitions/paths' },
            'definitions': { '$ref': '#/definitions/definitions' },
            'parameters': { '$ref': '#/definitions/parameterDefinitions' },
            'responses': { '$ref': '#/definitions/responseDefinitions' },
            'security': { '$ref': '#/definitions/security' },
            'securityDefinitions': { '$ref': '#/definitions/securityDefinitions' },
            'tags': {
              'type': 'array',
              'items': { '$ref': '#/definitions/tag' },
              'uniqueItems': true
            },
            'externalDocs': { '$ref': '#/definitions/externalDocs' }
          },
          'definitions': {
            'info': {
              'type': 'object',
              'description': 'General information about the API.',
              'required': [
                'version',
                'title'
              ],
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'title': {
                  'type': 'string',
                  'description': 'A unique and precise title of the API.'
                },
                'version': {
                  'type': 'string',
                  'description': 'A semantic version number of the API.'
                },
                'description': {
                  'type': 'string',
                  'description': 'A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.'
                },
                'termsOfService': {
                  'type': 'string',
                  'description': 'The terms of service for the API.'
                },
                'contact': { '$ref': '#/definitions/contact' },
                'license': { '$ref': '#/definitions/license' }
              }
            },
            'contact': {
              'type': 'object',
              'description': 'Contact information for the owners of the API.',
              'additionalProperties': false,
              'properties': {
                'name': {
                  'type': 'string',
                  'description': 'The identifying name of the contact person/organization.'
                },
                'url': {
                  'type': 'string',
                  'description': 'The URL pointing to the contact information.',
                  'format': 'uri'
                },
                'email': {
                  'type': 'string',
                  'description': 'The email address of the contact person/organization.',
                  'format': 'email'
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'license': {
              'type': 'object',
              'required': ['name'],
              'additionalProperties': false,
              'properties': {
                'name': {
                  'type': 'string',
                  'description': 'The name of the license type. It\'s encouraged to use an OSI compatible license.'
                },
                'url': {
                  'type': 'string',
                  'description': 'The URL pointing to the license.',
                  'format': 'uri'
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'paths': {
              'type': 'object',
              'description': 'Relative paths to the individual endpoints. They must be relative to the \'basePath\'.',
              'patternProperties': {
                '^x-': { '$ref': '#/definitions/vendorExtension' },
                '^/': { '$ref': '#/definitions/pathItem' }
              },
              'additionalProperties': false
            },
            'definitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/schema' },
              'description': 'One or more JSON objects describing the schemas being consumed and produced by the API.'
            },
            'parameterDefinitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/parameter' },
              'description': 'One or more JSON representations for parameters'
            },
            'responseDefinitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/response' },
              'description': 'One or more JSON representations for parameters'
            },
            'externalDocs': {
              'type': 'object',
              'additionalProperties': false,
              'description': 'information about external documentation',
              'required': ['url'],
              'properties': {
                'description': { 'type': 'string' },
                'url': {
                  'type': 'string',
                  'format': 'uri'
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'examples': {
              'type': 'object',
              'additionalProperties': true
            },
            'mimeType': {
              'type': 'string',
              'description': 'The MIME type of the HTTP message.'
            },
            'operation': {
              'type': 'object',
              'required': ['responses'],
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'tags': {
                  'type': 'array',
                  'items': { 'type': 'string' },
                  'uniqueItems': true
                },
                'summary': {
                  'type': 'string',
                  'description': 'A brief summary of the operation.'
                },
                'description': {
                  'type': 'string',
                  'description': 'A longer description of the operation, GitHub Flavored Markdown is allowed.'
                },
                'externalDocs': { '$ref': '#/definitions/externalDocs' },
                'operationId': {
                  'type': 'string',
                  'description': 'A unique identifier of the operation.'
                },
                'produces': {
                  'description': 'A list of MIME types the API can produce.',
                  '$ref': '#/definitions/mediaTypeList'
                },
                'consumes': {
                  'description': 'A list of MIME types the API can consume.',
                  '$ref': '#/definitions/mediaTypeList'
                },
                'parameters': { '$ref': '#/definitions/parametersList' },
                'responses': { '$ref': '#/definitions/responses' },
                'schemes': { '$ref': '#/definitions/schemesList' },
                'deprecated': {
                  'type': 'boolean',
                  'default': false
                },
                'security': { '$ref': '#/definitions/security' }
              }
            },
            'pathItem': {
              'type': 'object',
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                '$ref': { 'type': 'string' },
                'get': { '$ref': '#/definitions/operation' },
                'put': { '$ref': '#/definitions/operation' },
                'post': { '$ref': '#/definitions/operation' },
                'delete': { '$ref': '#/definitions/operation' },
                'options': { '$ref': '#/definitions/operation' },
                'head': { '$ref': '#/definitions/operation' },
                'patch': { '$ref': '#/definitions/operation' },
                'parameters': { '$ref': '#/definitions/parametersList' }
              }
            },
            'responses': {
              'type': 'object',
              'description': 'Response objects names can either be any valid HTTP status code or \'default\'.',
              'minProperties': 1,
              'additionalProperties': false,
              'patternProperties': {
                '^([0-9]{3})$|^(default)$': { '$ref': '#/definitions/responseValue' },
                '^x-': { '$ref': '#/definitions/vendorExtension' }
              },
              'not': {
                'type': 'object',
                'additionalProperties': false,
                'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
              }
            },
            'responseValue': {
              'oneOf': [
                { '$ref': '#/definitions/response' },
                { '$ref': '#/definitions/jsonReference' }
              ]
            },
            'response': {
              'type': 'object',
              'required': ['description'],
              'properties': {
                'description': { 'type': 'string' },
                'schema': {
                  'oneOf': [
                    { '$ref': '#/definitions/schema' },
                    { '$ref': '#/definitions/fileSchema' }
                  ]
                },
                'headers': { '$ref': '#/definitions/headers' },
                'examples': { '$ref': '#/definitions/examples' }
              },
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'headers': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/header' }
            },
            'header': {
              'type': 'object',
              'additionalProperties': false,
              'required': ['type'],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'integer',
                    'boolean',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'vendorExtension': {
              'description': 'Any property starting with x- is valid.',
              'additionalProperties': true,
              'additionalItems': true
            },
            'bodyParameter': {
              'type': 'object',
              'required': [
                'name',
                'in',
                'schema'
              ],
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['body']
                },
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'schema': { '$ref': '#/definitions/schema' }
              },
              'additionalProperties': false
            },
            'headerParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['header']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'queryParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['query']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'allowEmptyValue': {
                  'type': 'boolean',
                  'default': false,
                  'description': 'allows sending a parameter by name only or with an empty value.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormatWithMulti' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'formDataParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['formData']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'allowEmptyValue': {
                  'type': 'boolean',
                  'default': false,
                  'description': 'allows sending a parameter by name only or with an empty value.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array',
                    'file'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormatWithMulti' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'pathParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'required': ['required'],
              'properties': {
                'required': {
                  'type': 'boolean',
                  'enum': [true],
                  'description': 'Determines whether or not this parameter is required or optional.'
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['path']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'nonBodyParameter': {
              'type': 'object',
              'required': [
                'name',
                'in',
                'type'
              ],
              'oneOf': [
                { '$ref': '#/definitions/headerParameterSubSchema' },
                { '$ref': '#/definitions/formDataParameterSubSchema' },
                { '$ref': '#/definitions/queryParameterSubSchema' },
                { '$ref': '#/definitions/pathParameterSubSchema' }
              ]
            },
            'parameter': {
              'oneOf': [
                { '$ref': '#/definitions/bodyParameter' },
                { '$ref': '#/definitions/nonBodyParameter' }
              ]
            },
            'schema': {
              'type': 'object',
              'description': 'A deterministic version of a JSON Schema object.',
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                '$ref': { 'type': 'string' },
                'format': { 'type': 'string' },
                'title': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/title' },
                'description': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/description' },
                'default': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/default' },
                'multipleOf': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/multipleOf' },
                'maximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/maximum' },
                'exclusiveMaximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum' },
                'minimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/minimum' },
                'exclusiveMinimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum' },
                'maxLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
                'minLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
                'pattern': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/pattern' },
                'maxItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
                'minItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
                'uniqueItems': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/uniqueItems' },
                'maxProperties': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
                'minProperties': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
                'required': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/stringArray' },
                'enum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/enum' },
                'additionalProperties': {
                  'anyOf': [
                    { '$ref': '#/definitions/schema' },
                    { 'type': 'boolean' }
                  ],
                  'default': {}
                },
                'type': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/type' },
                'items': {
                  'anyOf': [
                    { '$ref': '#/definitions/schema' },
                    {
                      'type': 'array',
                      'minItems': 1,
                      'items': { '$ref': '#/definitions/schema' }
                    }
                  ],
                  'default': {}
                },
                'allOf': {
                  'type': 'array',
                  'minItems': 1,
                  'items': { '$ref': '#/definitions/schema' }
                },
                'properties': {
                  'type': 'object',
                  'additionalProperties': { '$ref': '#/definitions/schema' },
                  'default': {}
                },
                'discriminator': { 'type': 'string' },
                'readOnly': {
                  'type': 'boolean',
                  'default': false
                },
                'xml': { '$ref': '#/definitions/xml' },
                'externalDocs': { '$ref': '#/definitions/externalDocs' },
                'example': {}
              },
              'additionalProperties': false
            },
            'fileSchema': {
              'type': 'object',
              'description': 'A deterministic version of a JSON Schema object.',
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'required': ['type'],
              'properties': {
                'format': { 'type': 'string' },
                'title': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/title' },
                'description': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/description' },
                'default': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/default' },
                'required': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/stringArray' },
                'type': {
                  'type': 'string',
                  'enum': ['file']
                },
                'readOnly': {
                  'type': 'boolean',
                  'default': false
                },
                'externalDocs': { '$ref': '#/definitions/externalDocs' },
                'example': {}
              },
              'additionalProperties': false
            },
            'primitivesItems': {
              'type': 'object',
              'additionalProperties': false,
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'integer',
                    'boolean',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'security': {
              'type': 'array',
              'items': { '$ref': '#/definitions/securityRequirement' },
              'uniqueItems': true
            },
            'securityRequirement': {
              'type': 'object',
              'additionalProperties': {
                'type': 'array',
                'items': { 'type': 'string' },
                'uniqueItems': true
              }
            },
            'xml': {
              'type': 'object',
              'additionalProperties': false,
              'properties': {
                'name': { 'type': 'string' },
                'namespace': { 'type': 'string' },
                'prefix': { 'type': 'string' },
                'attribute': {
                  'type': 'boolean',
                  'default': false
                },
                'wrapped': {
                  'type': 'boolean',
                  'default': false
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'tag': {
              'type': 'object',
              'additionalProperties': false,
              'required': ['name'],
              'properties': {
                'name': { 'type': 'string' },
                'description': { 'type': 'string' },
                'externalDocs': { '$ref': '#/definitions/externalDocs' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'securityDefinitions': {
              'type': 'object',
              'additionalProperties': {
                'oneOf': [
                  { '$ref': '#/definitions/basicAuthenticationSecurity' },
                  { '$ref': '#/definitions/apiKeySecurity' },
                  { '$ref': '#/definitions/oauth2ImplicitSecurity' },
                  { '$ref': '#/definitions/oauth2PasswordSecurity' },
                  { '$ref': '#/definitions/oauth2ApplicationSecurity' },
                  { '$ref': '#/definitions/oauth2AccessCodeSecurity' }
                ]
              }
            },
            'basicAuthenticationSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': ['type'],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['basic']
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'apiKeySecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'name',
                'in'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['apiKey']
                },
                'name': { 'type': 'string' },
                'in': {
                  'type': 'string',
                  'enum': [
                    'header',
                    'query'
                  ]
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2ImplicitSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'authorizationUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['implicit']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'authorizationUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2PasswordSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'tokenUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['password']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'tokenUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2ApplicationSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'tokenUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['application']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'tokenUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2AccessCodeSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'authorizationUrl',
                'tokenUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['accessCode']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'authorizationUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'tokenUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2Scopes': {
              'type': 'object',
              'additionalProperties': { 'type': 'string' }
            },
            'mediaTypeList': {
              'type': 'array',
              'items': { '$ref': '#/definitions/mimeType' },
              'uniqueItems': true
            },
            'parametersList': {
              'type': 'array',
              'description': 'The parameters needed to send a valid API call.',
              'additionalItems': false,
              'items': {
                'oneOf': [
                  { '$ref': '#/definitions/parameter' },
                  { '$ref': '#/definitions/jsonReference' }
                ]
              },
              'uniqueItems': true
            },
            'schemesList': {
              'type': 'array',
              'description': 'The transfer protocol of the API.',
              'items': {
                'type': 'string',
                'enum': [
                  'http',
                  'https',
                  'ws',
                  'wss'
                ]
              },
              'uniqueItems': true
            },
            'collectionFormat': {
              'type': 'string',
              'enum': [
                'csv',
                'ssv',
                'tsv',
                'pipes'
              ],
              'default': 'csv'
            },
            'collectionFormatWithMulti': {
              'type': 'string',
              'enum': [
                'csv',
                'ssv',
                'tsv',
                'pipes',
                'multi'
              ],
              'default': 'csv'
            },
            'title': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/title' },
            'description': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/description' },
            'default': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/default' },
            'multipleOf': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/multipleOf' },
            'maximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/maximum' },
            'exclusiveMaximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum' },
            'minimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/minimum' },
            'exclusiveMinimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum' },
            'maxLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
            'minLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
            'pattern': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/pattern' },
            'maxItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
            'minItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
            'uniqueItems': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/uniqueItems' },
            'enum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/enum' },
            'jsonReference': {
              'type': 'object',
              'required': ['$ref'],
              'additionalProperties': false,
              'properties': { '$ref': { 'type': 'string' } }
            }
          }
        };
      },
      {}
    ],
    146: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        var punycode = require('punycode');
        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;
        exports.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        // Reference: RFC 3986, RFC 1808, RFC 2396
        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/,
          // RFC 2396: characters reserved for delimiting URLs.
          // We actually just auto-escape these.
          delims = [
            '<',
            '>',
            '"',
            '`',
            ' ',
            '\r',
            '\n',
            '\t'
          ],
          // RFC 2396: characters not allowed for various reasons.
          unwise = [
            '{',
            '}',
            '|',
            '\\',
            '^',
            '`'
          ].concat(delims),
          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
          autoEscape = ['\''].concat(unwise),
          // Characters that are never ever allowed in a hostname.
          // Note that any invalid chars are also handled, but these
          // are the ones that are *expected* to be seen, so we fast-path
          // them.
          nonHostChars = [
            '%',
            '/',
            '?',
            ';',
            '#'
          ].concat(autoEscape), hostEndingChars = [
            '/',
            '?',
            '#'
          ], hostnameMaxLen = 255, hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
          // protocols that can allow "unsafe" and "unwise" chars.
          unsafeProtocol = {
            'javascript': true,
            'javascript:': true
          },
          // protocols that never have a hostname.
          hostlessProtocol = {
            'javascript': true,
            'javascript:': true
          },
          // protocols that always contain a // bit.
          slashedProtocol = {
            'http': true,
            'https': true,
            'ftp': true,
            'gopher': true,
            'file': true,
            'http:': true,
            'https:': true,
            'ftp:': true,
            'gopher:': true,
            'file:': true
          }, querystring = require('querystring');
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && isObject(url) && url instanceof Url)
            return url;
          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }
        Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
          if (!isString(url)) {
            throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
          }
          var rest = url;
          // trim before proceeding.
          // This is to support parse stuff like "  http://foo.com  \n"
          rest = rest.trim();
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          // figure out if it's got a host
          // user@server is *always* interpreted as a hostname, and url
          // resolution will treat //foo/bar as host=foo,path=bar because that's
          // how the browser resolves relative URLs.
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c
            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.
            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
              // atSign can be anywhere.
              atSign = rest.lastIndexOf('@');
            } else {
              // atSign must be in auth portion.
              // http://a@b/c@d => host:b auth:a path:/c@d
              atSign = rest.lastIndexOf('@', hostEnd);
            }
            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            // pull out port.
            this.parseHost();
            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || '';
            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
            // validate a little.
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = '';
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      // we replace non-ASCII char with a temporary placeholder
                      // we need this to make sure size of hostname is not
                      // broken by replacing non-ASCII by nothing
                      newpart += 'x';
                    } else {
                      newpart += part[j];
                    }
                  }
                  // we test again with ASCII char only
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = '/' + notHost.join('.') + rest;
                    }
                    this.hostname = validParts.join('.');
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = '';
            } else {
              // hostnames are always lower case.
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              // IDNA Support: Returns a puny coded representation of "domain".
              // It only converts the part of the domain name that
              // has non ASCII characters. I.e. it dosent matter if
              // you call it with a domain that already is in ASCII.
              var domainArray = this.hostname.split('.');
              var newOut = [];
              for (var i = 0; i < domainArray.length; ++i) {
                var s = domainArray[i];
                newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
              }
              this.hostname = newOut.join('.');
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== '/') {
                rest = '/' + rest;
              }
            }
          }
          // now rest is set to the post-host stuff.
          // chop off any delim chars.
          if (!unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          // chop off from the tail first.
          var hash = rest.indexOf('#');
          if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf('?');
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = '';
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = '/';
          }
          //to support http.request
          if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
          }
          // finally, reconstruct the href based on what has been validated.
          this.href = this.format();
          return this;
        };
        // format a parsed object into a url string
        function urlFormat(obj) {
          // ensure it's an object, and not a string url.
          // If it's an obj, this is a no-op.
          // this way, you can call url_format() on strings
          // to clean up potentially wonky urls.
          if (isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function () {
          var auth = this.auth || '';
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
          }
          var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = '';
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
            if (this.port) {
              host += ':' + this.port;
            }
          }
          if (this.query && isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }
          var search = this.search || query && '?' + query || '';
          if (protocol && protocol.substr(-1) !== ':')
            protocol += ':';
          // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
          // unless they had them to begin with.
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/')
              pathname = '/' + pathname;
          } else if (!host) {
            host = '';
          }
          if (hash && hash.charAt(0) !== '#')
            hash = '#' + hash;
          if (search && search.charAt(0) !== '?')
            search = '?' + search;
          pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
          });
          search = search.replace('#', '%23');
          return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function (relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function (relative) {
          if (isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          Object.keys(this).forEach(function (k) {
            result[k] = this[k];
          }, this);
          // hash is always overridden, no matter what.
          // even href="" will remove it.
          result.hash = relative.hash;
          // if the relative url is empty, then there's nothing left to do here.
          if (relative.href === '') {
            result.href = result.format();
            return result;
          }
          // hrefs like //foo/bar always cut to the protocol.
          if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            Object.keys(relative).forEach(function (k) {
              if (k !== 'protocol')
                result[k] = relative[k];
            });
            //urlParse appends trailing / to urls like http://www.example.com
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!slashedProtocol[relative.protocol]) {
              Object.keys(relative).forEach(function (k) {
                result[k] = relative[k];
              });
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || '').split('/');
              while (relPath.length && !(relative.host = relPath.shift()));
              if (!relative.host)
                relative.host = '';
              if (!relative.hostname)
                relative.hostname = '';
              if (relPath[0] !== '')
                relPath.unshift('');
              if (relPath.length < 2)
                relPath.unshift('');
              result.pathname = relPath.join('/');
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
              var p = result.pathname || '';
              var s = result.search || '';
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/', isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/', mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
          // if the url is a non-slashed url, then relative
          // links like ../.. should be able
          // to crawl up to the hostname, as well.  This is strange.
          // result.protocol has already been set by now.
          // Later on, put the first path part into the host field.
          if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
              if (srcPath[0] === '')
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = '';
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === '')
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
          }
          if (isRelAbs) {
            // it's absolute.
            result.host = relative.host || relative.host === '' ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;  // fall through to the dot-handling below.
          } else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              //occationaly the auth can get stuck only in host
              //this especialy happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!isNull(result.pathname) || !isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
              result.path = '/' + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          // if a url ENDs in . or .., then it must get a trailing slash.
          // however, if it ends in anything else non-slashy,
          // then it must NOT get a trailing slash.
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === '';
          // strip single dots, resolve double dots to parent dir
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last == '.') {
              srcPath.splice(i, 1);
            } else if (last === '..') {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          // if the path is allowed to go above the root, restore leading ..s
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift('..');
            }
          }
          if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
          }
          if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
            srcPath.push('');
          }
          var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';
          // put the host back
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || result.host && srcPath.length;
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join('/');
          }
          //to support request.http
          if (!isNull(result.pathname) || !isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function () {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ':') {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host)
            this.hostname = host;
        };
        function isString(arg) {
          return typeof arg === 'string';
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isNull(arg) {
          return arg === null;
        }
        function isNullOrUndefined(arg) {
          return arg == null;
        }
      },
      {
        'punycode': 116,
        'querystring': 119
      }
    ],
    147: [
      function (require, module, exports) {
        (function (global) {
          /**
 * Module exports.
 */
          module.exports = deprecate;
          /**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */
          function deprecate(fn, msg) {
            if (config('noDeprecation')) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config('throwDeprecation')) {
                  throw new Error(msg);
                } else if (config('traceDeprecation')) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          }
          /**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */
          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage)
                return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val)
              return false;
            return String(val).toLowerCase() === 'true';
          }
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    148: [
      function (require, module, exports) {
        arguments[4][54][0].apply(exports, arguments);
      },
      { 'dup': 54 }
    ],
    149: [
      function (require, module, exports) {
        module.exports = function isBuffer(arg) {
          return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
        };
      },
      {}
    ],
    150: [
      function (require, module, exports) {
        (function (process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          var formatRegExp = /%[sdj%]/g;
          exports.format = function (f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(' ');
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function (x) {
                if (x === '%%')
                  return '%';
                if (i >= len)
                  return x;
                switch (x) {
                case '%s':
                  return String(args[i++]);
                case '%d':
                  return Number(args[i++]);
                case '%j':
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return '[Circular]';
                  }
                default:
                  return x;
                }
              });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }
            return str;
          };
          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function (fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
              return function () {
                return exports.deprecate(fn, msg).apply(this, arguments);
              };
            }
            if (process.noDeprecation === true) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          };
          var debugs = {};
          var debugEnviron;
          exports.debuglog = function (set) {
            if (isUndefined(debugEnviron))
              debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                var pid = process.pid;
                debugs[set] = function () {
                  var msg = exports.format.apply(exports, arguments);
                  console.error('%s %d: %s', set, pid, msg);
                };
              } else {
                debugs[set] = function () {
                };
              }
            }
            return debugs[set];
          };
          /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
          /* legacy: obj, showHidden, depth, colors*/
          function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
            // legacy...
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts;
            } else if (opts) {
              // got an "options" object
              exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports.inspect = inspect;
          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            'bold': [
              1,
              22
            ],
            'italic': [
              3,
              23
            ],
            'underline': [
              4,
              24
            ],
            'inverse': [
              7,
              27
            ],
            'white': [
              37,
              39
            ],
            'grey': [
              90,
              39
            ],
            'black': [
              30,
              39
            ],
            'blue': [
              34,
              39
            ],
            'cyan': [
              36,
              39
            ],
            'green': [
              32,
              39
            ],
            'magenta': [
              35,
              39
            ],
            'red': [
              31,
              39
            ],
            'yellow': [
              33,
              39
            ]
          };
          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            'regexp': 'red'
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
              return '\x1b[' + inspect.colors[style][0] + 'm' + str + '\x1b[' + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function (val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }
            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
              return formatError(value);
            }
            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }
              if (isError(value)) {
                return formatError(value);
              }
            }
            var base = '', array = false, braces = [
                '{',
                '}'
              ];
            // Make Array say that they are Array
            if (isArray(value)) {
              array = true;
              braces = [
                '[',
                ']'
              ];
            }
            // Make functions say that they are functions
            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            }
            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            }
            // Make dates with properties first say the date
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            }
            // Make error with message first say the error
            if (isError(value)) {
              base = ' ' + formatError(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function (key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, '\\\'').replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
              return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
              return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
              return ctx.stylize('null', 'null');
          }
          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push('');
              }
            }
            keys.forEach(function (key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function (line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function (line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, '\\\'').replace(/\\"/g, '"').replace(/(^"|"$)/g, '\'');
                name = ctx.stylize(name, 'string');
              }
            }
            return name + ': ' + str;
          }
          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function (prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0)
                  numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
              }, 0);
            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }
            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }
          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          exports.isBuffer = require('./support/isBuffer');
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }
          var months = [
              'Jan',
              'Feb',
              'Mar',
              'Apr',
              'May',
              'Jun',
              'Jul',
              'Aug',
              'Sep',
              'Oct',
              'Nov',
              'Dec'
            ];
          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date();
            var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())
              ].join(':');
            return [
              d.getDate(),
              months[d.getMonth()],
              time
            ].join(' ');
          }
          // log is just a thin wrapper to console.log that prepends a timestamp
          exports.log = function () {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
          };
          /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
          exports.inherits = require('inherits');
          exports._extend = function (origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add))
              return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {
        './support/isBuffer': 149,
        '_process': 115,
        'inherits': 148
      }
    ],
    151: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _toDate = require('./lib/toDate');
        var _toDate2 = _interopRequireDefault(_toDate);
        var _toFloat = require('./lib/toFloat');
        var _toFloat2 = _interopRequireDefault(_toFloat);
        var _toInt = require('./lib/toInt');
        var _toInt2 = _interopRequireDefault(_toInt);
        var _toBoolean = require('./lib/toBoolean');
        var _toBoolean2 = _interopRequireDefault(_toBoolean);
        var _equals = require('./lib/equals');
        var _equals2 = _interopRequireDefault(_equals);
        var _contains = require('./lib/contains');
        var _contains2 = _interopRequireDefault(_contains);
        var _matches = require('./lib/matches');
        var _matches2 = _interopRequireDefault(_matches);
        var _isEmail = require('./lib/isEmail');
        var _isEmail2 = _interopRequireDefault(_isEmail);
        var _isURL = require('./lib/isURL');
        var _isURL2 = _interopRequireDefault(_isURL);
        var _isMACAddress = require('./lib/isMACAddress');
        var _isMACAddress2 = _interopRequireDefault(_isMACAddress);
        var _isIP = require('./lib/isIP');
        var _isIP2 = _interopRequireDefault(_isIP);
        var _isFQDN = require('./lib/isFQDN');
        var _isFQDN2 = _interopRequireDefault(_isFQDN);
        var _isBoolean = require('./lib/isBoolean');
        var _isBoolean2 = _interopRequireDefault(_isBoolean);
        var _isAlpha = require('./lib/isAlpha');
        var _isAlpha2 = _interopRequireDefault(_isAlpha);
        var _isAlphanumeric = require('./lib/isAlphanumeric');
        var _isAlphanumeric2 = _interopRequireDefault(_isAlphanumeric);
        var _isNumeric = require('./lib/isNumeric');
        var _isNumeric2 = _interopRequireDefault(_isNumeric);
        var _isLowercase = require('./lib/isLowercase');
        var _isLowercase2 = _interopRequireDefault(_isLowercase);
        var _isUppercase = require('./lib/isUppercase');
        var _isUppercase2 = _interopRequireDefault(_isUppercase);
        var _isAscii = require('./lib/isAscii');
        var _isAscii2 = _interopRequireDefault(_isAscii);
        var _isFullWidth = require('./lib/isFullWidth');
        var _isFullWidth2 = _interopRequireDefault(_isFullWidth);
        var _isHalfWidth = require('./lib/isHalfWidth');
        var _isHalfWidth2 = _interopRequireDefault(_isHalfWidth);
        var _isVariableWidth = require('./lib/isVariableWidth');
        var _isVariableWidth2 = _interopRequireDefault(_isVariableWidth);
        var _isMultibyte = require('./lib/isMultibyte');
        var _isMultibyte2 = _interopRequireDefault(_isMultibyte);
        var _isSurrogatePair = require('./lib/isSurrogatePair');
        var _isSurrogatePair2 = _interopRequireDefault(_isSurrogatePair);
        var _isInt = require('./lib/isInt');
        var _isInt2 = _interopRequireDefault(_isInt);
        var _isFloat = require('./lib/isFloat');
        var _isFloat2 = _interopRequireDefault(_isFloat);
        var _isDecimal = require('./lib/isDecimal');
        var _isDecimal2 = _interopRequireDefault(_isDecimal);
        var _isHexadecimal = require('./lib/isHexadecimal');
        var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
        var _isDivisibleBy = require('./lib/isDivisibleBy');
        var _isDivisibleBy2 = _interopRequireDefault(_isDivisibleBy);
        var _isHexColor = require('./lib/isHexColor');
        var _isHexColor2 = _interopRequireDefault(_isHexColor);
        var _isMD = require('./lib/isMD5');
        var _isMD2 = _interopRequireDefault(_isMD);
        var _isJSON = require('./lib/isJSON');
        var _isJSON2 = _interopRequireDefault(_isJSON);
        var _isNull = require('./lib/isNull');
        var _isNull2 = _interopRequireDefault(_isNull);
        var _isLength = require('./lib/isLength');
        var _isLength2 = _interopRequireDefault(_isLength);
        var _isByteLength = require('./lib/isByteLength');
        var _isByteLength2 = _interopRequireDefault(_isByteLength);
        var _isUUID = require('./lib/isUUID');
        var _isUUID2 = _interopRequireDefault(_isUUID);
        var _isMongoId = require('./lib/isMongoId');
        var _isMongoId2 = _interopRequireDefault(_isMongoId);
        var _isDate = require('./lib/isDate');
        var _isDate2 = _interopRequireDefault(_isDate);
        var _isAfter = require('./lib/isAfter');
        var _isAfter2 = _interopRequireDefault(_isAfter);
        var _isBefore = require('./lib/isBefore');
        var _isBefore2 = _interopRequireDefault(_isBefore);
        var _isIn = require('./lib/isIn');
        var _isIn2 = _interopRequireDefault(_isIn);
        var _isCreditCard = require('./lib/isCreditCard');
        var _isCreditCard2 = _interopRequireDefault(_isCreditCard);
        var _isISIN = require('./lib/isISIN');
        var _isISIN2 = _interopRequireDefault(_isISIN);
        var _isISBN = require('./lib/isISBN');
        var _isISBN2 = _interopRequireDefault(_isISBN);
        var _isMobilePhone = require('./lib/isMobilePhone');
        var _isMobilePhone2 = _interopRequireDefault(_isMobilePhone);
        var _isCurrency = require('./lib/isCurrency');
        var _isCurrency2 = _interopRequireDefault(_isCurrency);
        var _isISO = require('./lib/isISO8601');
        var _isISO2 = _interopRequireDefault(_isISO);
        var _isBase = require('./lib/isBase64');
        var _isBase2 = _interopRequireDefault(_isBase);
        var _isDataURI = require('./lib/isDataURI');
        var _isDataURI2 = _interopRequireDefault(_isDataURI);
        var _ltrim = require('./lib/ltrim');
        var _ltrim2 = _interopRequireDefault(_ltrim);
        var _rtrim = require('./lib/rtrim');
        var _rtrim2 = _interopRequireDefault(_rtrim);
        var _trim = require('./lib/trim');
        var _trim2 = _interopRequireDefault(_trim);
        var _escape = require('./lib/escape');
        var _escape2 = _interopRequireDefault(_escape);
        var _unescape = require('./lib/unescape');
        var _unescape2 = _interopRequireDefault(_unescape);
        var _stripLow = require('./lib/stripLow');
        var _stripLow2 = _interopRequireDefault(_stripLow);
        var _whitelist = require('./lib/whitelist');
        var _whitelist2 = _interopRequireDefault(_whitelist);
        var _blacklist = require('./lib/blacklist');
        var _blacklist2 = _interopRequireDefault(_blacklist);
        var _isWhitelisted = require('./lib/isWhitelisted');
        var _isWhitelisted2 = _interopRequireDefault(_isWhitelisted);
        var _normalizeEmail = require('./lib/normalizeEmail');
        var _normalizeEmail2 = _interopRequireDefault(_normalizeEmail);
        var _toString = require('./lib/util/toString');
        var _toString2 = _interopRequireDefault(_toString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var version = '5.7.0';
        var validator = {
            version: version,
            toDate: _toDate2.default,
            toFloat: _toFloat2.default,
            toInt: _toInt2.default,
            toBoolean: _toBoolean2.default,
            equals: _equals2.default,
            contains: _contains2.default,
            matches: _matches2.default,
            isEmail: _isEmail2.default,
            isURL: _isURL2.default,
            isMACAddress: _isMACAddress2.default,
            isIP: _isIP2.default,
            isFQDN: _isFQDN2.default,
            isBoolean: _isBoolean2.default,
            isAlpha: _isAlpha2.default,
            isAlphanumeric: _isAlphanumeric2.default,
            isNumeric: _isNumeric2.default,
            isLowercase: _isLowercase2.default,
            isUppercase: _isUppercase2.default,
            isAscii: _isAscii2.default,
            isFullWidth: _isFullWidth2.default,
            isHalfWidth: _isHalfWidth2.default,
            isVariableWidth: _isVariableWidth2.default,
            isMultibyte: _isMultibyte2.default,
            isSurrogatePair: _isSurrogatePair2.default,
            isInt: _isInt2.default,
            isFloat: _isFloat2.default,
            isDecimal: _isDecimal2.default,
            isHexadecimal: _isHexadecimal2.default,
            isDivisibleBy: _isDivisibleBy2.default,
            isHexColor: _isHexColor2.default,
            isMD5: _isMD2.default,
            isJSON: _isJSON2.default,
            isNull: _isNull2.default,
            isLength: _isLength2.default,
            isByteLength: _isByteLength2.default,
            isUUID: _isUUID2.default,
            isMongoId: _isMongoId2.default,
            isDate: _isDate2.default,
            isAfter: _isAfter2.default,
            isBefore: _isBefore2.default,
            isIn: _isIn2.default,
            isCreditCard: _isCreditCard2.default,
            isISIN: _isISIN2.default,
            isISBN: _isISBN2.default,
            isMobilePhone: _isMobilePhone2.default,
            isCurrency: _isCurrency2.default,
            isISO8601: _isISO2.default,
            isBase64: _isBase2.default,
            isDataURI: _isDataURI2.default,
            ltrim: _ltrim2.default,
            rtrim: _rtrim2.default,
            trim: _trim2.default,
            escape: _escape2.default,
            unescape: _unescape2.default,
            stripLow: _stripLow2.default,
            whitelist: _whitelist2.default,
            blacklist: _blacklist2.default,
            isWhitelisted: _isWhitelisted2.default,
            normalizeEmail: _normalizeEmail2.default,
            toString: _toString2.default
          };
        exports.default = validator;
        module.exports = exports['default'];
      },
      {
        './lib/blacklist': 153,
        './lib/contains': 154,
        './lib/equals': 155,
        './lib/escape': 156,
        './lib/isAfter': 157,
        './lib/isAlpha': 158,
        './lib/isAlphanumeric': 159,
        './lib/isAscii': 160,
        './lib/isBase64': 161,
        './lib/isBefore': 162,
        './lib/isBoolean': 163,
        './lib/isByteLength': 164,
        './lib/isCreditCard': 165,
        './lib/isCurrency': 166,
        './lib/isDataURI': 167,
        './lib/isDate': 168,
        './lib/isDecimal': 169,
        './lib/isDivisibleBy': 170,
        './lib/isEmail': 171,
        './lib/isFQDN': 172,
        './lib/isFloat': 173,
        './lib/isFullWidth': 174,
        './lib/isHalfWidth': 175,
        './lib/isHexColor': 176,
        './lib/isHexadecimal': 177,
        './lib/isIP': 178,
        './lib/isISBN': 179,
        './lib/isISIN': 180,
        './lib/isISO8601': 181,
        './lib/isIn': 182,
        './lib/isInt': 183,
        './lib/isJSON': 184,
        './lib/isLength': 185,
        './lib/isLowercase': 186,
        './lib/isMACAddress': 187,
        './lib/isMD5': 188,
        './lib/isMobilePhone': 189,
        './lib/isMongoId': 190,
        './lib/isMultibyte': 191,
        './lib/isNull': 192,
        './lib/isNumeric': 193,
        './lib/isSurrogatePair': 194,
        './lib/isURL': 195,
        './lib/isUUID': 196,
        './lib/isUppercase': 197,
        './lib/isVariableWidth': 198,
        './lib/isWhitelisted': 199,
        './lib/ltrim': 200,
        './lib/matches': 201,
        './lib/normalizeEmail': 202,
        './lib/rtrim': 203,
        './lib/stripLow': 204,
        './lib/toBoolean': 205,
        './lib/toDate': 206,
        './lib/toFloat': 207,
        './lib/toInt': 208,
        './lib/trim': 209,
        './lib/unescape': 210,
        './lib/util/toString': 213,
        './lib/whitelist': 214
      }
    ],
    152: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var alpha = exports.alpha = {
            'en-US': /^[A-Z]+$/i,
            'cs-CZ': /^[A-Z]+$/i,
            'de-DE': /^[A-Z]+$/i,
            'es-ES': /^[A-Z]+$/i,
            'fr-FR': /^[A-Z]+$/i,
            'nl-NL': /^[A-Z]+$/i,
            'hu-HU': /^[A-Z]+$/i,
            'pl-PL': /^[A-Z]+$/i,
            'pt-PT': /^[A-Z]+$/i,
            'ru-RU': /^[-]+$/i,
            'sr-RS@latin': /^[A-Z]+$/i,
            'sr-RS': /^[-]+$/i,
            'tr-TR': /^[A-Z]+$/i,
            ar: /^[]+$/
          };
        var alphanumeric = exports.alphanumeric = {
            'en-US': /^[0-9A-Z]+$/i,
            'cs-CZ': /^[0-9A-Z]+$/i,
            'de-DE': /^[0-9A-Z]+$/i,
            'es-ES': /^[0-9A-Z]+$/i,
            'fr-FR': /^[0-9A-Z]+$/i,
            'hu-HU': /^[0-9A-Z]+$/i,
            'nl-NL': /^[0-9A-Z]+$/i,
            'pl-PL': /^[0-9A-Z]+$/i,
            'pt-PT': /^[0-9A-Z]+$/i,
            'ru-RU': /^[0-9-]+$/i,
            'sr-RS@latin': /^[0-9A-Z]+$/i,
            'sr-RS': /^[0-9-]+$/i,
            'tr-TR': /^[0-9A-Z]+$/i,
            ar: /^[0-9]+$/
          };
        var englishLocales = exports.englishLocales = [
            'AU',
            'GB',
            'HK',
            'IN',
            'NZ',
            'ZA',
            'ZM'
          ];
        for (var locale, i = 0; i < englishLocales.length; i++) {
          locale = 'en-' + englishLocales[i];
          alpha[locale] = alpha['en-US'];
          alphanumeric[locale] = alphanumeric['en-US'];
        }
        alpha['pt-BR'] = alpha['pt-PT'];
        alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
        // Source: http://www.localeplanet.com/java/
        var arabicLocales = exports.arabicLocales = [
            'AE',
            'BH',
            'DZ',
            'EG',
            'IQ',
            'JO',
            'KW',
            'LB',
            'LY',
            'MA',
            'QM',
            'QA',
            'SA',
            'SD',
            'SY',
            'TN',
            'YE'
          ];
        for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
          _locale = 'ar-' + arabicLocales[_i];
          alpha[_locale] = alpha.ar;
          alphanumeric[_locale] = alphanumeric.ar;
        }
      },
      {}
    ],
    153: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = blacklist;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function blacklist(str, chars) {
          (0, _assertString2.default)(str);
          return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    154: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = contains;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toString = require('./util/toString');
        var _toString2 = _interopRequireDefault(_toString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function contains(str, elem) {
          (0, _assertString2.default)(str);
          return str.indexOf((0, _toString2.default)(elem)) >= 0;
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 211,
        './util/toString': 213
      }
    ],
    155: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = equals;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function equals(str, comparison) {
          (0, _assertString2.default)(str);
          return str === comparison;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    156: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = escape;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function escape(str) {
          (0, _assertString2.default)(str);
          return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/`/g, '&#96;');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    157: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAfter;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toDate = require('./toDate');
        var _toDate2 = _interopRequireDefault(_toDate);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isAfter(str) {
          var date = arguments.length <= 1 || arguments[1] === undefined ? String(new Date()) : arguments[1];
          (0, _assertString2.default)(str);
          var comparison = (0, _toDate2.default)(date);
          var original = (0, _toDate2.default)(str);
          return !!(original && comparison && original > comparison);
        }
        module.exports = exports['default'];
      },
      {
        './toDate': 206,
        './util/assertString': 211
      }
    ],
    158: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAlpha;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _alpha = require('./alpha');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isAlpha(str) {
          var locale = arguments.length <= 1 || arguments[1] === undefined ? 'en-US' : arguments[1];
          (0, _assertString2.default)(str);
          if (locale in _alpha.alpha) {
            return _alpha.alpha[locale].test(str);
          }
          throw new Error('Invalid locale \'' + locale + '\'');
        }
        module.exports = exports['default'];
      },
      {
        './alpha': 152,
        './util/assertString': 211
      }
    ],
    159: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAlphanumeric;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _alpha = require('./alpha');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isAlphanumeric(str) {
          var locale = arguments.length <= 1 || arguments[1] === undefined ? 'en-US' : arguments[1];
          (0, _assertString2.default)(str);
          if (locale in _alpha.alphanumeric) {
            return _alpha.alphanumeric[locale].test(str);
          }
          throw new Error('Invalid locale \'' + locale + '\'');
        }
        module.exports = exports['default'];
      },
      {
        './alpha': 152,
        './util/assertString': 211
      }
    ],
    160: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAscii;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable no-control-regex */
        var ascii = /^[\x00-\x7F]+$/;
        /* eslint-enable no-control-regex */
        function isAscii(str) {
          (0, _assertString2.default)(str);
          return ascii.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    161: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isBase64;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var notBase64 = /[^A-Z0-9+\/=]/i;
        function isBase64(str) {
          (0, _assertString2.default)(str);
          var len = str.length;
          if (!len || len % 4 !== 0 || notBase64.test(str)) {
            return false;
          }
          var firstPaddingChar = str.indexOf('=');
          return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    162: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isBefore;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toDate = require('./toDate');
        var _toDate2 = _interopRequireDefault(_toDate);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isBefore(str) {
          var date = arguments.length <= 1 || arguments[1] === undefined ? String(new Date()) : arguments[1];
          (0, _assertString2.default)(str);
          var comparison = (0, _toDate2.default)(date);
          var original = (0, _toDate2.default)(str);
          return !!(original && comparison && original < comparison);
        }
        module.exports = exports['default'];
      },
      {
        './toDate': 206,
        './util/assertString': 211
      }
    ],
    163: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isBoolean;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isBoolean(str) {
          (0, _assertString2.default)(str);
          return [
            'true',
            'false',
            '1',
            '0'
          ].indexOf(str) >= 0;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    164: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol ? 'symbol' : typeof obj;
          };
        exports.default = isByteLength;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable prefer-rest-params */
        function isByteLength(str, options) {
          (0, _assertString2.default)(str);
          var min = void 0;
          var max = void 0;
          if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            min = options.min || 0;
            max = options.max;
          } else {
            // backwards compatibility: isByteLength(str, min [, max])
            min = arguments[1];
            max = arguments[2];
          }
          var len = encodeURI(str).split(/%..|./).length - 1;
          return len >= min && (typeof max === 'undefined' || len <= max);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    165: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isCreditCard;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable max-len */
        var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})|62[0-9]{14}$/;
        /* eslint-enable max-len */
        function isCreditCard(str) {
          (0, _assertString2.default)(str);
          var sanitized = str.replace(/[^0-9]+/g, '');
          if (!creditCard.test(sanitized)) {
            return false;
          }
          var sum = 0;
          var digit = void 0;
          var tmpNum = void 0;
          var shouldDouble = void 0;
          for (var i = sanitized.length - 1; i >= 0; i--) {
            digit = sanitized.substring(i, i + 1);
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
              tmpNum *= 2;
              if (tmpNum >= 10) {
                sum += tmpNum % 10 + 1;
              } else {
                sum += tmpNum;
              }
            } else {
              sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
          }
          return !!(sum % 10 === 0 ? sanitized : false);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    166: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isCurrency;
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function currencyRegex(options) {
          var symbol = '(\\' + options.symbol.replace(/\./g, '\\.') + ')' + (options.require_symbol ? '' : '?'), negative = '-?', whole_dollar_amount_without_sep = '[1-9]\\d*', whole_dollar_amount_with_sep = '[1-9]\\d{0,2}(\\' + options.thousands_separator + '\\d{3})*', valid_whole_dollar_amounts = [
              '0',
              whole_dollar_amount_without_sep,
              whole_dollar_amount_with_sep
            ], whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?', decimal_amount = '(\\' + options.decimal_separator + '\\d{2})?';
          var pattern = whole_dollar_amount + decimal_amount;
          // default is negative sign before symbol, but there are two other options (besides parens)
          if (options.allow_negatives && !options.parens_for_negatives) {
            if (options.negative_sign_after_digits) {
              pattern += negative;
            } else if (options.negative_sign_before_digits) {
              pattern = negative + pattern;
            }
          }
          // South African Rand, for example, uses R 123 (space) and R-123 (no space)
          if (options.allow_negative_sign_placeholder) {
            pattern = '( (?!\\-))?' + pattern;
          } else if (options.allow_space_after_symbol) {
            pattern = ' ?' + pattern;
          } else if (options.allow_space_after_digits) {
            pattern += '( (?!$))?';
          }
          if (options.symbol_after_digits) {
            pattern += symbol;
          } else {
            pattern = symbol + pattern;
          }
          if (options.allow_negatives) {
            if (options.parens_for_negatives) {
              pattern = '(\\(' + pattern + '\\)|' + pattern + ')';
            } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
              pattern = negative + pattern;
            }
          }
          /* eslint-disable prefer-template */
          return new RegExp('^' + '(?!-? )(?=.*\\d)' + pattern + '$');  /* eslint-enable prefer-template */
        }
        var default_currency_options = {
            symbol: '$',
            require_symbol: false,
            allow_space_after_symbol: false,
            symbol_after_digits: false,
            allow_negatives: true,
            parens_for_negatives: false,
            negative_sign_before_digits: false,
            negative_sign_after_digits: false,
            allow_negative_sign_placeholder: false,
            thousands_separator: ',',
            decimal_separator: '.',
            allow_space_after_digits: false
          };
        function isCurrency(str, options) {
          (0, _assertString2.default)(str);
          options = (0, _merge2.default)(options, default_currency_options);
          return currencyRegex(options).test(str);
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 211,
        './util/merge': 212
      }
    ],
    167: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isDataURI;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var dataURI = /^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9!\$&',\(\)\*\+,;=\-\._~:@\/\?%\s]*\s*$/i;
        // eslint-disable-line max-len
        function isDataURI(str) {
          (0, _assertString2.default)(str);
          return dataURI.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    168: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isDate;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _isISO = require('./isISO8601');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function getTimezoneOffset(str) {
          var iso8601Parts = str.match(_isISO.iso8601);
          var timezone = void 0, sign = void 0, hours = void 0, minutes = void 0;
          if (!iso8601Parts) {
            str = str.toLowerCase();
            timezone = str.match(/(?:\s|gmt\s*)(-|\+)(\d{1,4})(\s|$)/);
            if (!timezone) {
              return str.indexOf('gmt') !== -1 ? 0 : null;
            }
            sign = timezone[1];
            var offset = timezone[2];
            if (offset.length === 3) {
              offset = '0' + offset;
            }
            if (offset.length <= 2) {
              hours = 0;
              minutes = parseInt(offset, 10);
            } else {
              hours = parseInt(offset.slice(0, 2), 10);
              minutes = parseInt(offset.slice(2, 4), 10);
            }
          } else {
            timezone = iso8601Parts[21];
            if (!timezone) {
              // if no hour/minute was provided, the date is GMT
              return !iso8601Parts[12] ? 0 : null;
            }
            if (timezone === 'z' || timezone === 'Z') {
              return 0;
            }
            sign = iso8601Parts[22];
            if (timezone.indexOf(':') !== -1) {
              hours = parseInt(iso8601Parts[23], 10);
              minutes = parseInt(iso8601Parts[24], 10);
            } else {
              hours = 0;
              minutes = parseInt(iso8601Parts[23], 10);
            }
          }
          return (hours * 60 + minutes) * (sign === '-' ? 1 : -1);
        }
        function isDate(str) {
          (0, _assertString2.default)(str);
          var normalizedDate = new Date(Date.parse(str));
          if (isNaN(normalizedDate)) {
            return false;
          }
          // normalizedDate is in the user's timezone. Apply the input
          // timezone offset to the date so that the year and day match
          // the input
          var timezoneOffset = getTimezoneOffset(str);
          if (timezoneOffset !== null) {
            var timezoneDifference = normalizedDate.getTimezoneOffset() - timezoneOffset;
            normalizedDate = new Date(normalizedDate.getTime() + 60000 * timezoneDifference);
          }
          var day = String(normalizedDate.getDate());
          var dayOrYear = void 0, dayOrYearMatches = void 0, year = void 0;
          // check for valid double digits that could be late days
          // check for all matches since a string like '12/23' is a valid date
          // ignore everything with nearby colons
          dayOrYearMatches = str.match(/(^|[^:\d])[23]\d([^T:\d]|$)/g);
          if (!dayOrYearMatches) {
            return true;
          }
          dayOrYear = dayOrYearMatches.map(function (digitString) {
            return digitString.match(/\d+/g)[0];
          }).join('/');
          year = String(normalizedDate.getFullYear()).slice(-2);
          if (dayOrYear === day || dayOrYear === year) {
            return true;
          } else if (dayOrYear === '' + day / year || dayOrYear === '' + year / day) {
            return true;
          }
          return false;
        }
        module.exports = exports['default'];
      },
      {
        './isISO8601': 181,
        './util/assertString': 211
      }
    ],
    169: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isDecimal;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var decimal = /^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/;
        function isDecimal(str) {
          (0, _assertString2.default)(str);
          return str !== '' && decimal.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    170: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isDivisibleBy;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toFloat = require('./toFloat');
        var _toFloat2 = _interopRequireDefault(_toFloat);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isDivisibleBy(str, num) {
          (0, _assertString2.default)(str);
          return (0, _toFloat2.default)(str) % parseInt(num, 10) === 0;
        }
        module.exports = exports['default'];
      },
      {
        './toFloat': 207,
        './util/assertString': 211
      }
    ],
    171: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isEmail;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        var _isByteLength = require('./isByteLength');
        var _isByteLength2 = _interopRequireDefault(_isByteLength);
        var _isFQDN = require('./isFQDN');
        var _isFQDN2 = _interopRequireDefault(_isFQDN);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_email_options = {
            allow_display_name: false,
            allow_utf8_local_part: true,
            require_tld: true
          };
        /* eslint-disable max-len */
        /* eslint-disable no-control-regex */
        var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
        var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
        var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
        var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
        var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
        /* eslint-enable max-len */
        /* eslint-enable no-control-regex */
        function isEmail(str, options) {
          (0, _assertString2.default)(str);
          options = (0, _merge2.default)(options, default_email_options);
          if (options.allow_display_name) {
            var display_email = str.match(displayName);
            if (display_email) {
              str = display_email[1];
            }
          }
          var parts = str.split('@');
          var domain = parts.pop();
          var user = parts.join('@');
          var lower_domain = domain.toLowerCase();
          if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
            user = user.replace(/\./g, '').toLowerCase();
          }
          if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 256 })) {
            return false;
          }
          if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
            return false;
          }
          if (user[0] === '"') {
            user = user.slice(1, user.length - 1);
            return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
          }
          var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
          var user_parts = user.split('.');
          for (var i = 0; i < user_parts.length; i++) {
            if (!pattern.test(user_parts[i])) {
              return false;
            }
          }
          return true;
        }
        module.exports = exports['default'];
      },
      {
        './isByteLength': 164,
        './isFQDN': 172,
        './util/assertString': 211,
        './util/merge': 212
      }
    ],
    172: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isFDQN;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_fqdn_options = {
            require_tld: true,
            allow_underscores: false,
            allow_trailing_dot: false
          };
        function isFDQN(str, options) {
          (0, _assertString2.default)(str);
          options = (0, _merge2.default)(options, default_fqdn_options);
          /* Remove the optional trailing dot before checking validity */
          if (options.allow_trailing_dot && str[str.length - 1] === '.') {
            str = str.substring(0, str.length - 1);
          }
          var parts = str.split('.');
          if (options.require_tld) {
            var tld = parts.pop();
            if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
              return false;
            }
          }
          for (var part, i = 0; i < parts.length; i++) {
            part = parts[i];
            if (options.allow_underscores) {
              part = part.replace(/_/g, '');
            }
            if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
              return false;
            }
            if (/[\uff01-\uff5e]/.test(part)) {
              // disallow full-width chars
              return false;
            }
            if (part[0] === '-' || part[part.length - 1] === '-') {
              return false;
            }
          }
          return true;
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 211,
        './util/merge': 212
      }
    ],
    173: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isFloat;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var float = /^(?:[-+]?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/;
        function isFloat(str, options) {
          (0, _assertString2.default)(str);
          options = options || {};
          if (str === '' || str === '.') {
            return false;
          }
          return float.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    174: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.fullWidth = undefined;
        exports.default = isFullWidth;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var fullWidth = exports.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        function isFullWidth(str) {
          (0, _assertString2.default)(str);
          return fullWidth.test(str);
        }
      },
      { './util/assertString': 211 }
    ],
    175: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.halfWidth = undefined;
        exports.default = isHalfWidth;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var halfWidth = exports.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        function isHalfWidth(str) {
          (0, _assertString2.default)(str);
          return halfWidth.test(str);
        }
      },
      { './util/assertString': 211 }
    ],
    176: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isHexColor;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;
        function isHexColor(str) {
          (0, _assertString2.default)(str);
          return hexcolor.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    177: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isHexadecimal;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var hexadecimal = /^[0-9A-F]+$/i;
        function isHexadecimal(str) {
          (0, _assertString2.default)(str);
          return hexadecimal.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    178: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isIP;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
        var ipv6Block = /^[0-9A-F]{1,4}$/i;
        function isIP(str) {
          var version = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
          (0, _assertString2.default)(str);
          version = String(version);
          if (!version) {
            return isIP(str, 4) || isIP(str, 6);
          } else if (version === '4') {
            if (!ipv4Maybe.test(str)) {
              return false;
            }
            var parts = str.split('.').sort(function (a, b) {
                return a - b;
              });
            return parts[3] <= 255;
          } else if (version === '6') {
            var blocks = str.split(':');
            var foundOmissionBlock = false;
            // marker to indicate ::
            // At least some OS accept the last 32 bits of an IPv6 address
            // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
            // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
            // and '::a.b.c.d' is deprecated, but also valid.
            var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
            var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
            if (blocks.length > expectedNumberOfBlocks) {
              return false;
            }
            // initial or final ::
            if (str === '::') {
              return true;
            } else if (str.substr(0, 2) === '::') {
              blocks.shift();
              blocks.shift();
              foundOmissionBlock = true;
            } else if (str.substr(str.length - 2) === '::') {
              blocks.pop();
              blocks.pop();
              foundOmissionBlock = true;
            }
            for (var i = 0; i < blocks.length; ++i) {
              // test for a :: which can not be at the string start/end
              // since those cases have been handled above
              if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
                if (foundOmissionBlock) {
                  return false;  // multiple :: in address
                }
                foundOmissionBlock = true;
              } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
              } else if (!ipv6Block.test(blocks[i])) {
                return false;
              }
            }
            if (foundOmissionBlock) {
              return blocks.length >= 1;
            }
            return blocks.length === expectedNumberOfBlocks;
          }
          return false;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    179: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISBN;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
        var isbn13Maybe = /^(?:[0-9]{13})$/;
        var factor = [
            1,
            3
          ];
        function isISBN(str) {
          var version = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
          (0, _assertString2.default)(str);
          version = String(version);
          if (!version) {
            return isISBN(str, 10) || isISBN(str, 13);
          }
          var sanitized = str.replace(/[\s-]+/g, '');
          var checksum = 0;
          var i = void 0;
          if (version === '10') {
            if (!isbn10Maybe.test(sanitized)) {
              return false;
            }
            for (i = 0; i < 9; i++) {
              checksum += (i + 1) * sanitized.charAt(i);
            }
            if (sanitized.charAt(9) === 'X') {
              checksum += 10 * 10;
            } else {
              checksum += 10 * sanitized.charAt(9);
            }
            if (checksum % 11 === 0) {
              return !!sanitized;
            }
          } else if (version === '13') {
            if (!isbn13Maybe.test(sanitized)) {
              return false;
            }
            for (i = 0; i < 12; i++) {
              checksum += factor[i % 2] * sanitized.charAt(i);
            }
            if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {
              return !!sanitized;
            }
          }
          return false;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    180: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISIN;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
        function isISIN(str) {
          (0, _assertString2.default)(str);
          if (!isin.test(str)) {
            return false;
          }
          var checksumStr = str.replace(/[A-Z]/g, function (character) {
              return parseInt(character, 36);
            });
          var sum = 0;
          var digit = void 0;
          var tmpNum = void 0;
          var shouldDouble = true;
          for (var i = checksumStr.length - 2; i >= 0; i--) {
            digit = checksumStr.substring(i, i + 1);
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
              tmpNum *= 2;
              if (tmpNum >= 10) {
                sum += tmpNum + 1;
              } else {
                sum += tmpNum;
              }
            } else {
              sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
          }
          return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    181: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.iso8601 = undefined;
        exports.default = function (str) {
          (0, _assertString2.default)(str);
          return iso8601.test(str);
        };
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable max-len */
        // from http://goo.gl/0ejHHW
        var iso8601 = exports.iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;  /* eslint-enable max-len */
      },
      { './util/assertString': 211 }
    ],
    182: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol ? 'symbol' : typeof obj;
          };
        exports.default = isIn;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toString = require('./util/toString');
        var _toString2 = _interopRequireDefault(_toString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isIn(str, options) {
          (0, _assertString2.default)(str);
          var i = void 0;
          if (Object.prototype.toString.call(options) === '[object Array]') {
            var array = [];
            for (i in options) {
              if ({}.hasOwnProperty.call(options, i)) {
                array[i] = (0, _toString2.default)(options[i]);
              }
            }
            return array.indexOf(str) >= 0;
          } else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            return options.hasOwnProperty(str);
          } else if (options && typeof options.indexOf === 'function') {
            return options.indexOf(str) >= 0;
          }
          return false;
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 211,
        './util/toString': 213
      }
    ],
    183: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isInt;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
        var intLeadingZeroes = /^[-+]?[0-9]+$/;
        function isInt(str, options) {
          (0, _assertString2.default)(str);
          options = options || {};
          // Get the regex to use for testing, based on whether
          // leading zeroes are allowed or not.
          var regex = options.hasOwnProperty('allow_leading_zeroes') && options.allow_leading_zeroes ? intLeadingZeroes : int;
          // Check min/max
          var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;
          var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;
          return regex.test(str) && minCheckPassed && maxCheckPassed;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    184: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol ? 'symbol' : typeof obj;
          };
        exports.default = isJSON;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isJSON(str) {
          (0, _assertString2.default)(str);
          try {
            var obj = JSON.parse(str);
            return !!obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
          } catch (e) {
          }
          return false;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    185: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol ? 'symbol' : typeof obj;
          };
        exports.default = isLength;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable prefer-rest-params */
        function isLength(str, options) {
          (0, _assertString2.default)(str);
          var min = void 0;
          var max = void 0;
          if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            min = options.min || 0;
            max = options.max;
          } else {
            // backwards compatibility: isLength(str, min [, max])
            min = arguments[1];
            max = arguments[2];
          }
          var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
          var len = str.length - surrogatePairs.length;
          return len >= min && (typeof max === 'undefined' || len <= max);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    186: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isLowercase;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isLowercase(str) {
          (0, _assertString2.default)(str);
          return str === str.toLowerCase();
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    187: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMACAddress;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
        function isMACAddress(str) {
          (0, _assertString2.default)(str);
          return macAddress.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    188: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMD5;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var md5 = /^[a-f0-9]{32}$/;
        function isMD5(str) {
          (0, _assertString2.default)(str);
          return md5.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    189: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMobilePhone;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable max-len */
        var phones = {
            'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
            'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
            'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
            'en-US': /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
            'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
            'de-DE': /^(\+?49[ \.\-])?([\(]{1}[0-9]{1,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,
            'da-DK': /^(\+?45)?(\d{8})$/,
            'el-GR': /^(\+?30)?(69\d{8})$/,
            'en-AU': /^(\+?61|0)4\d{8}$/,
            'en-GB': /^(\+?44|0)7\d{9}$/,
            'en-HK': /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
            'en-IN': /^(\+?91|0)?[789]\d{9}$/,
            'en-NZ': /^(\+?64|0)2\d{7,9}$/,
            'en-ZA': /^(\+?27|0)\d{9}$/,
            'en-ZM': /^(\+?26)?09[567]\d{7}$/,
            'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
            'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5)?|50)\s?(\d\s?){4,8}\d$/,
            'fr-FR': /^(\+?33|0)[67]\d{8}$/,
            'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
            'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
            'ja-JP': /^(\+?81|0)\d{1,4}[ \-]?\d{1,4}[ \-]?\d{4}$/,
            'ms-MY': /^(\+?6?01){1}(([145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
            'nb-NO': /^(\+?47)?[49]\d{7}$/,
            'nl-BE': /^(\+?32|0)4?\d{8}$/,
            'nn-NO': /^(\+?47)?[49]\d{7}$/,
            'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
            'pt-BR': /^(\+?55|0)\-?[1-9]{2}\-?[2-9]{1}\d{3,4}\-?\d{4}$/,
            'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
            'ru-RU': /^(\+?7|8)?9\d{9}$/,
            'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
            'tr-TR': /^(\+?90|0)?5\d{9}$/,
            'vi-VN': /^(\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,
            'zh-CN': /^(\+?0?86\-?)?1[345789]\d{9}$/,
            'zh-TW': /^(\+?886\-?|0)?9\d{8}$/
          };
        /* eslint-enable max-len */
        // aliases
        phones['en-CA'] = phones['en-US'];
        phones['fr-BE'] = phones['nl-BE'];
        function isMobilePhone(str, locale) {
          (0, _assertString2.default)(str);
          if (locale in phones) {
            return phones[locale].test(str);
          }
          return false;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    190: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMongoId;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _isHexadecimal = require('./isHexadecimal');
        var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isMongoId(str) {
          (0, _assertString2.default)(str);
          return (0, _isHexadecimal2.default)(str) && str.length === 24;
        }
        module.exports = exports['default'];
      },
      {
        './isHexadecimal': 177,
        './util/assertString': 211
      }
    ],
    191: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMultibyte;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable no-control-regex */
        var multibyte = /[^\x00-\x7F]/;
        /* eslint-enable no-control-regex */
        function isMultibyte(str) {
          (0, _assertString2.default)(str);
          return multibyte.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    192: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isNull;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isNull(str) {
          (0, _assertString2.default)(str);
          return str.length === 0;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    193: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isNumeric;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var numeric = /^[-+]?[0-9]+$/;
        function isNumeric(str) {
          (0, _assertString2.default)(str);
          return numeric.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    194: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isSurrogatePair;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
        function isSurrogatePair(str) {
          (0, _assertString2.default)(str);
          return surrogatePair.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    195: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isURL;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _isFQDN = require('./isFQDN');
        var _isFQDN2 = _interopRequireDefault(_isFQDN);
        var _isIP = require('./isIP');
        var _isIP2 = _interopRequireDefault(_isIP);
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_url_options = {
            protocols: [
              'http',
              'https',
              'ftp'
            ],
            require_tld: true,
            require_protocol: false,
            require_host: true,
            require_valid_protocol: true,
            allow_underscores: false,
            allow_trailing_dot: false,
            allow_protocol_relative_urls: false
          };
        var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
        function isRegExp(obj) {
          return Object.prototype.toString.call(obj) === '[object RegExp]';
        }
        function checkHost(host, matches) {
          for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            if (host === match || isRegExp(match) && match.test(host)) {
              return true;
            }
          }
          return false;
        }
        function isURL(url, options) {
          (0, _assertString2.default)(url);
          if (!url || url.length >= 2083 || /\s/.test(url)) {
            return false;
          }
          if (url.indexOf('mailto:') === 0) {
            return false;
          }
          options = (0, _merge2.default)(options, default_url_options);
          var protocol = void 0, auth = void 0, host = void 0, hostname = void 0, port = void 0, port_str = void 0, split = void 0, ipv6 = void 0;
          split = url.split('#');
          url = split.shift();
          split = url.split('?');
          url = split.shift();
          split = url.split('://');
          if (split.length > 1) {
            protocol = split.shift();
            if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
              return false;
            }
          } else if (options.require_protocol) {
            return false;
          } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
            split[0] = url.substr(2);
          }
          url = split.join('://');
          split = url.split('/');
          url = split.shift();
          if (url === '' && !options.require_host) {
            return true;
          }
          split = url.split('@');
          if (split.length > 1) {
            auth = split.shift();
            if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
              return false;
            }
          }
          hostname = split.join('@');
          port_str = ipv6 = null;
          var ipv6_match = hostname.match(wrapped_ipv6);
          if (ipv6_match) {
            host = '';
            ipv6 = ipv6_match[1];
            port_str = ipv6_match[2] || null;
          } else {
            split = hostname.split(':');
            host = split.shift();
            if (split.length) {
              port_str = split.join(':');
            }
          }
          if (port_str !== null) {
            port = parseInt(port_str, 10);
            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
              return false;
            }
          }
          if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6)) && host !== 'localhost') {
            return false;
          }
          host = host || ipv6;
          if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
            return false;
          }
          if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
            return false;
          }
          return true;
        }
        module.exports = exports['default'];
      },
      {
        './isFQDN': 172,
        './isIP': 178,
        './util/assertString': 211,
        './util/merge': 212
      }
    ],
    196: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isUUID;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var uuid = {
            3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
          };
        function isUUID(str) {
          var version = arguments.length <= 1 || arguments[1] === undefined ? 'all' : arguments[1];
          (0, _assertString2.default)(str);
          var pattern = uuid[version];
          return pattern && pattern.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    197: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isUppercase;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isUppercase(str) {
          (0, _assertString2.default)(str);
          return str === str.toUpperCase();
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    198: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isVariableWidth;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _isFullWidth = require('./isFullWidth');
        var _isHalfWidth = require('./isHalfWidth');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isVariableWidth(str) {
          (0, _assertString2.default)(str);
          return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
        }
        module.exports = exports['default'];
      },
      {
        './isFullWidth': 174,
        './isHalfWidth': 175,
        './util/assertString': 211
      }
    ],
    199: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isWhitelisted;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isWhitelisted(str, chars) {
          (0, _assertString2.default)(str);
          for (var i = str.length - 1; i >= 0; i--) {
            if (chars.indexOf(str[i]) === -1) {
              return false;
            }
          }
          return true;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    200: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = ltrim;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function ltrim(str, chars) {
          (0, _assertString2.default)(str);
          var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\s+/g;
          return str.replace(pattern, '');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    201: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = matches;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function matches(str, pattern, modifiers) {
          (0, _assertString2.default)(str);
          if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
            pattern = new RegExp(pattern, modifiers);
          }
          return pattern.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    202: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = normalizeEmail;
        var _isEmail = require('./isEmail');
        var _isEmail2 = _interopRequireDefault(_isEmail);
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_normalize_email_options = {
            lowercase: true,
            remove_dots: true,
            remove_extension: true
          };
        function normalizeEmail(email, options) {
          options = (0, _merge2.default)(options, default_normalize_email_options);
          if (!(0, _isEmail2.default)(email)) {
            return false;
          }
          var parts = email.split('@', 2);
          parts[1] = parts[1].toLowerCase();
          if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
            if (options.remove_extension) {
              parts[0] = parts[0].split('+')[0];
            }
            if (options.remove_dots) {
              parts[0] = parts[0].replace(/\./g, '');
            }
            if (!parts[0].length) {
              return false;
            }
            parts[0] = parts[0].toLowerCase();
            parts[1] = 'gmail.com';
          } else if (options.lowercase) {
            parts[0] = parts[0].toLowerCase();
          }
          return parts.join('@');
        }
        module.exports = exports['default'];
      },
      {
        './isEmail': 171,
        './util/merge': 212
      }
    ],
    203: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = rtrim;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function rtrim(str, chars) {
          (0, _assertString2.default)(str);
          var pattern = chars ? new RegExp('[' + chars + ']') : /\s/;
          var idx = str.length - 1;
          while (idx >= 0 && pattern.test(str[idx])) {
            idx--;
          }
          return idx < str.length ? str.substr(0, idx + 1) : str;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    204: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = stripLow;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _blacklist = require('./blacklist');
        var _blacklist2 = _interopRequireDefault(_blacklist);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function stripLow(str, keep_new_lines) {
          (0, _assertString2.default)(str);
          var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
          return (0, _blacklist2.default)(str, chars);
        }
        module.exports = exports['default'];
      },
      {
        './blacklist': 153,
        './util/assertString': 211
      }
    ],
    205: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toBoolean;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toBoolean(str, strict) {
          (0, _assertString2.default)(str);
          if (strict) {
            return str === '1' || str === 'true';
          }
          return str !== '0' && str !== 'false' && str !== '';
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    206: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toDate;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toDate(date) {
          (0, _assertString2.default)(date);
          date = Date.parse(date);
          return !isNaN(date) ? new Date(date) : null;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    207: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toFloat;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toFloat(str) {
          (0, _assertString2.default)(str);
          return parseFloat(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    208: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toInt;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toInt(str, radix) {
          (0, _assertString2.default)(str);
          return parseInt(str, radix || 10);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    209: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = trim;
        var _rtrim = require('./rtrim');
        var _rtrim2 = _interopRequireDefault(_rtrim);
        var _ltrim = require('./ltrim');
        var _ltrim2 = _interopRequireDefault(_ltrim);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function trim(str, chars) {
          return (0, _rtrim2.default)((0, _ltrim2.default)(str, chars), chars);
        }
        module.exports = exports['default'];
      },
      {
        './ltrim': 200,
        './rtrim': 203
      }
    ],
    210: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = unescape;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function unescape(str) {
          (0, _assertString2.default)(str);
          return str.replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#x27;/g, '\'').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#96;/g, '`');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    211: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = assertString;
        function assertString(input) {
          if (typeof input !== 'string') {
            throw new TypeError('This library (validator.js) validates strings only');
          }
        }
        module.exports = exports['default'];
      },
      {}
    ],
    212: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = merge;
        function merge() {
          var obj = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
          var defaults = arguments[1];
          for (var key in defaults) {
            if (typeof obj[key] === 'undefined') {
              obj[key] = defaults[key];
            }
          }
          return obj;
        }
        module.exports = exports['default'];
      },
      {}
    ],
    213: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol ? 'symbol' : typeof obj;
          };
        exports.default = toString;
        function toString(input) {
          if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input !== null) {
            if (typeof input.toString === 'function') {
              input = input.toString();
            } else {
              input = '[object Object]';
            }
          } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
            input = '';
          }
          return String(input);
        }
        module.exports = exports['default'];
      },
      {}
    ],
    214: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = whitelist;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function whitelist(str, chars) {
          (0, _assertString2.default)(str);
          return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 211 }
    ],
    215: [
      function (require, module, exports) {
        module.exports = extend;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function extend() {
          var target = {};
          for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }
      },
      {}
    ],
    216: [
      function (require, module, exports) {
        'use strict';
        module.exports = {
          INVALID_TYPE: 'Expected type {0} but found type {1}',
          INVALID_FORMAT: 'Object didn\'t pass validation for format {0}: {1}',
          ENUM_MISMATCH: 'No enum match for: {0}',
          ANY_OF_MISSING: 'Data does not match any schemas from \'anyOf\'',
          ONE_OF_MISSING: 'Data does not match any schemas from \'oneOf\'',
          ONE_OF_MULTIPLE: 'Data is valid against more than one schema from \'oneOf\'',
          NOT_PASSED: 'Data matches schema from \'not\'',
          ARRAY_LENGTH_SHORT: 'Array is too short ({0}), minimum {1}',
          ARRAY_LENGTH_LONG: 'Array is too long ({0}), maximum {1}',
          ARRAY_UNIQUE: 'Array items are not unique (indexes {0} and {1})',
          ARRAY_ADDITIONAL_ITEMS: 'Additional items not allowed',
          MULTIPLE_OF: 'Value {0} is not a multiple of {1}',
          MINIMUM: 'Value {0} is less than minimum {1}',
          MINIMUM_EXCLUSIVE: 'Value {0} is equal or less than exclusive minimum {1}',
          MAXIMUM: 'Value {0} is greater than maximum {1}',
          MAXIMUM_EXCLUSIVE: 'Value {0} is equal or greater than exclusive maximum {1}',
          OBJECT_PROPERTIES_MINIMUM: 'Too few properties defined ({0}), minimum {1}',
          OBJECT_PROPERTIES_MAXIMUM: 'Too many properties defined ({0}), maximum {1}',
          OBJECT_MISSING_REQUIRED_PROPERTY: 'Missing required property: {0}',
          OBJECT_ADDITIONAL_PROPERTIES: 'Additional properties not allowed: {0}',
          OBJECT_DEPENDENCY_KEY: 'Dependency failed - key must exist: {0} (due to key: {1})',
          MIN_LENGTH: 'String is too short ({0} chars), minimum {1}',
          MAX_LENGTH: 'String is too long ({0} chars), maximum {1}',
          PATTERN: 'String does not match pattern {0}: {1}',
          KEYWORD_TYPE_EXPECTED: 'Keyword \'{0}\' is expected to be of type \'{1}\'',
          KEYWORD_UNDEFINED_STRICT: 'Keyword \'{0}\' must be defined in strict mode',
          KEYWORD_UNEXPECTED: 'Keyword \'{0}\' is not expected to appear in the schema',
          KEYWORD_MUST_BE: 'Keyword \'{0}\' must be {1}',
          KEYWORD_DEPENDENCY: 'Keyword \'{0}\' requires keyword \'{1}\'',
          KEYWORD_PATTERN: 'Keyword \'{0}\' is not a valid RegExp pattern: {1}',
          KEYWORD_VALUE_TYPE: 'Each element of keyword \'{0}\' array must be a \'{1}\'',
          UNKNOWN_FORMAT: 'There is no validation function for format \'{0}\'',
          CUSTOM_MODE_FORCE_PROPERTIES: '{0} must define at least one property if present',
          REF_UNRESOLVED: 'Reference has not been resolved during compilation: {0}',
          UNRESOLVABLE_REFERENCE: 'Reference could not be resolved: {0}',
          SCHEMA_NOT_REACHABLE: 'Validator was not able to read schema with uri: {0}',
          SCHEMA_TYPE_EXPECTED: 'Schema is expected to be of type \'object\'',
          SCHEMA_NOT_AN_OBJECT: 'Schema is not an object: {0}',
          ASYNC_TIMEOUT: '{0} asynchronous task(s) have timed out after {1} ms',
          PARENT_SCHEMA_VALIDATION_FAILED: 'Schema failed to validate against its parent schema, see inner errors for details.',
          REMOTE_NOT_VALID: 'Remote reference didn\'t compile successfully: {0}'
        };
      },
      {}
    ],
    217: [
      function (require, module, exports) {
        /*jshint maxlen: false*/
        var validator = require('validator');
        var FormatValidators = {
            'date': function (date) {
              if (typeof date !== 'string') {
                return true;
              }
              // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
              var matches = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(date);
              if (matches === null) {
                return false;
              }
              // var year = matches[1];
              // var month = matches[2];
              // var day = matches[3];
              if (matches[2] < '01' || matches[2] > '12' || matches[3] < '01' || matches[3] > '31') {
                return false;
              }
              return true;
            },
            'date-time': function (dateTime) {
              if (typeof dateTime !== 'string') {
                return true;
              }
              // date-time from http://tools.ietf.org/html/rfc3339#section-5.6
              var s = dateTime.toLowerCase().split('t');
              if (!FormatValidators.date(s[0])) {
                return false;
              }
              var matches = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(s[1]);
              if (matches === null) {
                return false;
              }
              // var hour = matches[1];
              // var minute = matches[2];
              // var second = matches[3];
              // var fraction = matches[4];
              // var timezone = matches[5];
              if (matches[1] > '23' || matches[2] > '59' || matches[3] > '59') {
                return false;
              }
              return true;
            },
            'email': function (email) {
              if (typeof email !== 'string') {
                return true;
              }
              return validator.isEmail(email, { 'require_tld': true });
            },
            'hostname': function (hostname) {
              if (typeof hostname !== 'string') {
                return true;
              }
              /*
            http://json-schema.org/latest/json-schema-validation.html#anchor114
            A string instance is valid against this attribute if it is a valid
            representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034].

            http://tools.ietf.org/html/rfc1034#section-3.5

            <digit> ::= any one of the ten digits 0 through 9
            var digit = /[0-9]/;

            <letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case
            var letter = /[a-zA-Z]/;

            <let-dig> ::= <letter> | <digit>
            var letDig = /[0-9a-zA-Z]/;

            <let-dig-hyp> ::= <let-dig> | "-"
            var letDigHyp = /[-0-9a-zA-Z]/;

            <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
            var ldhStr = /[-0-9a-zA-Z]+/;

            <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]
            var label = /[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?/;

            <subdomain> ::= <label> | <subdomain> "." <label>
            var subdomain = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/;

            <domain> ::= <subdomain> | " "
            var domain = null;
        */
              var valid = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(hostname);
              if (valid) {
                // the sum of all label octets and label lengths is limited to 255.
                if (hostname.length > 255) {
                  return false;
                }
                // Each node has a label, which is zero to 63 octets in length
                var labels = hostname.split('.');
                for (var i = 0; i < labels.length; i++) {
                  if (labels[i].length > 63) {
                    return false;
                  }
                }
              }
              return valid;
            },
            'host-name': function (hostname) {
              return FormatValidators.hostname.call(this, hostname);
            },
            'ipv4': function (ipv4) {
              if (typeof ipv4 !== 'string') {
                return true;
              }
              return validator.isIP(ipv4, 4);
            },
            'ipv6': function (ipv6) {
              if (typeof ipv6 !== 'string') {
                return true;
              }
              return validator.isIP(ipv6, 6);
            },
            'regex': function (str) {
              try {
                RegExp(str);
                return true;
              } catch (e) {
                return false;
              }
            },
            'uri': function (uri) {
              if (this.options.strictUris) {
                return FormatValidators['strict-uri'].apply(this, arguments);
              }
              // https://github.com/zaggino/z-schema/issues/18
              // RegExp from http://tools.ietf.org/html/rfc3986#appendix-B
              return typeof uri !== 'string' || RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?').test(uri);
            },
            'strict-uri': function (uri) {
              return typeof uri !== 'string' || validator.isURL(uri);
            }
          };
        module.exports = FormatValidators;
      },
      { 'validator': 151 }
    ],
    218: [
      function (require, module, exports) {
        'use strict';
        var FormatValidators = require('./FormatValidators'), Report = require('./Report'), Utils = require('./Utils');
        var JsonValidators = {
            multipleOf: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.2
              if (typeof json !== 'number') {
                return;
              }
              if (Utils.whatIs(json / schema.multipleOf) !== 'integer') {
                report.addError('MULTIPLE_OF', [
                  json,
                  schema.multipleOf
                ], null, schema.description);
              }
            },
            maximum: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.2
              if (typeof json !== 'number') {
                return;
              }
              if (schema.exclusiveMaximum !== true) {
                if (json > schema.maximum) {
                  report.addError('MAXIMUM', [
                    json,
                    schema.maximum
                  ], null, schema.description);
                }
              } else {
                if (json >= schema.maximum) {
                  report.addError('MAXIMUM_EXCLUSIVE', [
                    json,
                    schema.maximum
                  ], null, schema.description);
                }
              }
            },
            exclusiveMaximum: function () {
            },
            minimum: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.2
              if (typeof json !== 'number') {
                return;
              }
              if (schema.exclusiveMinimum !== true) {
                if (json < schema.minimum) {
                  report.addError('MINIMUM', [
                    json,
                    schema.minimum
                  ], null, schema.description);
                }
              } else {
                if (json <= schema.minimum) {
                  report.addError('MINIMUM_EXCLUSIVE', [
                    json,
                    schema.minimum
                  ], null, schema.description);
                }
              }
            },
            exclusiveMinimum: function () {
            },
            maxLength: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.2
              if (typeof json !== 'string') {
                return;
              }
              if (Utils.ucs2decode(json).length > schema.maxLength) {
                report.addError('MAX_LENGTH', [
                  json.length,
                  schema.maxLength
                ], null, schema.description);
              }
            },
            minLength: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.2
              if (typeof json !== 'string') {
                return;
              }
              if (Utils.ucs2decode(json).length < schema.minLength) {
                report.addError('MIN_LENGTH', [
                  json.length,
                  schema.minLength
                ], null, schema.description);
              }
            },
            pattern: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.2
              if (typeof json !== 'string') {
                return;
              }
              if (RegExp(schema.pattern).test(json) === false) {
                report.addError('PATTERN', [
                  schema.pattern,
                  json
                ], null, schema.description);
              }
            },
            additionalItems: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.2
              if (!Array.isArray(json)) {
                return;
              }
              // if the value of "additionalItems" is boolean value false and the value of "items" is an array,
              // the json is valid if its size is less than, or equal to, the size of "items".
              if (schema.additionalItems === false && Array.isArray(schema.items)) {
                if (json.length > schema.items.length) {
                  report.addError('ARRAY_ADDITIONAL_ITEMS', null, null, schema.description);
                }
              }
            },
            items: function () {
            },
            maxItems: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.2
              if (!Array.isArray(json)) {
                return;
              }
              if (json.length > schema.maxItems) {
                report.addError('ARRAY_LENGTH_LONG', [
                  json.length,
                  schema.maxItems
                ], null, schema.description);
              }
            },
            minItems: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.2
              if (!Array.isArray(json)) {
                return;
              }
              if (json.length < schema.minItems) {
                report.addError('ARRAY_LENGTH_SHORT', [
                  json.length,
                  schema.minItems
                ], null, schema.description);
              }
            },
            uniqueItems: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.2
              if (!Array.isArray(json)) {
                return;
              }
              if (schema.uniqueItems === true) {
                var matches = [];
                if (Utils.isUniqueArray(json, matches) === false) {
                  report.addError('ARRAY_UNIQUE', matches, null, schema.description);
                }
              }
            },
            maxProperties: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var keysCount = Object.keys(json).length;
              if (keysCount > schema.maxProperties) {
                report.addError('OBJECT_PROPERTIES_MAXIMUM', [
                  keysCount,
                  schema.maxProperties
                ], null, schema.description);
              }
            },
            minProperties: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var keysCount = Object.keys(json).length;
              if (keysCount < schema.minProperties) {
                report.addError('OBJECT_PROPERTIES_MINIMUM', [
                  keysCount,
                  schema.minProperties
                ], null, schema.description);
              }
            },
            required: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var idx = schema.required.length;
              while (idx--) {
                var requiredPropertyName = schema.required[idx];
                if (json[requiredPropertyName] === undefined) {
                  report.addError('OBJECT_MISSING_REQUIRED_PROPERTY', [requiredPropertyName], null, schema.description);
                }
              }
            },
            additionalProperties: function (report, schema, json) {
              // covered in properties and patternProperties
              if (schema.properties === undefined && schema.patternProperties === undefined) {
                return JsonValidators.properties.call(this, report, schema, json);
              }
            },
            patternProperties: function (report, schema, json) {
              // covered in properties
              if (schema.properties === undefined) {
                return JsonValidators.properties.call(this, report, schema, json);
              }
            },
            properties: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var properties = schema.properties !== undefined ? schema.properties : {};
              var patternProperties = schema.patternProperties !== undefined ? schema.patternProperties : {};
              if (schema.additionalProperties === false) {
                // The property set of the json to validate.
                var s = Object.keys(json);
                // The property set from "properties".
                var p = Object.keys(properties);
                // The property set from "patternProperties".
                var pp = Object.keys(patternProperties);
                // remove from "s" all elements of "p", if any;
                s = Utils.difference(s, p);
                // for each regex in "pp", remove all elements of "s" which this regex matches.
                var idx = pp.length;
                while (idx--) {
                  var regExp = RegExp(pp[idx]), idx2 = s.length;
                  while (idx2--) {
                    if (regExp.test(s[idx2]) === true) {
                      s.splice(idx2, 1);
                    }
                  }
                }
                // Validation of the json succeeds if, after these two steps, set "s" is empty.
                if (s.length > 0) {
                  // assumeAdditional can be an array of allowed properties
                  var idx3 = this.options.assumeAdditional.length;
                  if (idx3) {
                    while (idx3--) {
                      var io = s.indexOf(this.options.assumeAdditional[idx3]);
                      if (io !== -1) {
                        s.splice(io, 1);
                      }
                    }
                  }
                  if (s.length > 0) {
                    report.addError('OBJECT_ADDITIONAL_PROPERTIES', [s], null, schema.description);
                  }
                }
              }
            },
            dependencies: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var keys = Object.keys(schema.dependencies), idx = keys.length;
              while (idx--) {
                // iterate all dependencies
                var dependencyName = keys[idx];
                if (json[dependencyName]) {
                  var dependencyDefinition = schema.dependencies[dependencyName];
                  if (Utils.whatIs(dependencyDefinition) === 'object') {
                    // if dependency is a schema, validate against this schema
                    exports.validate.call(this, report, dependencyDefinition, json);
                  } else {
                    // Array
                    // if dependency is an array, object needs to have all properties in this array
                    var idx2 = dependencyDefinition.length;
                    while (idx2--) {
                      var requiredPropertyName = dependencyDefinition[idx2];
                      if (json[requiredPropertyName] === undefined) {
                        report.addError('OBJECT_DEPENDENCY_KEY', [
                          requiredPropertyName,
                          dependencyName
                        ], null, schema.description);
                      }
                    }
                  }
                }
              }
            },
            enum: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.2
              var match = false, idx = schema.enum.length;
              while (idx--) {
                if (Utils.areEqual(json, schema.enum[idx])) {
                  match = true;
                  break;
                }
              }
              if (match === false) {
                report.addError('ENUM_MISMATCH', [json], null, schema.description);
              }
            },
            allOf: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.2
              var idx = schema.allOf.length;
              while (idx--) {
                var validateResult = exports.validate.call(this, report, schema.allOf[idx], json);
                if (this.options.breakOnFirstError && validateResult === false) {
                  break;
                }
              }
            },
            anyOf: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.2
              var subReports = [], passed = false, idx = schema.anyOf.length;
              while (idx-- && passed === false) {
                var subReport = new Report(report);
                subReports.push(subReport);
                passed = exports.validate.call(this, subReport, schema.anyOf[idx], json);
              }
              if (passed === false) {
                report.addError('ANY_OF_MISSING', undefined, subReports, schema.description);
              }
            },
            oneOf: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.2
              var passes = 0, subReports = [], idx = schema.oneOf.length;
              while (idx--) {
                var subReport = new Report(report, { maxErrors: 1 });
                subReports.push(subReport);
                if (exports.validate.call(this, subReport, schema.oneOf[idx], json) === true) {
                  passes++;
                }
              }
              if (passes === 0) {
                report.addError('ONE_OF_MISSING', undefined, subReports, schema.description);
              } else if (passes > 1) {
                report.addError('ONE_OF_MULTIPLE', null, null, schema.description);
              }
            },
            not: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.2
              var subReport = new Report(report);
              if (exports.validate.call(this, subReport, schema.not, json) === true) {
                report.addError('NOT_PASSED', null, null, schema.description);
              }
            },
            definitions: function () {
            },
            format: function (report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.7.2
              var formatValidatorFn = FormatValidators[schema.format];
              if (typeof formatValidatorFn === 'function') {
                if (formatValidatorFn.length === 2) {
                  // async
                  report.addAsyncTask(formatValidatorFn, [json], function (result) {
                    if (result !== true) {
                      report.addError('INVALID_FORMAT', [
                        schema.format,
                        json
                      ], null, schema.description);
                    }
                  });
                } else {
                  // sync
                  if (formatValidatorFn.call(this, json) !== true) {
                    report.addError('INVALID_FORMAT', [
                      schema.format,
                      json
                    ], null, schema.description);
                  }
                }
              } else if (this.options.ignoreUnknownFormats !== true) {
                report.addError('UNKNOWN_FORMAT', [schema.format], null, schema.description);
              }
            }
          };
        var recurseArray = function (report, schema, json) {
          // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.2
          var idx = json.length;
          // If "items" is an array, this situation, the schema depends on the index:
          // if the index is less than, or equal to, the size of "items",
          // the child instance must be valid against the corresponding schema in the "items" array;
          // otherwise, it must be valid against the schema defined by "additionalItems".
          if (Array.isArray(schema.items)) {
            while (idx--) {
              // equal to doesnt make sense here
              if (idx < schema.items.length) {
                report.path.push(idx.toString());
                exports.validate.call(this, report, schema.items[idx], json[idx]);
                report.path.pop();
              } else {
                // might be boolean, so check that it's an object
                if (typeof schema.additionalItems === 'object') {
                  report.path.push(idx.toString());
                  exports.validate.call(this, report, schema.additionalItems, json[idx]);
                  report.path.pop();
                }
              }
            }
          } else if (typeof schema.items === 'object') {
            // If items is a schema, then the child instance must be valid against this schema,
            // regardless of its index, and regardless of the value of "additionalItems".
            while (idx--) {
              report.path.push(idx.toString());
              exports.validate.call(this, report, schema.items, json[idx]);
              report.path.pop();
            }
          }
        };
        var recurseObject = function (report, schema, json) {
          // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3
          // If "additionalProperties" is absent, it is considered present with an empty schema as a value.
          // In addition, boolean value true is considered equivalent to an empty schema.
          var additionalProperties = schema.additionalProperties;
          if (additionalProperties === true || additionalProperties === undefined) {
            additionalProperties = {};
          }
          // p - The property set from "properties".
          var p = schema.properties ? Object.keys(schema.properties) : [];
          // pp - The property set from "patternProperties". Elements of this set will be called regexes for convenience.
          var pp = schema.patternProperties ? Object.keys(schema.patternProperties) : [];
          // m - The property name of the child.
          var keys = Object.keys(json), idx = keys.length;
          while (idx--) {
            var m = keys[idx], propertyValue = json[m];
            // s - The set of schemas for the child instance.
            var s = [];
            // 1. If set "p" contains value "m", then the corresponding schema in "properties" is added to "s".
            if (p.indexOf(m) !== -1) {
              s.push(schema.properties[m]);
            }
            // 2. For each regex in "pp", if it matches "m" successfully, the corresponding schema in "patternProperties" is added to "s".
            var idx2 = pp.length;
            while (idx2--) {
              var regexString = pp[idx2];
              if (RegExp(regexString).test(m) === true) {
                s.push(schema.patternProperties[regexString]);
              }
            }
            // 3. The schema defined by "additionalProperties" is added to "s" if and only if, at this stage, "s" is empty.
            if (s.length === 0 && additionalProperties !== false) {
              s.push(additionalProperties);
            }
            // we are passing tests even without this assert because this is covered by properties check
            // if s is empty in this stage, no additionalProperties are allowed
            // report.expect(s.length !== 0, 'E001', m);
            // Instance property value must pass all schemas from s
            idx2 = s.length;
            while (idx2--) {
              report.path.push(m);
              exports.validate.call(this, report, s[idx2], propertyValue);
              report.path.pop();
            }
          }
        };
        exports.validate = function (report, schema, json) {
          report.commonErrorMessage = 'JSON_OBJECT_VALIDATION_FAILED';
          // check if schema is an object
          var to = Utils.whatIs(schema);
          if (to !== 'object') {
            report.addError('SCHEMA_NOT_AN_OBJECT', [to], null, schema.description);
            return false;
          }
          // check if schema is empty, everything is valid against empty schema
          var keys = Object.keys(schema);
          if (keys.length === 0) {
            return true;
          }
          // this method can be called recursively, so we need to remember our root
          var isRoot = false;
          if (!report.rootSchema) {
            report.rootSchema = schema;
            isRoot = true;
          }
          // follow schema.$ref keys
          if (schema.$ref !== undefined) {
            // avoid infinite loop with maxRefs
            var maxRefs = 99;
            while (schema.$ref && maxRefs > 0) {
              if (!schema.__$refResolved) {
                report.addError('REF_UNRESOLVED', [schema.$ref], null, schema.description);
                break;
              } else if (schema.__$refResolved === schema) {
                break;
              } else {
                schema = schema.__$refResolved;
                keys = Object.keys(schema);
              }
              maxRefs--;
            }
            if (maxRefs === 0) {
              throw new Error('Circular dependency by $ref references!');
            }
          }
          // type checking first
          // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
          var jsonType = Utils.whatIs(json);
          if (schema.type) {
            if (typeof schema.type === 'string') {
              if (jsonType !== schema.type && (jsonType !== 'integer' || schema.type !== 'number')) {
                report.addError('INVALID_TYPE', [
                  schema.type,
                  jsonType
                ], null, schema.description);
                if (this.options.breakOnFirstError) {
                  return false;
                }
              }
            } else {
              if (schema.type.indexOf(jsonType) === -1 && (jsonType !== 'integer' || schema.type.indexOf('number') === -1)) {
                report.addError('INVALID_TYPE', [
                  schema.type,
                  jsonType
                ], null, schema.description);
                if (this.options.breakOnFirstError) {
                  return false;
                }
              }
            }
          }
          // now iterate all the keys in schema and execute validation methods
          var idx = keys.length;
          while (idx--) {
            if (JsonValidators[keys[idx]]) {
              JsonValidators[keys[idx]].call(this, report, schema, json);
              if (report.errors.length && this.options.breakOnFirstError) {
                break;
              }
            }
          }
          if (report.errors.length === 0 || this.options.breakOnFirstError === false) {
            if (jsonType === 'array') {
              recurseArray.call(this, report, schema, json);
            } else if (jsonType === 'object') {
              recurseObject.call(this, report, schema, json);
            }
          }
          if (typeof this.options.customValidator === 'function') {
            this.options.customValidator(report, schema, json);
          }
          // we don't need the root pointer anymore
          if (isRoot) {
            report.rootSchema = undefined;
          }
          // return valid just to be able to break at some code points
          return report.errors.length === 0;
        };
      },
      {
        './FormatValidators': 217,
        './Report': 220,
        './Utils': 224
      }
    ],
    219: [
      function (require, module, exports) {
        // Number.isFinite polyfill
        // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite
        if (typeof Number.isFinite !== 'function') {
          Number.isFinite = function isFinite(value) {
            // 1. If Type(number) is not Number, return false.
            if (typeof value !== 'number') {
              return false;
            }
            // 2. If number is NaN, +, or , return false.
            if (value !== value || value === Infinity || value === -Infinity) {
              return false;
            }
            // 3. Otherwise, return true.
            return true;
          };
        }
      },
      {}
    ],
    220: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          var get = require('lodash.get');
          var Errors = require('./Errors');
          var Utils = require('./Utils');
          function Report(parentOrOptions, reportOptions) {
            this.parentReport = parentOrOptions instanceof Report ? parentOrOptions : undefined;
            this.options = parentOrOptions instanceof Report ? parentOrOptions.options : parentOrOptions || {};
            this.reportOptions = reportOptions || {};
            this.errors = [];
            this.path = [];
            this.asyncTasks = [];
          }
          Report.prototype.isValid = function () {
            if (this.asyncTasks.length > 0) {
              throw new Error('Async tasks pending, can\'t answer isValid');
            }
            return this.errors.length === 0;
          };
          Report.prototype.addAsyncTask = function (fn, args, asyncTaskResultProcessFn) {
            this.asyncTasks.push([
              fn,
              args,
              asyncTaskResultProcessFn
            ]);
          };
          Report.prototype.processAsyncTasks = function (timeout, callback) {
            var validationTimeout = timeout || 2000, tasksCount = this.asyncTasks.length, idx = tasksCount, timedOut = false, self = this;
            function finish() {
              process.nextTick(function () {
                var valid = self.errors.length === 0, err = valid ? undefined : self.errors;
                callback(err, valid);
              });
            }
            function respond(asyncTaskResultProcessFn) {
              return function (asyncTaskResult) {
                if (timedOut) {
                  return;
                }
                asyncTaskResultProcessFn(asyncTaskResult);
                if (--tasksCount === 0) {
                  finish();
                }
              };
            }
            if (tasksCount === 0 || this.errors.length > 0) {
              finish();
              return;
            }
            while (idx--) {
              var task = this.asyncTasks[idx];
              task[0].apply(null, task[1].concat(respond(task[2])));
            }
            setTimeout(function () {
              if (tasksCount > 0) {
                timedOut = true;
                self.addError('ASYNC_TIMEOUT', [
                  tasksCount,
                  validationTimeout
                ]);
                callback(self.errors, false);
              }
            }, validationTimeout);
          };
          Report.prototype.getPath = function (returnPathAsString) {
            var path = [];
            if (this.parentReport) {
              path = path.concat(this.parentReport.path);
            }
            path = path.concat(this.path);
            if (returnPathAsString !== true) {
              // Sanitize the path segments (http://tools.ietf.org/html/rfc6901#section-4)
              path = '#/' + path.map(function (segment) {
                if (Utils.isAbsoluteUri(segment)) {
                  return 'uri(' + segment + ')';
                }
                return segment.replace(/\~/g, '~0').replace(/\//g, '~1');
              }).join('/');
            }
            return path;
          };
          Report.prototype.getSchemaId = function () {
            if (!this.rootSchema) {
              return null;
            }
            // get the error path as an array
            var path = [];
            if (this.parentReport) {
              path = path.concat(this.parentReport.path);
            }
            path = path.concat(this.path);
            // try to find id in the error path
            while (path.length > 0) {
              var obj = get(this.rootSchema, path);
              if (obj && obj.id) {
                return obj.id;
              }
              path.pop();
            }
            // return id of the root
            return this.rootSchema.id;
          };
          Report.prototype.hasError = function (errorCode, params) {
            var idx = this.errors.length;
            while (idx--) {
              if (this.errors[idx].code === errorCode) {
                // assume match
                var match = true;
                // check the params too
                var idx2 = this.errors[idx].params.length;
                while (idx2--) {
                  if (this.errors[idx].params[idx2] !== params[idx2]) {
                    match = false;
                  }
                }
                // if match, return true
                if (match) {
                  return match;
                }
              }
            }
            return false;
          };
          Report.prototype.addError = function (errorCode, params, subReports, schemaDescription) {
            if (!errorCode) {
              throw new Error('No errorCode passed into addError()');
            }
            this.addCustomError(errorCode, Errors[errorCode], params, subReports, schemaDescription);
          };
          Report.prototype.addCustomError = function (errorCode, errorMessage, params, subReports, schemaDescription) {
            if (this.errors.length >= this.reportOptions.maxErrors) {
              return;
            }
            if (!errorMessage) {
              throw new Error('No errorMessage known for code ' + errorCode);
            }
            params = params || [];
            var idx = params.length;
            while (idx--) {
              var whatIs = Utils.whatIs(params[idx]);
              var param = whatIs === 'object' || whatIs === 'null' ? JSON.stringify(params[idx]) : params[idx];
              errorMessage = errorMessage.replace('{' + idx + '}', param);
            }
            var err = {
                code: errorCode,
                params: params,
                message: errorMessage,
                path: this.getPath(this.options.reportPathAsArray),
                schemaId: this.getSchemaId()
              };
            if (schemaDescription) {
              err.description = schemaDescription;
            }
            if (subReports != null) {
              if (!Array.isArray(subReports)) {
                subReports = [subReports];
              }
              err.inner = [];
              idx = subReports.length;
              while (idx--) {
                var subReport = subReports[idx], idx2 = subReport.errors.length;
                while (idx2--) {
                  err.inner.push(subReport.errors[idx2]);
                }
              }
              if (err.inner.length === 0) {
                err.inner = undefined;
              }
            }
            this.errors.push(err);
          };
          module.exports = Report;
        }.call(this, require('_process')));
      },
      {
        './Errors': 216,
        './Utils': 224,
        '_process': 115,
        'lodash.get': 108
      }
    ],
    221: [
      function (require, module, exports) {
        'use strict';
        var Report = require('./Report');
        var SchemaCompilation = require('./SchemaCompilation');
        var SchemaValidation = require('./SchemaValidation');
        var Utils = require('./Utils');
        function decodeJSONPointer(str) {
          // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3
          return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {
            return x === '~1' ? '/' : '~';
          });
        }
        function getRemotePath(uri) {
          var io = uri.indexOf('#');
          return io === -1 ? uri : uri.slice(0, io);
        }
        function getQueryPath(uri) {
          var io = uri.indexOf('#');
          var res = io === -1 ? undefined : uri.slice(io + 1);
          // WARN: do not slice slash, #/ means take root and go down from it
          // if (res && res[0] === "/") { res = res.slice(1); }
          return res;
        }
        function findId(schema, id) {
          // process only arrays and objects
          if (typeof schema !== 'object' || schema === null) {
            return;
          }
          // no id means root so return itself
          if (!id) {
            return schema;
          }
          if (schema.id) {
            if (schema.id === id || schema.id[0] === '#' && schema.id.substring(1) === id) {
              return schema;
            }
          }
          var idx, result;
          if (Array.isArray(schema)) {
            idx = schema.length;
            while (idx--) {
              result = findId(schema[idx], id);
              if (result) {
                return result;
              }
            }
          } else {
            var keys = Object.keys(schema);
            idx = keys.length;
            while (idx--) {
              var k = keys[idx];
              if (k.indexOf('__$') === 0) {
                continue;
              }
              result = findId(schema[k], id);
              if (result) {
                return result;
              }
            }
          }
        }
        exports.cacheSchemaByUri = function (uri, schema) {
          var remotePath = getRemotePath(uri);
          if (remotePath) {
            this.cache[remotePath] = schema;
          }
        };
        exports.removeFromCacheByUri = function (uri) {
          var remotePath = getRemotePath(uri);
          if (remotePath) {
            delete this.cache[remotePath];
          }
        };
        exports.checkCacheForUri = function (uri) {
          var remotePath = getRemotePath(uri);
          return remotePath ? this.cache[remotePath] != null : false;
        };
        exports.getSchema = function (report, schema) {
          if (typeof schema === 'object') {
            schema = exports.getSchemaByReference.call(this, report, schema);
          }
          if (typeof schema === 'string') {
            schema = exports.getSchemaByUri.call(this, report, schema);
          }
          return schema;
        };
        exports.getSchemaByReference = function (report, key) {
          var i = this.referenceCache.length;
          while (i--) {
            if (this.referenceCache[i][0] === key) {
              return this.referenceCache[i][1];
            }
          }
          // not found
          var schema = Utils.cloneDeep(key);
          this.referenceCache.push([
            key,
            schema
          ]);
          return schema;
        };
        exports.getSchemaByUri = function (report, uri, root) {
          var remotePath = getRemotePath(uri), queryPath = getQueryPath(uri), result = remotePath ? this.cache[remotePath] : root;
          if (result && remotePath) {
            // we need to avoid compiling schemas in a recursive loop
            var compileRemote = result !== root;
            // now we need to compile and validate resolved schema (in case it's not already)
            if (compileRemote) {
              report.path.push(remotePath);
              var remoteReport = new Report(report);
              if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {
                SchemaValidation.validateSchema.call(this, remoteReport, result);
              }
              var remoteReportIsValid = remoteReport.isValid();
              if (!remoteReportIsValid) {
                report.addError('REMOTE_NOT_VALID', [uri], remoteReport);
              }
              report.path.pop();
              if (!remoteReportIsValid) {
                return undefined;
              }
            }
          }
          if (result && queryPath) {
            var parts = queryPath.split('/');
            for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {
              var key = decodeJSONPointer(parts[idx]);
              if (idx === 0) {
                // it's an id
                result = findId(result, key);
              } else {
                // it's a path behind id
                result = result[key];
              }
            }
          }
          return result;
        };
        exports.getRemotePath = getRemotePath;
      },
      {
        './Report': 220,
        './SchemaCompilation': 222,
        './SchemaValidation': 223,
        './Utils': 224
      }
    ],
    222: [
      function (require, module, exports) {
        'use strict';
        var Report = require('./Report');
        var SchemaCache = require('./SchemaCache');
        var Utils = require('./Utils');
        function mergeReference(scope, ref) {
          if (Utils.isAbsoluteUri(ref)) {
            return ref;
          }
          var joinedScope = scope.join(''), isScopeAbsolute = Utils.isAbsoluteUri(joinedScope), isScopeRelative = Utils.isRelativeUri(joinedScope), isRefRelative = Utils.isRelativeUri(ref), toRemove;
          if (isScopeAbsolute && isRefRelative) {
            toRemove = joinedScope.match(/\/[^\/]*$/);
            if (toRemove) {
              joinedScope = joinedScope.slice(0, toRemove.index + 1);
            }
          } else if (isScopeRelative && isRefRelative) {
            joinedScope = '';
          } else {
            toRemove = joinedScope.match(/[^#\/]+$/);
            if (toRemove) {
              joinedScope = joinedScope.slice(0, toRemove.index);
            }
          }
          var res = joinedScope + ref;
          res = res.replace(/##/, '#');
          return res;
        }
        function collectReferences(obj, results, scope, path) {
          results = results || [];
          scope = scope || [];
          path = path || [];
          if (typeof obj !== 'object' || obj === null) {
            return results;
          }
          if (typeof obj.id === 'string') {
            scope.push(obj.id);
          }
          if (typeof obj.$ref === 'string' && typeof obj.__$refResolved === 'undefined') {
            results.push({
              ref: mergeReference(scope, obj.$ref),
              key: '$ref',
              obj: obj,
              path: path.slice(0)
            });
          }
          if (typeof obj.$schema === 'string' && typeof obj.__$schemaResolved === 'undefined') {
            results.push({
              ref: mergeReference(scope, obj.$schema),
              key: '$schema',
              obj: obj,
              path: path.slice(0)
            });
          }
          var idx;
          if (Array.isArray(obj)) {
            idx = obj.length;
            while (idx--) {
              path.push(idx.toString());
              collectReferences(obj[idx], results, scope, path);
              path.pop();
            }
          } else {
            var keys = Object.keys(obj);
            idx = keys.length;
            while (idx--) {
              // do not recurse through resolved references and other z-schema props
              if (keys[idx].indexOf('__$') === 0) {
                continue;
              }
              path.push(keys[idx]);
              collectReferences(obj[keys[idx]], results, scope, path);
              path.pop();
            }
          }
          if (typeof obj.id === 'string') {
            scope.pop();
          }
          return results;
        }
        var compileArrayOfSchemasLoop = function (mainReport, arr) {
          var idx = arr.length, compiledCount = 0;
          while (idx--) {
            // try to compile each schema separately
            var report = new Report(mainReport);
            var isValid = exports.compileSchema.call(this, report, arr[idx]);
            if (isValid) {
              compiledCount++;
            }
            // copy errors to report
            mainReport.errors = mainReport.errors.concat(report.errors);
          }
          return compiledCount;
        };
        function findId(arr, id) {
          var idx = arr.length;
          while (idx--) {
            if (arr[idx].id === id) {
              return arr[idx];
            }
          }
          return null;
        }
        var compileArrayOfSchemas = function (report, arr) {
          var compiled = 0, lastLoopCompiled;
          do {
            // remove all UNRESOLVABLE_REFERENCE errors before compiling array again
            var idx = report.errors.length;
            while (idx--) {
              if (report.errors[idx].code === 'UNRESOLVABLE_REFERENCE') {
                report.errors.splice(idx, 1);
              }
            }
            // remember how many were compiled in the last loop
            lastLoopCompiled = compiled;
            // count how many are compiled now
            compiled = compileArrayOfSchemasLoop.call(this, report, arr);
            // fix __$missingReferences if possible
            idx = arr.length;
            while (idx--) {
              var sch = arr[idx];
              if (sch.__$missingReferences) {
                var idx2 = sch.__$missingReferences.length;
                while (idx2--) {
                  var refObj = sch.__$missingReferences[idx2];
                  var response = findId(arr, refObj.ref);
                  if (response) {
                    // this might create circular references
                    refObj.obj['__' + refObj.key + 'Resolved'] = response;
                    // it's resolved now so delete it
                    sch.__$missingReferences.splice(idx2, 1);
                  }
                }
                if (sch.__$missingReferences.length === 0) {
                  delete sch.__$missingReferences;
                }
              }
            }  // keep repeating if not all compiled and at least one more was compiled in the last loop
          } while (compiled !== arr.length && compiled !== lastLoopCompiled);
          return report.isValid();
        };
        exports.compileSchema = function (report, schema) {
          report.commonErrorMessage = 'SCHEMA_COMPILATION_FAILED';
          // if schema is a string, assume it's a uri
          if (typeof schema === 'string') {
            var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);
            if (!loadedSchema) {
              report.addError('SCHEMA_NOT_REACHABLE', [schema]);
              return false;
            }
            schema = loadedSchema;
          }
          // if schema is an array, assume it's an array of schemas
          if (Array.isArray(schema)) {
            return compileArrayOfSchemas.call(this, report, schema);
          }
          // if we have an id than it should be cached already (if this instance has compiled it)
          if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {
            schema.__$compiled = undefined;
          }
          // do not re-compile schemas
          if (schema.__$compiled) {
            return true;
          }
          if (schema.id && typeof schema.id === 'string') {
            // add this to our schemaCache (before compilation in case we have references including id)
            SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);
          }
          // this method can be called recursively, so we need to remember our root
          var isRoot = false;
          if (!report.rootSchema) {
            report.rootSchema = schema;
            isRoot = true;
          }
          // delete all __$missingReferences from previous compilation attempts
          var isValidExceptReferences = report.isValid();
          delete schema.__$missingReferences;
          // collect all references that need to be resolved - $ref and $schema
          var refs = collectReferences.call(this, schema), idx = refs.length;
          while (idx--) {
            // resolve all the collected references into __xxxResolved pointer
            var refObj = refs[idx];
            var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);
            // we can try to use custom schemaReader if available
            if (!response) {
              var schemaReader = this.getSchemaReader();
              if (schemaReader) {
                // it's supposed to return a valid schema
                var s = schemaReader(refObj.ref);
                if (s) {
                  // it needs to have the id
                  s.id = refObj.ref;
                  // try to compile the schema
                  var subreport = new Report(report);
                  if (!exports.compileSchema.call(this, subreport, s)) {
                    // copy errors to report
                    report.errors = report.errors.concat(subreport.errors);
                  } else {
                    response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);
                  }
                }
              }
            }
            if (!response) {
              var hasNotValid = report.hasError('REMOTE_NOT_VALID', [refObj.ref]);
              var isAbsolute = Utils.isAbsoluteUri(refObj.ref);
              var isDownloaded = false;
              var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;
              if (isAbsolute) {
                // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded
                // and set through setRemoteReference method
                isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);
              }
              if (hasNotValid) {
              } else if (ignoreUnresolvableRemotes && isAbsolute) {
              } else if (isDownloaded) {
              } else {
                Array.prototype.push.apply(report.path, refObj.path);
                report.addError('UNRESOLVABLE_REFERENCE', [refObj.ref]);
                report.path = report.path.slice(0, -refObj.path.length);
                // pusblish unresolved references out
                if (isValidExceptReferences) {
                  schema.__$missingReferences = schema.__$missingReferences || [];
                  schema.__$missingReferences.push(refObj);
                }
              }
            }
            // this might create circular references
            refObj.obj['__' + refObj.key + 'Resolved'] = response;
          }
          var isValid = report.isValid();
          if (isValid) {
            schema.__$compiled = true;
          } else {
            if (schema.id && typeof schema.id === 'string') {
              // remove this schema from schemaCache because it failed to compile
              SchemaCache.removeFromCacheByUri.call(this, schema.id);
            }
          }
          // we don't need the root pointer anymore
          if (isRoot) {
            report.rootSchema = undefined;
          }
          return isValid;
        };
      },
      {
        './Report': 220,
        './SchemaCache': 221,
        './Utils': 224
      }
    ],
    223: [
      function (require, module, exports) {
        'use strict';
        var FormatValidators = require('./FormatValidators'), JsonValidation = require('./JsonValidation'), Report = require('./Report'), Utils = require('./Utils');
        var SchemaValidators = {
            $ref: function (report, schema) {
              // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07
              // http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03
              if (typeof schema.$ref !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  '$ref',
                  'string'
                ]);
              }
            },
            $schema: function (report, schema) {
              // http://json-schema.org/latest/json-schema-core.html#rfc.section.6
              if (typeof schema.$schema !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  '$schema',
                  'string'
                ]);
              }
            },
            multipleOf: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.1
              if (typeof schema.multipleOf !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'multipleOf',
                  'number'
                ]);
              } else if (schema.multipleOf <= 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'multipleOf',
                  'strictly greater than 0'
                ]);
              }
            },
            maximum: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
              if (typeof schema.maximum !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maximum',
                  'number'
                ]);
              }
            },
            exclusiveMaximum: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
              if (typeof schema.exclusiveMaximum !== 'boolean') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'exclusiveMaximum',
                  'boolean'
                ]);
              } else if (schema.maximum === undefined) {
                report.addError('KEYWORD_DEPENDENCY', [
                  'exclusiveMaximum',
                  'maximum'
                ]);
              }
            },
            minimum: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
              if (typeof schema.minimum !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minimum',
                  'number'
                ]);
              }
            },
            exclusiveMinimum: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
              if (typeof schema.exclusiveMinimum !== 'boolean') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'exclusiveMinimum',
                  'boolean'
                ]);
              } else if (schema.minimum === undefined) {
                report.addError('KEYWORD_DEPENDENCY', [
                  'exclusiveMinimum',
                  'minimum'
                ]);
              }
            },
            maxLength: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.1
              if (Utils.whatIs(schema.maxLength) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maxLength',
                  'integer'
                ]);
              } else if (schema.maxLength < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'maxLength',
                  'greater than, or equal to 0'
                ]);
              }
            },
            minLength: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.1
              if (Utils.whatIs(schema.minLength) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minLength',
                  'integer'
                ]);
              } else if (schema.minLength < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'minLength',
                  'greater than, or equal to 0'
                ]);
              }
            },
            pattern: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.1
              if (typeof schema.pattern !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'pattern',
                  'string'
                ]);
              } else {
                try {
                  RegExp(schema.pattern);
                } catch (e) {
                  report.addError('KEYWORD_PATTERN', [
                    'pattern',
                    schema.pattern
                  ]);
                }
              }
            },
            additionalItems: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
              var type = Utils.whatIs(schema.additionalItems);
              if (type !== 'boolean' && type !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'additionalItems',
                  [
                    'boolean',
                    'object'
                  ]
                ]);
              } else if (type === 'object') {
                report.path.push('additionalItems');
                exports.validateSchema.call(this, report, schema.additionalItems);
                report.path.pop();
              }
            },
            items: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
              var type = Utils.whatIs(schema.items);
              if (type === 'object') {
                report.path.push('items');
                exports.validateSchema.call(this, report, schema.items);
                report.path.pop();
              } else if (type === 'array') {
                var idx = schema.items.length;
                while (idx--) {
                  report.path.push('items');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.items[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              } else {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'items',
                  [
                    'array',
                    'object'
                  ]
                ]);
              }
              // custom - strict mode
              if (this.options.forceAdditional === true && schema.additionalItems === undefined && Array.isArray(schema.items)) {
                report.addError('KEYWORD_UNDEFINED_STRICT', ['additionalItems']);
              }
              // custome - assume defined false mode
              if (this.options.assumeAdditional && schema.additionalItems === undefined && Array.isArray(schema.items)) {
                schema.additionalItems = false;
              }
            },
            maxItems: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.1
              if (typeof schema.maxItems !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maxItems',
                  'integer'
                ]);
              } else if (schema.maxItems < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'maxItems',
                  'greater than, or equal to 0'
                ]);
              }
            },
            minItems: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.1
              if (Utils.whatIs(schema.minItems) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minItems',
                  'integer'
                ]);
              } else if (schema.minItems < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'minItems',
                  'greater than, or equal to 0'
                ]);
              }
            },
            uniqueItems: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.1
              if (typeof schema.uniqueItems !== 'boolean') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'uniqueItems',
                  'boolean'
                ]);
              }
            },
            maxProperties: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.1
              if (Utils.whatIs(schema.maxProperties) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maxProperties',
                  'integer'
                ]);
              } else if (schema.maxProperties < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'maxProperties',
                  'greater than, or equal to 0'
                ]);
              }
            },
            minProperties: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.1
              if (Utils.whatIs(schema.minProperties) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minProperties',
                  'integer'
                ]);
              } else if (schema.minProperties < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'minProperties',
                  'greater than, or equal to 0'
                ]);
              }
            },
            required: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.1
              if (Utils.whatIs(schema.required) !== 'array') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'required',
                  'array'
                ]);
              } else if (schema.required.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'required',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.required.length;
                while (idx--) {
                  if (typeof schema.required[idx] !== 'string') {
                    report.addError('KEYWORD_VALUE_TYPE', [
                      'required',
                      'string'
                    ]);
                  }
                }
                if (Utils.isUniqueArray(schema.required) === false) {
                  report.addError('KEYWORD_MUST_BE', [
                    'required',
                    'an array with unique items'
                  ]);
                }
              }
            },
            additionalProperties: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
              var type = Utils.whatIs(schema.additionalProperties);
              if (type !== 'boolean' && type !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'additionalProperties',
                  [
                    'boolean',
                    'object'
                  ]
                ]);
              } else if (type === 'object') {
                report.path.push('additionalProperties');
                exports.validateSchema.call(this, report, schema.additionalProperties);
                report.path.pop();
              }
            },
            properties: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
              if (Utils.whatIs(schema.properties) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'properties',
                  'object'
                ]);
                return;
              }
              var keys = Object.keys(schema.properties), idx = keys.length;
              while (idx--) {
                var key = keys[idx], val = schema.properties[key];
                report.path.push('properties');
                report.path.push(key);
                exports.validateSchema.call(this, report, val);
                report.path.pop();
                report.path.pop();
              }
              // custom - strict mode
              if (this.options.forceAdditional === true && schema.additionalProperties === undefined) {
                report.addError('KEYWORD_UNDEFINED_STRICT', ['additionalProperties']);
              }
              // custome - assume defined false mode
              if (this.options.assumeAdditional && schema.additionalProperties === undefined) {
                schema.additionalProperties = false;
              }
              // custom - forceProperties
              if (this.options.forceProperties === true && keys.length === 0) {
                report.addError('CUSTOM_MODE_FORCE_PROPERTIES', ['properties']);
              }
            },
            patternProperties: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
              if (Utils.whatIs(schema.patternProperties) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'patternProperties',
                  'object'
                ]);
                return;
              }
              var keys = Object.keys(schema.patternProperties), idx = keys.length;
              while (idx--) {
                var key = keys[idx], val = schema.patternProperties[key];
                try {
                  RegExp(key);
                } catch (e) {
                  report.addError('KEYWORD_PATTERN', [
                    'patternProperties',
                    key
                  ]);
                }
                report.path.push('patternProperties');
                report.path.push(key.toString());
                exports.validateSchema.call(this, report, val);
                report.path.pop();
                report.path.pop();
              }
              // custom - forceProperties
              if (this.options.forceProperties === true && keys.length === 0) {
                report.addError('CUSTOM_MODE_FORCE_PROPERTIES', ['patternProperties']);
              }
            },
            dependencies: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.1
              if (Utils.whatIs(schema.dependencies) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'dependencies',
                  'object'
                ]);
              } else {
                var keys = Object.keys(schema.dependencies), idx = keys.length;
                while (idx--) {
                  var schemaKey = keys[idx], schemaDependency = schema.dependencies[schemaKey], type = Utils.whatIs(schemaDependency);
                  if (type === 'object') {
                    report.path.push('dependencies');
                    report.path.push(schemaKey);
                    exports.validateSchema.call(this, report, schemaDependency);
                    report.path.pop();
                    report.path.pop();
                  } else if (type === 'array') {
                    var idx2 = schemaDependency.length;
                    if (idx2 === 0) {
                      report.addError('KEYWORD_MUST_BE', [
                        'dependencies',
                        'not empty array'
                      ]);
                    }
                    while (idx2--) {
                      if (typeof schemaDependency[idx2] !== 'string') {
                        report.addError('KEYWORD_VALUE_TYPE', [
                          'dependensices',
                          'string'
                        ]);
                      }
                    }
                    if (Utils.isUniqueArray(schemaDependency) === false) {
                      report.addError('KEYWORD_MUST_BE', [
                        'dependencies',
                        'an array with unique items'
                      ]);
                    }
                  } else {
                    report.addError('KEYWORD_VALUE_TYPE', [
                      'dependencies',
                      'object or array'
                    ]);
                  }
                }
              }
            },
            enum: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.1
              if (Array.isArray(schema.enum) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'enum',
                  'array'
                ]);
              } else if (schema.enum.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'enum',
                  'an array with at least one element'
                ]);
              } else if (Utils.isUniqueArray(schema.enum) === false) {
                report.addError('KEYWORD_MUST_BE', [
                  'enum',
                  'an array with unique elements'
                ]);
              }
            },
            type: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.1
              var primitiveTypes = [
                  'array',
                  'boolean',
                  'integer',
                  'number',
                  'null',
                  'object',
                  'string'
                ], primitiveTypeStr = primitiveTypes.join(','), isArray = Array.isArray(schema.type);
              if (isArray) {
                var idx = schema.type.length;
                while (idx--) {
                  if (primitiveTypes.indexOf(schema.type[idx]) === -1) {
                    report.addError('KEYWORD_TYPE_EXPECTED', [
                      'type',
                      primitiveTypeStr
                    ]);
                  }
                }
                if (Utils.isUniqueArray(schema.type) === false) {
                  report.addError('KEYWORD_MUST_BE', [
                    'type',
                    'an object with unique properties'
                  ]);
                }
              } else if (typeof schema.type === 'string') {
                if (primitiveTypes.indexOf(schema.type) === -1) {
                  report.addError('KEYWORD_TYPE_EXPECTED', [
                    'type',
                    primitiveTypeStr
                  ]);
                }
              } else {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'type',
                  [
                    'string',
                    'array'
                  ]
                ]);
              }
              if (this.options.noEmptyStrings === true) {
                if (schema.type === 'string' || isArray && schema.type.indexOf('string') !== -1) {
                  if (schema.minLength === undefined && schema.enum === undefined && schema.format === undefined) {
                    schema.minLength = 1;
                  }
                }
              }
              if (this.options.noEmptyArrays === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.minItems === undefined) {
                    schema.minItems = 1;
                  }
                }
              }
              if (this.options.forceProperties === true) {
                if (schema.type === 'object' || isArray && schema.type.indexOf('object') !== -1) {
                  if (schema.properties === undefined && schema.patternProperties === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['properties']);
                  }
                }
              }
              if (this.options.forceItems === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.items === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['items']);
                  }
                }
              }
              if (this.options.forceMinItems === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.minItems === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['minItems']);
                  }
                }
              }
              if (this.options.forceMaxItems === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.maxItems === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['maxItems']);
                  }
                }
              }
              if (this.options.forceMinLength === true) {
                if (schema.type === 'string' || isArray && schema.type.indexOf('string') !== -1) {
                  if (schema.minLength === undefined && schema.format === undefined && schema.enum === undefined && schema.pattern === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['minLength']);
                  }
                }
              }
              if (this.options.forceMaxLength === true) {
                if (schema.type === 'string' || isArray && schema.type.indexOf('string') !== -1) {
                  if (schema.maxLength === undefined && schema.format === undefined && schema.enum === undefined && schema.pattern === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['maxLength']);
                  }
                }
              }
            },
            allOf: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.1
              if (Array.isArray(schema.allOf) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'allOf',
                  'array'
                ]);
              } else if (schema.allOf.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'allOf',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.allOf.length;
                while (idx--) {
                  report.path.push('allOf');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.allOf[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            anyOf: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.1
              if (Array.isArray(schema.anyOf) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'anyOf',
                  'array'
                ]);
              } else if (schema.anyOf.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'anyOf',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.anyOf.length;
                while (idx--) {
                  report.path.push('anyOf');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.anyOf[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            oneOf: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.1
              if (Array.isArray(schema.oneOf) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'oneOf',
                  'array'
                ]);
              } else if (schema.oneOf.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'oneOf',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.oneOf.length;
                while (idx--) {
                  report.path.push('oneOf');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.oneOf[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            not: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.1
              if (Utils.whatIs(schema.not) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'not',
                  'object'
                ]);
              } else {
                report.path.push('not');
                exports.validateSchema.call(this, report, schema.not);
                report.path.pop();
              }
            },
            definitions: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.1
              if (Utils.whatIs(schema.definitions) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'definitions',
                  'object'
                ]);
              } else {
                var keys = Object.keys(schema.definitions), idx = keys.length;
                while (idx--) {
                  var key = keys[idx], val = schema.definitions[key];
                  report.path.push('definitions');
                  report.path.push(key);
                  exports.validateSchema.call(this, report, val);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            format: function (report, schema) {
              if (typeof schema.format !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'format',
                  'string'
                ]);
              } else {
                if (FormatValidators[schema.format] === undefined && this.options.ignoreUnknownFormats !== true) {
                  report.addError('UNKNOWN_FORMAT', [schema.format]);
                }
              }
            },
            id: function (report, schema) {
              // http://json-schema.org/latest/json-schema-core.html#rfc.section.7.2
              if (typeof schema.id !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'id',
                  'string'
                ]);
              }
            },
            title: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
              if (typeof schema.title !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'title',
                  'string'
                ]);
              }
            },
            description: function (report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
              if (typeof schema.description !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'description',
                  'string'
                ]);
              }
            },
            'default': function () {
            }
          };
        var validateArrayOfSchemas = function (report, arr) {
          var idx = arr.length;
          while (idx--) {
            exports.validateSchema.call(this, report, arr[idx]);
          }
          return report.isValid();
        };
        exports.validateSchema = function (report, schema) {
          report.commonErrorMessage = 'SCHEMA_VALIDATION_FAILED';
          // if schema is an array, assume it's an array of schemas
          if (Array.isArray(schema)) {
            return validateArrayOfSchemas.call(this, report, schema);
          }
          // do not revalidate schema that has already been validated once
          if (schema.__$validated) {
            return true;
          }
          // if $schema is present, this schema should validate against that $schema
          var hasParentSchema = schema.$schema && schema.id !== schema.$schema;
          if (hasParentSchema) {
            if (schema.__$schemaResolved && schema.__$schemaResolved !== schema) {
              var subReport = new Report(report);
              var valid = JsonValidation.validate.call(this, subReport, schema.__$schemaResolved, schema);
              if (valid === false) {
                report.addError('PARENT_SCHEMA_VALIDATION_FAILED', null, subReport);
              }
            } else {
              if (this.options.ignoreUnresolvableReferences !== true) {
                report.addError('REF_UNRESOLVED', [schema.$schema]);
              }
            }
          }
          if (this.options.noTypeless === true) {
            // issue #36 - inherit type to anyOf, oneOf, allOf if noTypeless is defined
            if (schema.type !== undefined) {
              var schemas = [];
              if (Array.isArray(schema.anyOf)) {
                schemas = schemas.concat(schema.anyOf);
              }
              if (Array.isArray(schema.oneOf)) {
                schemas = schemas.concat(schema.oneOf);
              }
              if (Array.isArray(schema.allOf)) {
                schemas = schemas.concat(schema.allOf);
              }
              schemas.forEach(function (sch) {
                if (!sch.type) {
                  sch.type = schema.type;
                }
              });
            }
            // end issue #36
            if (schema.enum === undefined && schema.type === undefined && schema.anyOf === undefined && schema.oneOf === undefined && schema.not === undefined && schema.$ref === undefined) {
              report.addError('KEYWORD_UNDEFINED_STRICT', ['type']);
            }
          }
          var keys = Object.keys(schema), idx = keys.length;
          while (idx--) {
            var key = keys[idx];
            if (key.indexOf('__') === 0) {
              continue;
            }
            if (SchemaValidators[key] !== undefined) {
              SchemaValidators[key].call(this, report, schema);
            } else if (!hasParentSchema) {
              if (this.options.noExtraKeywords === true) {
                report.addError('KEYWORD_UNEXPECTED', [key]);
              }
            }
          }
          if (this.options.pedanticCheck === true) {
            if (schema.enum) {
              // break recursion
              var tmpSchema = Utils.clone(schema);
              delete tmpSchema.enum;
              delete tmpSchema.default;
              report.path.push('enum');
              idx = schema.enum.length;
              while (idx--) {
                report.path.push(idx.toString());
                JsonValidation.validate.call(this, report, tmpSchema, schema.enum[idx]);
                report.path.pop();
              }
              report.path.pop();
            }
            if (schema.default) {
              report.path.push('default');
              JsonValidation.validate.call(this, report, schema, schema.default);
              report.path.pop();
            }
          }
          var isValid = report.isValid();
          if (isValid) {
            schema.__$validated = true;
          }
          return isValid;
        };
      },
      {
        './FormatValidators': 217,
        './JsonValidation': 218,
        './Report': 220,
        './Utils': 224
      }
    ],
    224: [
      function (require, module, exports) {
        'use strict';
        exports.isAbsoluteUri = function (uri) {
          return /^https?:\/\//.test(uri);
        };
        exports.isRelativeUri = function (uri) {
          // relative URIs that end with a hash sign, issue #56
          return /.+#/.test(uri);
        };
        exports.whatIs = function (what) {
          var to = typeof what;
          if (to === 'object') {
            if (what === null) {
              return 'null';
            }
            if (Array.isArray(what)) {
              return 'array';
            }
            return 'object';  // typeof what === 'object' && what === Object(what) && !Array.isArray(what);
          }
          if (to === 'number') {
            if (Number.isFinite(what)) {
              if (what % 1 === 0) {
                return 'integer';
              } else {
                return 'number';
              }
            }
            if (Number.isNaN(what)) {
              return 'not-a-number';
            }
            return 'unknown-number';
          }
          return to;  // undefined, boolean, string, function
        };
        exports.areEqual = function areEqual(json1, json2) {
          // http://json-schema.org/latest/json-schema-core.html#rfc.section.3.6
          // Two JSON values are said to be equal if and only if:
          // both are nulls; or
          // both are booleans, and have the same value; or
          // both are strings, and have the same value; or
          // both are numbers, and have the same mathematical value; or
          if (json1 === json2) {
            return true;
          }
          var i, len;
          // both are arrays, and:
          if (Array.isArray(json1) && Array.isArray(json2)) {
            // have the same number of items; and
            if (json1.length !== json2.length) {
              return false;
            }
            // items at the same index are equal according to this definition; or
            len = json1.length;
            for (i = 0; i < len; i++) {
              if (!areEqual(json1[i], json2[i])) {
                return false;
              }
            }
            return true;
          }
          // both are objects, and:
          if (exports.whatIs(json1) === 'object' && exports.whatIs(json2) === 'object') {
            // have the same set of property names; and
            var keys1 = Object.keys(json1);
            var keys2 = Object.keys(json2);
            if (!areEqual(keys1, keys2)) {
              return false;
            }
            // values for a same property name are equal according to this definition.
            len = keys1.length;
            for (i = 0; i < len; i++) {
              if (!areEqual(json1[keys1[i]], json2[keys1[i]])) {
                return false;
              }
            }
            return true;
          }
          return false;
        };
        exports.isUniqueArray = function (arr, indexes) {
          var i, j, l = arr.length;
          for (i = 0; i < l; i++) {
            for (j = i + 1; j < l; j++) {
              if (exports.areEqual(arr[i], arr[j])) {
                if (indexes) {
                  indexes.push(i, j);
                }
                return false;
              }
            }
          }
          return true;
        };
        exports.difference = function (bigSet, subSet) {
          var arr = [], idx = bigSet.length;
          while (idx--) {
            if (subSet.indexOf(bigSet[idx]) === -1) {
              arr.push(bigSet[idx]);
            }
          }
          return arr;
        };
        // NOT a deep version of clone
        exports.clone = function (src) {
          if (typeof src === 'undefined') {
            return void 0;
          }
          if (typeof src !== 'object' || src === null) {
            return src;
          }
          var res, idx;
          if (Array.isArray(src)) {
            res = [];
            idx = src.length;
            while (idx--) {
              res[idx] = src[idx];
            }
          } else {
            res = {};
            var keys = Object.keys(src);
            idx = keys.length;
            while (idx--) {
              var key = keys[idx];
              res[key] = src[key];
            }
          }
          return res;
        };
        exports.cloneDeep = function (src) {
          var visited = [], cloned = [];
          function cloneDeep(src) {
            if (typeof src !== 'object' || src === null) {
              return src;
            }
            var res, idx, cidx;
            cidx = visited.indexOf(src);
            if (cidx !== -1) {
              return cloned[cidx];
            }
            visited.push(src);
            if (Array.isArray(src)) {
              res = [];
              cloned.push(res);
              idx = src.length;
              while (idx--) {
                res[idx] = cloneDeep(src[idx]);
              }
            } else {
              res = {};
              cloned.push(res);
              var keys = Object.keys(src);
              idx = keys.length;
              while (idx--) {
                var key = keys[idx];
                res[key] = cloneDeep(src[key]);
              }
            }
            return res;
          }
          return cloneDeep(src);
        };
        /*
  following function comes from punycode.js library
  see: https://github.com/bestiejs/punycode.js
*/
        /*jshint -W016*/
        /**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
        exports.ucs2decode = function (string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              // high surrogate, and there is a next character
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                // low surrogate
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                // unmatched surrogate; only append this code unit, in case the next
                // code unit is the high surrogate of a surrogate pair
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        };  /*jshint +W016*/
      },
      {}
    ],
    225: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          require('./Polyfills');
          var get = require('lodash.get');
          var Report = require('./Report');
          var FormatValidators = require('./FormatValidators');
          var JsonValidation = require('./JsonValidation');
          var SchemaCache = require('./SchemaCache');
          var SchemaCompilation = require('./SchemaCompilation');
          var SchemaValidation = require('./SchemaValidation');
          var Utils = require('./Utils');
          var Draft4Schema = require('./schemas/schema.json');
          var Draft4HyperSchema = require('./schemas/hyper-schema.json');
          /*
    default options
*/
          var defaultOptions = {
              asyncTimeout: 2000,
              forceAdditional: false,
              assumeAdditional: false,
              forceItems: false,
              forceMinItems: false,
              forceMaxItems: false,
              forceMinLength: false,
              forceMaxLength: false,
              forceProperties: false,
              ignoreUnresolvableReferences: false,
              noExtraKeywords: false,
              noTypeless: false,
              noEmptyStrings: false,
              noEmptyArrays: false,
              strictUris: false,
              strictMode: false,
              reportPathAsArray: false,
              breakOnFirstError: true,
              pedanticCheck: false,
              ignoreUnknownFormats: false,
              customValidator: null
            };
          /*
    constructor
*/
          function ZSchema(options) {
            this.cache = {};
            this.referenceCache = [];
            this.setRemoteReference('http://json-schema.org/draft-04/schema', Draft4Schema);
            this.setRemoteReference('http://json-schema.org/draft-04/hyper-schema', Draft4HyperSchema);
            // options
            if (typeof options === 'object') {
              var keys = Object.keys(options), idx = keys.length, key;
              // check that the options are correctly configured
              while (idx--) {
                key = keys[idx];
                if (defaultOptions[key] === undefined) {
                  throw new Error('Unexpected option passed to constructor: ' + key);
                }
              }
              // copy the default options into passed options
              keys = Object.keys(defaultOptions);
              idx = keys.length;
              while (idx--) {
                key = keys[idx];
                if (options[key] === undefined) {
                  options[key] = Utils.clone(defaultOptions[key]);
                }
              }
              this.options = options;
            } else {
              this.options = Utils.clone(defaultOptions);
            }
            if (this.options.strictMode === true) {
              this.options.forceAdditional = true;
              this.options.forceItems = true;
              this.options.forceMaxLength = true;
              this.options.forceProperties = true;
              this.options.noExtraKeywords = true;
              this.options.noTypeless = true;
              this.options.noEmptyStrings = true;
              this.options.noEmptyArrays = true;
            }
          }
          /*
    instance methods
*/
          ZSchema.prototype.compileSchema = function (schema) {
            var report = new Report(this.options);
            schema = SchemaCache.getSchema.call(this, report, schema);
            SchemaCompilation.compileSchema.call(this, report, schema);
            this.lastReport = report;
            return report.isValid();
          };
          ZSchema.prototype.validateSchema = function (schema) {
            if (Array.isArray(schema) && schema.length === 0) {
              throw new Error('.validateSchema was called with an empty array');
            }
            var report = new Report(this.options);
            schema = SchemaCache.getSchema.call(this, report, schema);
            var compiled = SchemaCompilation.compileSchema.call(this, report, schema);
            if (compiled) {
              SchemaValidation.validateSchema.call(this, report, schema);
            }
            this.lastReport = report;
            return report.isValid();
          };
          ZSchema.prototype.validate = function (json, schema, options, callback) {
            if (Utils.whatIs(options) === 'function') {
              callback = options;
              options = {};
            }
            if (!options) {
              options = {};
            }
            var whatIs = Utils.whatIs(schema);
            if (whatIs !== 'string' && whatIs !== 'object') {
              var e = new Error('Invalid .validate call - schema must be an string or object but ' + whatIs + ' was passed!');
              if (callback) {
                process.nextTick(function () {
                  callback(e, false);
                });
                return;
              }
              throw e;
            }
            var foundError = false;
            var report = new Report(this.options);
            if (typeof schema === 'string') {
              var schemaName = schema;
              schema = SchemaCache.getSchema.call(this, report, schemaName);
              if (!schema) {
                throw new Error('Schema with id \'' + schemaName + '\' wasn\'t found in the validator cache!');
              }
            } else {
              schema = SchemaCache.getSchema.call(this, report, schema);
            }
            var compiled = false;
            if (!foundError) {
              compiled = SchemaCompilation.compileSchema.call(this, report, schema);
            }
            if (!compiled) {
              this.lastReport = report;
              foundError = true;
            }
            var validated = false;
            if (!foundError) {
              validated = SchemaValidation.validateSchema.call(this, report, schema);
            }
            if (!validated) {
              this.lastReport = report;
              foundError = true;
            }
            if (options.schemaPath) {
              report.rootSchema = schema;
              schema = get(schema, options.schemaPath);
              if (!schema) {
                throw new Error('Schema path \'' + options.schemaPath + '\' wasn\'t found in the schema!');
              }
            }
            if (!foundError) {
              JsonValidation.validate.call(this, report, schema, json);
            }
            if (callback) {
              report.processAsyncTasks(this.options.asyncTimeout, callback);
              return;
            } else if (report.asyncTasks.length > 0) {
              throw new Error('This validation has async tasks and cannot be done in sync mode, please provide callback argument.');
            }
            // assign lastReport so errors are retrievable in sync mode
            this.lastReport = report;
            return report.isValid();
          };
          ZSchema.prototype.getLastError = function () {
            if (this.lastReport.errors.length === 0) {
              return null;
            }
            var e = new Error();
            e.name = 'z-schema validation error';
            e.message = this.lastReport.commonErrorMessage;
            e.details = this.lastReport.errors;
            return e;
          };
          ZSchema.prototype.getLastErrors = function () {
            return this.lastReport && this.lastReport.errors.length > 0 ? this.lastReport.errors : undefined;
          };
          ZSchema.prototype.getMissingReferences = function (arr) {
            arr = arr || this.lastReport.errors;
            var res = [], idx = arr.length;
            while (idx--) {
              var error = arr[idx];
              if (error.code === 'UNRESOLVABLE_REFERENCE') {
                var reference = error.params[0];
                if (res.indexOf(reference) === -1) {
                  res.push(reference);
                }
              }
              if (error.inner) {
                res = res.concat(this.getMissingReferences(error.inner));
              }
            }
            return res;
          };
          ZSchema.prototype.getMissingRemoteReferences = function () {
            var missingReferences = this.getMissingReferences(), missingRemoteReferences = [], idx = missingReferences.length;
            while (idx--) {
              var remoteReference = SchemaCache.getRemotePath(missingReferences[idx]);
              if (remoteReference && missingRemoteReferences.indexOf(remoteReference) === -1) {
                missingRemoteReferences.push(remoteReference);
              }
            }
            return missingRemoteReferences;
          };
          ZSchema.prototype.setRemoteReference = function (uri, schema) {
            if (typeof schema === 'string') {
              schema = JSON.parse(schema);
            } else {
              schema = Utils.cloneDeep(schema);
            }
            SchemaCache.cacheSchemaByUri.call(this, uri, schema);
          };
          ZSchema.prototype.getResolvedSchema = function (schema) {
            var report = new Report(this.options);
            schema = SchemaCache.getSchema.call(this, report, schema);
            // clone before making any modifications
            schema = Utils.cloneDeep(schema);
            var visited = [];
            // clean-up the schema and resolve references
            var cleanup = function (schema) {
              var key, typeOf = Utils.whatIs(schema);
              if (typeOf !== 'object' && typeOf !== 'array') {
                return;
              }
              if (schema.___$visited) {
                return;
              }
              schema.___$visited = true;
              visited.push(schema);
              if (schema.$ref && schema.__$refResolved) {
                var from = schema.__$refResolved;
                var to = schema;
                delete schema.$ref;
                delete schema.__$refResolved;
                for (key in from) {
                  if (from.hasOwnProperty(key)) {
                    to[key] = from[key];
                  }
                }
              }
              for (key in schema) {
                if (schema.hasOwnProperty(key)) {
                  if (key.indexOf('__$') === 0) {
                    delete schema[key];
                  } else {
                    cleanup(schema[key]);
                  }
                }
              }
            };
            cleanup(schema);
            visited.forEach(function (s) {
              delete s.___$visited;
            });
            this.lastReport = report;
            if (report.isValid()) {
              return schema;
            } else {
              throw this.getLastError();
            }
          };
          ZSchema.prototype.setSchemaReader = function (schemaReader) {
            return ZSchema.setSchemaReader(schemaReader);
          };
          ZSchema.prototype.getSchemaReader = function () {
            return ZSchema.schemaReader;
          };
          /*
    static methods
*/
          ZSchema.setSchemaReader = function (schemaReader) {
            ZSchema.schemaReader = schemaReader;
          };
          ZSchema.registerFormat = function (formatName, validatorFunction) {
            FormatValidators[formatName] = validatorFunction;
          };
          ZSchema.unregisterFormat = function (formatName) {
            delete FormatValidators[formatName];
          };
          ZSchema.getRegisteredFormats = function () {
            return Object.keys(FormatValidators);
          };
          ZSchema.getDefaultOptions = function () {
            return Utils.cloneDeep(defaultOptions);
          };
          module.exports = ZSchema;
        }.call(this, require('_process')));
      },
      {
        './FormatValidators': 217,
        './JsonValidation': 218,
        './Polyfills': 219,
        './Report': 220,
        './SchemaCache': 221,
        './SchemaCompilation': 222,
        './SchemaValidation': 223,
        './Utils': 224,
        './schemas/hyper-schema.json': 226,
        './schemas/schema.json': 227,
        '_process': 115,
        'lodash.get': 108
      }
    ],
    226: [
      function (require, module, exports) {
        module.exports = {
          '$schema': 'http://json-schema.org/draft-04/hyper-schema#',
          'id': 'http://json-schema.org/draft-04/hyper-schema#',
          'title': 'JSON Hyper-Schema',
          'allOf': [{ '$ref': 'http://json-schema.org/draft-04/schema#' }],
          'properties': {
            'additionalItems': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ]
            },
            'additionalProperties': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ]
            },
            'dependencies': {
              'additionalProperties': {
                'anyOf': [
                  { '$ref': '#' },
                  { 'type': 'array' }
                ]
              }
            },
            'items': {
              'anyOf': [
                { '$ref': '#' },
                { '$ref': '#/definitions/schemaArray' }
              ]
            },
            'definitions': { 'additionalProperties': { '$ref': '#' } },
            'patternProperties': { 'additionalProperties': { '$ref': '#' } },
            'properties': { 'additionalProperties': { '$ref': '#' } },
            'allOf': { '$ref': '#/definitions/schemaArray' },
            'anyOf': { '$ref': '#/definitions/schemaArray' },
            'oneOf': { '$ref': '#/definitions/schemaArray' },
            'not': { '$ref': '#' },
            'links': {
              'type': 'array',
              'items': { '$ref': '#/definitions/linkDescription' }
            },
            'fragmentResolution': { 'type': 'string' },
            'media': {
              'type': 'object',
              'properties': {
                'type': {
                  'description': 'A media type, as described in RFC 2046',
                  'type': 'string'
                },
                'binaryEncoding': {
                  'description': 'A content encoding scheme, as described in RFC 2045',
                  'type': 'string'
                }
              }
            },
            'pathStart': {
              'description': 'Instances\' URIs must start with this value for this schema to apply to them',
              'type': 'string',
              'format': 'uri'
            }
          },
          'definitions': {
            'schemaArray': {
              'type': 'array',
              'items': { '$ref': '#' }
            },
            'linkDescription': {
              'title': 'Link Description Object',
              'type': 'object',
              'required': [
                'href',
                'rel'
              ],
              'properties': {
                'href': {
                  'description': 'a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing',
                  'type': 'string'
                },
                'rel': {
                  'description': 'relation to the target resource of the link',
                  'type': 'string'
                },
                'title': {
                  'description': 'a title for the link',
                  'type': 'string'
                },
                'targetSchema': {
                  'description': 'JSON Schema describing the link target',
                  '$ref': '#'
                },
                'mediaType': {
                  'description': 'media type (as defined by RFC 2046) describing the link target',
                  'type': 'string'
                },
                'method': {
                  'description': 'method for requesting the target of the link (e.g. for HTTP this might be "GET" or "DELETE")',
                  'type': 'string'
                },
                'encType': {
                  'description': 'The media type in which to submit data along with the request',
                  'type': 'string',
                  'default': 'application/json'
                },
                'schema': {
                  'description': 'Schema describing the data to submit along with the request',
                  '$ref': '#'
                }
              }
            }
          }
        };
      },
      {}
    ],
    227: [
      function (require, module, exports) {
        module.exports = {
          'id': 'http://json-schema.org/draft-04/schema#',
          '$schema': 'http://json-schema.org/draft-04/schema#',
          'description': 'Core schema meta-schema',
          'definitions': {
            'schemaArray': {
              'type': 'array',
              'minItems': 1,
              'items': { '$ref': '#' }
            },
            'positiveInteger': {
              'type': 'integer',
              'minimum': 0
            },
            'positiveIntegerDefault0': {
              'allOf': [
                { '$ref': '#/definitions/positiveInteger' },
                { 'default': 0 }
              ]
            },
            'simpleTypes': {
              'enum': [
                'array',
                'boolean',
                'integer',
                'null',
                'number',
                'object',
                'string'
              ]
            },
            'stringArray': {
              'type': 'array',
              'items': { 'type': 'string' },
              'minItems': 1,
              'uniqueItems': true
            }
          },
          'type': 'object',
          'properties': {
            'id': {
              'type': 'string',
              'format': 'uri'
            },
            '$schema': {
              'type': 'string',
              'format': 'uri'
            },
            'title': { 'type': 'string' },
            'description': { 'type': 'string' },
            'default': {},
            'multipleOf': {
              'type': 'number',
              'minimum': 0,
              'exclusiveMinimum': true
            },
            'maximum': { 'type': 'number' },
            'exclusiveMaximum': {
              'type': 'boolean',
              'default': false
            },
            'minimum': { 'type': 'number' },
            'exclusiveMinimum': {
              'type': 'boolean',
              'default': false
            },
            'maxLength': { '$ref': '#/definitions/positiveInteger' },
            'minLength': { '$ref': '#/definitions/positiveIntegerDefault0' },
            'pattern': {
              'type': 'string',
              'format': 'regex'
            },
            'additionalItems': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ],
              'default': {}
            },
            'items': {
              'anyOf': [
                { '$ref': '#' },
                { '$ref': '#/definitions/schemaArray' }
              ],
              'default': {}
            },
            'maxItems': { '$ref': '#/definitions/positiveInteger' },
            'minItems': { '$ref': '#/definitions/positiveIntegerDefault0' },
            'uniqueItems': {
              'type': 'boolean',
              'default': false
            },
            'maxProperties': { '$ref': '#/definitions/positiveInteger' },
            'minProperties': { '$ref': '#/definitions/positiveIntegerDefault0' },
            'required': { '$ref': '#/definitions/stringArray' },
            'additionalProperties': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ],
              'default': {}
            },
            'definitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#' },
              'default': {}
            },
            'properties': {
              'type': 'object',
              'additionalProperties': { '$ref': '#' },
              'default': {}
            },
            'patternProperties': {
              'type': 'object',
              'additionalProperties': { '$ref': '#' },
              'default': {}
            },
            'dependencies': {
              'type': 'object',
              'additionalProperties': {
                'anyOf': [
                  { '$ref': '#' },
                  { '$ref': '#/definitions/stringArray' }
                ]
              }
            },
            'enum': {
              'type': 'array',
              'minItems': 1,
              'uniqueItems': true
            },
            'type': {
              'anyOf': [
                { '$ref': '#/definitions/simpleTypes' },
                {
                  'type': 'array',
                  'items': { '$ref': '#/definitions/simpleTypes' },
                  'minItems': 1,
                  'uniqueItems': true
                }
              ]
            },
            'format': { 'type': 'string' },
            'allOf': { '$ref': '#/definitions/schemaArray' },
            'anyOf': { '$ref': '#/definitions/schemaArray' },
            'oneOf': { '$ref': '#/definitions/schemaArray' },
            'not': { '$ref': '#' }
          },
          'dependencies': {
            'exclusiveMaximum': ['maximum'],
            'exclusiveMinimum': ['minimum']
          },
          'default': {}
        };
      },
      {}
    ]
  }, {}, [1])(1);
}));
// CodeMirror is the only global var we claim
window.CodeMirror = function () {
  'use strict';
  // BROWSER SNIFFING
  // Crude, but necessary to handle a number of hard-to-feature-detect
  // bugs and behavior differences.
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);
  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);
  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version)
    opera_version = Number(opera_version[1]);
  if (opera_version && opera_version >= 15) {
    opera = false;
    webkit = true;
  }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || ie && !ie_lt9;
  // Optimize some code when these features are not used
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  // CONSTRUCTOR
  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror))
      return new CodeMirror(place, options);
    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    for (var opt in defaults)
      if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
        options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);
    var docStart = typeof options.value == 'string' ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile)
      focusInput(this);
    this.state = {
      keyMaps: [],
      overlays: [],
      modeGen: 0,
      overwrite: false,
      focused: false,
      suppressEdits: false,
      pasteIncoming: false,
      draggingText: false,
      highlight: new Delayed()
    };
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += ' CodeMirror-wrap';
    var doc = options.value;
    if (typeof doc == 'string')
      doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);
    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie)
      setTimeout(bind(resetInput, this, true), 20);
    registerEventHandlers(this);
    // IE throws unspecified error in certain cases, when
    // trying to access activeElement before onload
    var hasFocus;
    try {
      hasFocus = document.activeElement == display.input;
    } catch (e) {
    }
    if (hasFocus || options.autofocus && !mobile)
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);
    operation(this, function () {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i)
        initHooks[i](this);
    })();
  }
  // DISPLAY CONSTRUCTOR
  function makeDisplay(place, docStart) {
    var d = {};
    var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;');
    if (webkit)
      input.style.width = '1000px';
    else
      input.setAttribute('wrap', 'off');
    // if border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios)
      input.style.border = '1px solid black';
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('autocapitalize', 'off');
    input.setAttribute('spellcheck', 'false');
    // Wraps and hides input textarea
    d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
    // The actual fake scrollbars.
    d.scrollbarH = elt('div', [elt('div', null, null, 'height: 1px')], 'CodeMirror-hscrollbar');
    d.scrollbarV = elt('div', [elt('div', null, null, 'width: 1px')], 'CodeMirror-vscrollbar');
    d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
    d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler');
    // DIVs containing the selection and the actual code
    d.lineDiv = elt('div', null, 'CodeMirror-code');
    d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
    // Blinky cursor, and element used to ensure cursor fits at the end of a line
    d.cursor = elt('div', '\xa0', 'CodeMirror-cursor');
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    d.otherCursor = elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor');
    // Used to measure text size
    d.measure = elt('div', null, 'CodeMirror-measure');
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt('div', [
      d.measure,
      d.selectionDiv,
      d.lineDiv,
      d.cursor,
      d.otherCursor
    ], null, 'position: relative; outline: none');
    // Moved around its parent to cover visible view
    d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
    // Set to the height of the text, causes scrolling
    d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
    d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
    // Will contain the gutters, if any
    d.gutters = elt('div', null, 'CodeMirror-gutters');
    d.lineGutter = null;
    // Provides scrolling
    d.scroller = elt('div', [
      d.sizer,
      d.heightForcer,
      d.gutters
    ], 'CodeMirror-scroll');
    d.scroller.setAttribute('tabIndex', '-1');
    // The element in which the editor lives.
    d.wrapper = elt('div', [
      d.inputDiv,
      d.scrollbarH,
      d.scrollbarV,
      d.scrollbarFiller,
      d.gutterFiller,
      d.scroller
    ], 'CodeMirror');
    // Work around IE7 z-index bug
    if (ie_lt8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (place.appendChild)
      place.appendChild(d.wrapper);
    else
      place(d.wrapper);
    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios)
      input.style.width = '0px';
    if (!webkit)
      d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) {
      d.inputDiv.style.height = '1px';
      d.inputDiv.style.position = 'absolute';
    }  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    else if (ie_lt8)
      d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = '18px';
    // Current visible range (may be bigger than the view window).
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;
    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = '';
    // Set to true when a non-horizontal-scrolling widget is added. As
    // an optimization, widget aligning is skipped when d is false.
    d.alignWidgets = false;
    // Flag that indicates whether we currently expect input to appear
    // (after some event like 'keypress' or 'input') and are polling
    // intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();
    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;
    // Tracks when resetInput has punted to just putting a short
    // string instead of the (large) selection.
    d.inaccurateSelection = false;
    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    return d;
  }
  // STATE UPDATES
  // Used to get the editor into a consistent state again when options change.
  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function (line) {
      if (line.stateAfter)
        line.stateAfter = null;
      if (line.styles)
        line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp)
      regChange(cm);
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += ' CodeMirror-wrap';
      cm.display.sizer.style.minWidth = '';
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-wrap', '');
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      updateScrollbars(cm);
    }, 100);
  }
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height)
        updateLineHeight(line, estHeight);
    });
  }
  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
    cm.state.disableInput = map.disableInput;
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
    clearCaches(cm);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function () {
      alignHorizontally(cm);
    }, 20);
  }
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
      if (gutterClass == 'CodeMirror-linenumbers') {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
      }
    }
    gutters.style.display = i ? '' : 'none';
  }
  function lineLength(doc, line) {
    if (line.height == 0)
      return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }
  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == 'CodeMirror-linenumbers') {
        if (options.lineNumbers)
          found = true;
        else
          options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push('CodeMirror-linenumbers');
  }
  // SCROLLBARS
  // Re-synchronize the fake scrollbars with the actual size of the
  // content. Optionally force a scrollTop.
  function updateScrollbars(cm) {
    var d = cm.display, docHeight = cm.doc.height;
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + 'px';
    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + 'px';
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1;
    var needsV = scrollHeight > d.scroller.clientHeight + 1;
    if (needsV) {
      d.scrollbarV.style.display = 'block';
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + 'px';
    } else
      d.scrollbarV.style.display = '';
    if (needsH) {
      d.scrollbarH.style.display = 'block';
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + 'px';
    } else
      d.scrollbarH.style.display = '';
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = 'block';
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
    } else
      d.scrollbarFiller.style.display = '';
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = 'block';
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + 'px';
      d.gutterFiller.style.width = d.gutters.offsetWidth + 'px';
    } else
      d.gutterFiller.style.display = '';
    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? '18px' : '12px';
  }
  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == 'number')
      top = viewPort;
    else if (viewPort) {
      top = viewPort.top;
      height = viewPort.bottom - viewPort.top;
    }
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {
      from: lineAtHeight(doc, top),
      to: lineAtHeight(doc, bottom)
    };
  }
  // LINE NUMBERS
  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
      return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + 'px';
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)
      if (n.alignable) {
        for (var i = 0, a = n.alignable; i < a.length; ++i)
          a[i].style.left = l;
      }
    if (cm.options.fixedGutter)
      display.gutters.style.left = comp + gutterW + 'px';
  }
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers)
      return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = '';
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + 'px';
      return true;
    }
    return false;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }
  // DISPLAY DRAWING
  function updateDisplay(cm, changes, viewPort, forced) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (!updateDisplayInner(cm, changes, visible, forced))
        break;
      forced = false;
      updated = true;
      updateSelection(cm);
      updateScrollbars(cm);
      // Clip forced viewport to actual scrollable area
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == 'number' ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }
    if (updated) {
      signalLater(cm, 'update', cm);
      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
        signalLater(cm, 'viewportChange', cm, cm.display.showingFrom, cm.display.showingTo);
    }
    return updated;
  }
  // Uses a set of changes plus the current scroll position to
  // determine which DOM updates have to be made, and makes the
  // updates.
  function updateDisplayInner(cm, changes, visible, forced) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }
    // Bail out if the visible area is already rendered and nothing changed.
    if (!forced && changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo)
      return;
    if (maybeUpdateLineNumberWidth(cm))
      changes = [{
          from: doc.first,
          to: doc.first + doc.size
        }];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + 'px';
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : '0';
    // Used to determine which lines need their line numbers updated
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) {
          positionsChangedFrom = changes[i].from;
          break;
        }
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20)
      from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20)
      to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to)))
        ++to;
    }
    // Create a range of theoretically intact lines, and punch holes
    // in that using the change info.
    var intact = [{
          from: Math.max(display.showingFrom, doc.first),
          to: Math.min(display.showingTo, end)
        }];
    if (intact[0].from >= intact[0].to)
      intact = [];
    else
      intact = computeIntact(intact, changes);
    // When merged lines are present, we might have to reduce the
    // intact ranges because changes in continued fragments of the
    // intact lines do require the lines to be redrawn.
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from)
            range.to = newTo;
          else {
            intact.splice(i--, 1);
            break;
          }
        }
      }
    // Clip off the parts that won't be visible
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from)
        range.from = from;
      if (range.to > to)
        range.to = to;
      if (range.from >= range.to)
        intact.splice(i--, 1);
      else
        intactLines += range.to - range.from;
    }
    if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function (a, b) {
      return a.from - b.from;
    });
    // Avoid crashing on IE's "unspecified error" when in iframes
    try {
      var focused = document.activeElement;
    } catch (e) {
    }
    if (intactLines < (to - from) * 0.7)
      display.lineDiv.style.display = 'none';
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = '';
    if (focused && document.activeElement != focused && focused.offsetHeight)
      focused.focus();
    var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
    // This is just a bogus formula that detects when the editor is
    // resized or the font size changes.
    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }
    display.showingFrom = from;
    display.showingTo = to;
    updateHeightsInViewport(cm);
    updateViewOffset(cm);
    return true;
  }
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling)
      if (node.lineObj) {
        if (ie_lt8) {
          var bot = node.offsetTop + node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = getRect(node);
          height = box.bottom - box.top;
        }
        var diff = node.lineObj.height - height;
        if (height < 2)
          height = textHeight(display);
        if (diff > 0.001 || diff < -0.001) {
          updateLineHeight(node.lineObj, height);
          var widgets = node.lineObj.widgets;
          if (widgets)
            for (var i = 0; i < widgets.length; ++i)
              widgets[i].height = widgets[i].node.offsetHeight;
        }
      }
  }
  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    // Position the mover div to align with the current virtual scroll position
    cm.display.mover.style.top = off + 'px';
  }
  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({
            from: range.from + diff,
            to: range.to + diff
          });
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({
              from: range.from,
              to: change.from
            });
          if (change.to < range.to)
            intact2.push({
              from: change.to + diff,
              to: range.to + diff
            });
        }
      }
      intact = intact2;
    }
    return intact;
  }
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = 'none';
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }
    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function (line) {
      if (nextIntact && nextIntact.to == lineN)
        nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0)
          updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling)
          for (var i = 0; i < line.widgets.length; ++i) {
            var w = line.widgets[i];
            if (w.showIfHidden) {
              var prev = cur.previousSibling;
              if (/pre/i.test(prev.nodeName)) {
                var wrap = elt('div', null, null, 'position: relative');
                prev.parentNode.replaceChild(wrap, prev);
                wrap.appendChild(prev);
                prev = wrap;
              }
              var wnode = prev.appendChild(elt('div', [w.node], 'CodeMirror-linewidget'));
              if (!w.handleMouseEvents)
                wnode.ignoreEvents = true;
              positionLineWidget(w, wnode, prev, dims);
            }
          }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        // This line is intact. Skip to the actual node. Update its
        // line number if needed.
        while (cur.lineObj != line)
          cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        // For lines with widgets, make an attempt to find and reuse
        // the existing element, so that widgets aren't needlessly
        // removed and re-inserted into the dom
        if (line.widgets)
          for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
            if (search.lineObj == line && /div/i.test(search.nodeName)) {
              reuse = search;
              break;
            }
        // This line needs to be generated.
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse)
            cur = rm(cur);
          cur = cur.nextSibling;
        }
        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur)
      cur = rm(cur);
  }
  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;
    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;
    // Lines with gutter elements, widgets or a background class need
    // to be wrapped again, and have the extra elements added to the
    // wrapper div
    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0, insertBefore = null;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0; i < line.widgets.length; ++i) {
            var widget = line.widgets[i];
            if (widget.node == n.firstChild) {
              if (!widget.above && !insertBefore)
                insertBefore = n;
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              break;
            }
          }
          if (i == line.widgets.length) {
            isOk = false;
            break;
          }
        }
      }
      reuse.insertBefore(lineElement, insertBefore);
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || '';
      }
    }
    if (!wrap) {
      wrap = elt('div', null, line.wrapClass, 'position: relative');
      wrap.appendChild(lineElement);
    }
    // Kludge to make sure the styled element lies behind the selection (by z-index)
    if (line.bgClass)
      wrap.insertBefore(elt('div', null, line.bgClass + ' CodeMirror-linebackground'), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt('div', null, null, 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), wrap.firstChild);
      if (cm.options.fixedGutter)
        (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
        wrap.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineNo), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + display.lineNumInnerWidth + 'px'));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
        }
    }
    if (ie_lt8)
      wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse)
      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
        var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
        if (!widget.handleMouseEvents)
          node.ignoreEvents = true;
        positionLineWidget(widget, node, wrap, dims);
        if (widget.above)
          wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
        else
          wrap.appendChild(node);
        signalLater(widget, 'redraw');
      }
    return wrap;
  }
  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + 'px';
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + 'px';
      }
      node.style.width = width + 'px';
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = 'relative';
      if (!widget.noHScroll)
        node.style.marginLeft = -dims.gutterTotalWidth + 'px';
    }
  }
  // SELECTION / CURSOR
  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = 'none';
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = 'none';
    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, 'div');
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + 'px';
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + 'px';
    }
  }
  // No selection, plain cursor
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, 'div');
    display.cursor.style.left = pos.left + 'px';
    display.cursor.style.top = pos.top + 'px';
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
    display.cursor.style.display = '';
    if (pos.other) {
      display.otherCursor.style.display = '';
      display.otherCursor.style.left = pos.other.left + 'px';
      display.otherCursor.style.top = pos.other.top + 'px';
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
    } else {
      display.otherCursor.style.display = 'none';
    }
  }
  // Highlight selection
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);
    function add(left, top, width, bottom) {
      if (top < 0)
        top = 0;
      fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? clientWidth - left : width) + 'px; height: ' + (bottom - top) + 'px'));
    }
    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), 'div', lineObj, bias);
      }
      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
        var leftPos = coords(from, 'left'), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, 'right');
          if (dir == 'rtl') {
            var tmp = leftPos;
            leftPos = rightPos;
            rightPos = tmp;
          }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0)
          left = pl;
        if (rightPos.top - leftPos.top > 3) {
          // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top)
            add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen)
          right = clientWidth;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < pl + 1)
          left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {
        start: start,
        end: end
      };
    }
    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);
      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(pl, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(pl, leftEnd.bottom, null, rightStart.top);
    }
    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = '';
  }
  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused)
      return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = '';
    display.blinker = setInterval(function () {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? '' : 'hidden';
    }, cm.options.cursorBlinkRate);
  }
  // HIGHLIGHT WORKER
  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first)
      doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo)
      return;
    var end = +new Date() + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
      if (doc.frontier >= cm.display.showingFrom) {
        // Visible
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i)
          ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier)
            prevChange.end++;
          else
            changed.push(prevChange = {
              start: doc.frontier,
              end: doc.frontier + 1
            });
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function () {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }
  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first)
        return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier))
        return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState)
      return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
    if (!state)
      state = startState(doc.mode);
    else
      state = copyState(doc.mode, state);
    doc.iter(pos, n, function (line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }
  // POSITION MEASUREMENT
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt('pre', null, null, 'text-align: left')).appendChild(elt('span', 'x'));
    return e.offsetLeft;
  }
  function measureChar(cm, line, ch, data, bias) {
    var dir = -1;
    data = data || measureLine(cm, line);
    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r)
        break;
      if (dir < 0 && pos == 0)
        dir = 1;
    }
    bias = pos > ch ? 'left' : pos < ch ? 'right' : bias;
    if (bias == 'left' && r.leftSide)
      r = r.leftSide;
    else if (bias == 'right' && r.rightSide)
      r = r.rightSide;
    return {
      left: pos < ch ? r.right : r.left,
      right: pos > ch ? r.left : r.right,
      top: r.top,
      bottom: r.bottom
    };
  }
  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + '|' + line.bgClass + '|' + line.wrapClass)
        return memo;
    }
  }
  function clearCachedMeasurement(cm, line) {
    var exists = findCachedMeasurement(cm, line);
    if (exists)
      exists.text = exists.measure = exists.markedSpans = null;
  }
  function measureLine(cm, line) {
    // First look in the cache
    var cached = findCachedMeasurement(cm, line);
    if (cached)
      return cached.measure;
    // Failing that, recompute and store result in cache
    var measure = measureLineInner(cm, line);
    var cache = cm.display.measureLineCache;
    var memo = {
        text: line.text,
        width: cm.display.scroller.clientWidth,
        markedSpans: line.markedSpans,
        measure: measure,
        classes: line.textClass + '|' + line.bgClass + '|' + line.wrapClass
      };
    if (cache.length == 16)
      cache[++cm.display.measureLineCachePos % 16] = memo;
    else
      cache.push(memo);
    return measure;
  }
  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure, true);
    // IE does not cache element positions of inline elements between
    // calls to getBoundingClientRect. This makes the loop below,
    // which gathers the positions of all the characters on the line,
    // do an amount of layout work quadratic to the number of
    // characters. When line wrapping is off, we try to improve things
    // by first subdividing the line into a bunch of inline blocks, so
    // that IE can reuse most of the layout information from caches
    // for those blocks. This does interfere with line wrapping, so it
    // doesn't work when wrapping is on, but in that case the
    // situation is slightly better, since IE does cache line-wrapping
    // information and only recomputes per-line.
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt('div', null, null, 'display: inline-block');
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }
    removeChildrenAndAdd(display.measure, pre);
    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    // Work around an IE7/8 bug where it will sometimes have randomly
    // replaced our pre with a clone at this point.
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);
    function measureRect(rect) {
      var top = rect.top - outer.top, bot = rect.bottom - outer.top;
      if (bot > maxBot)
        bot = maxBot;
      if (top < 0)
        top = 0;
      for (var i = vranges.length - 2; i >= 0; i -= 2) {
        var rtop = vranges[i], rbot = vranges[i + 1];
        if (rtop > bot || rbot < top)
          continue;
        if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
          vranges[i] = Math.min(top, rtop);
          vranges[i + 1] = Math.max(bot, rbot);
          break;
        }
      }
      if (i < 0) {
        i = vranges.length;
        vranges.push(top, bot);
      }
      return {
        left: rect.left - outer.left,
        right: rect.right - outer.left,
        top: i,
        bottom: null
      };
    }
    function finishRect(rect) {
      rect.bottom = vranges[rect.top + 1];
      rect.top = vranges[rect.top];
    }
    for (var i = 0, cur; i < measure.length; ++i)
      if (cur = measure[i]) {
        var node = cur, rect = null;
        // A widget might wrap, needs special care
        if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
          if (cur.firstChild.nodeType == 1)
            node = cur.firstChild;
          var rects = node.getClientRects();
          if (rects.length > 1) {
            rect = data[i] = measureRect(rects[0]);
            rect.rightSide = measureRect(rects[rects.length - 1]);
          }
        }
        if (!rect)
          rect = data[i] = measureRect(getRect(node));
        if (cur.measureRight)
          rect.right = getRect(cur.measureRight).left;
        if (cur.leftSide)
          rect.leftSide = measureRect(getRect(cur.leftSide));
      }
    for (var i = 0, cur; i < data.length; ++i)
      if (cur = data[i]) {
        finishRect(cur);
        if (cur.leftSide)
          finishRect(cur.leftSide);
        if (cur.rightSide)
          finishRect(cur.rightSide);
      }
    return data;
  }
  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans)
      for (var i = 0; i < line.markedSpans; ++i) {
        var sp = line.markedSpans[i];
        if (sp.collapsed && (sp.to == null || sp.to == line.text.length))
          hasBadSpan = true;
      }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached)
      return measureChar(cm, line, line.text.length, cached.measure, 'right').right;
    var pre = lineContent(cm, line, null, true);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }
  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping)
      cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }
  function pageScrollX() {
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }
  function pageScrollY() {
    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }
  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets)
      for (var i = 0; i < lineObj.widgets.length; ++i)
        if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;
          rect.bottom += size;
        }
    if (context == 'line')
      return rect;
    if (!context)
      context = 'local';
    var yOff = heightAtLine(cm, lineObj);
    if (context == 'local')
      yOff += paddingTop(cm.display);
    else
      yOff -= cm.display.viewOffset;
    if (context == 'page' || context == 'window') {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());
      var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  // Context may be "window", "page", "div", or "local"/null
  // Result is in "div" coords
  function fromCoordSystem(cm, coords, context) {
    if (context == 'div')
      return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == 'page') {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == 'local' || !context) {
      var localBox = getRect(cm.display.sizer);
      left += localBox.left;
      top += localBox.top;
    }
    var lineSpaceBox = getRect(cm.display.lineSpace);
    return {
      left: left - lineSpaceBox.left,
      top: top - lineSpaceBox.top
    };
  }
  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj)
      lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
  }
  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement)
      measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement, right ? 'right' : 'left');
      if (right)
        m.left = m.right;
      else
        m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from)
        return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order)
      return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null)
      val.other = getBidi(ch, bidiOther);
    return val;
  }
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = new Pos(line, ch);
    pos.xRel = xRel;
    if (outside)
      pos.outside = true;
    return pos;
  }
  // Coords must be lineSpace-local
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0)
      return PosWithInfo(doc.first, 0, true, -1);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0)
      x = 0;
    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }
  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);
    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom)
        return sp.left - adjust;
      else if (innerOff < sp.top)
        return sp.left + adjust;
      else
        wrongLine = false;
      return sp.left;
    }
    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
    if (x > toX)
      return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar.test(lineObj.text.charAt(ch)))
          ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < 0 ? -1 : xDiff ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i)
          middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {
        to = middle;
        toX = middleX;
        if (toOutside = wrongLine)
          toX += 1000;
        dist = step;
      } else {
        from = middle;
        fromX = middleX;
        fromOutside = wrongLine;
        dist -= step;
      }
    }
  }
  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null)
      return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt('pre');
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode('x'));
        measureText.appendChild(elt('br'));
      }
      measureText.appendChild(document.createTextNode('x'));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3)
      display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }
  function charWidth(display) {
    if (display.cachedCharWidth != null)
      return display.cachedCharWidth;
    var anchor = elt('span', 'x');
    var pre = elt('pre', [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2)
      display.cachedCharWidth = width;
    return width || 10;
  }
  // OPERATIONS
  // Operations are used to wrap changes in such a way that each
  // change won't have to update the cursor and display (which would
  // be awkward, slow, and error-prone), but instead updates are
  // batched and then all combined and executed at once.
  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      changes: [],
      forceUpdate: false,
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++)
      delayedCallbacks = [];
  }
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;
    if (op.updateMaxLine)
      computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + 'px';
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) {
      // don't rescroll if not visible
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);
      if (cm.display.scroller.offsetHeight)
        cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged)
      updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged)
      restartBlink(cm);
    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden)
      for (var i = 0; i < hidden.length; ++i)
        if (!hidden[i].lines.length)
          signal(hidden[i], 'hide');
    if (unhidden)
      for (var i = 0; i < unhidden.length; ++i)
        if (unhidden[i].lines.length)
          signal(unhidden[i], 'unhide');
    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, 'change', cm, op.textChanged);
    if (op.cursorActivity)
      signal(cm, 'cursorActivity', cm);
    if (delayed)
      for (var i = 0; i < delayed.length; ++i)
        delayed[i]();
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm1, f) {
    return function () {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp)
        startOperation(cm);
      try {
        var result = f.apply(cm, arguments);
      } finally {
        if (withOp)
          endOperation(cm);
      }
      return result;
    };
  }
  function docOperation(f) {
    return function () {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp)
        startOperation(this.cm);
      try {
        result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp)
      startOperation(cm);
    try {
      result = f();
    } finally {
      if (withOp)
        endOperation(cm);
    }
    return result;
  }
  function regChange(cm, from, to, lendiff) {
    if (from == null)
      from = cm.doc.first;
    if (to == null)
      to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({
      from: from,
      to: to,
      diff: lendiff
    });
  }
  // INPUT HANDLING
  function slowPoll(cm) {
    if (cm.display.pollingFast)
      return;
    cm.display.poll.set(cm.options.pollInterval, function () {
      readInput(cm);
      if (cm.state.focused)
        slowPoll(cm);
    });
  }
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {
        missed = true;
        cm.display.poll.set(60, p);
      } else {
        cm.display.pollingFast = false;
        slowPoll(cm);
      }
    }
    cm.display.poll.set(20, p);
  }
  // prevInput is a hack to work with IME. If we reset the textarea
  // on every change, that breaks IME. So we look for changes
  // compared to the previous content instead. (Modern browsers have
  // events that indicate IME taking place, but these are not widely
  // supported or compatible enough yet to rely on.)
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput)
      return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to))
      return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }
    var withOp = !cm.curOp;
    if (withOp)
      startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
      ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
    var updateInput = cm.curOp.updateInput;
    var changeEvent = {
        from: from,
        to: to,
        text: splitLines(text.slice(same)),
        origin: cm.state.pasteIncoming ? 'paste' : '+input'
      };
    makeChange(cm.doc, changeEvent, 'end');
    cm.curOp.updateInput = updateInput;
    signalLater(cm, 'inputRead', cm, changeEvent);
    if (text.length > 1000 || text.indexOf('\n') > -1)
      input.value = cm.display.prevInput = '';
    else
      cm.display.prevInput = text;
    if (withOp)
      endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }
  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = '';
      minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? '-' : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused)
        selectInput(cm.display.input);
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = '';
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }
  function focusInput(cm) {
    if (cm.options.readOnly != 'nocursor' && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }
  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }
  // EVENT HANDLERS
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, 'mousedown', operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, 'dblclick', operation(cm, function (e) {
        if (signalDOMEvent(cm, e))
          return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, 'dblclick', function (e) {
        signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    on(d.lineSpace, 'selectstart', function (e) {
      if (!eventInWidget(d, e))
        e_preventDefault(e);
    });
    // Gecko browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for Gecko.
    if (!captureMiddleClick)
      on(d.scroller, 'contextmenu', function (e) {
        onContextMenu(cm, e);
      });
    on(d.scroller, 'scroll', function () {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, 'scroll', cm);
      }
    });
    on(d.scrollbarV, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });
    on(d.scroller, 'mousewheel', function (e) {
      onScrollWheel(cm, e);
    });
    on(d.scroller, 'DOMMouseScroll', function (e) {
      onScrollWheel(cm, e);
    });
    function reFocus() {
      if (cm.state.focused)
        setTimeout(bind(focusInput, cm), 0);
    }
    on(d.scrollbarH, 'mousedown', reFocus);
    on(d.scrollbarV, 'mousedown', reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, 'scroll', function () {
      d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    var resizeTimer;
    function onResize() {
      if (resizeTimer == null)
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          // Might be a text scaling operation, clear size caches.
          d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
          clearCaches(cm);
          runInOp(cm, bind(regChange, cm));
        }, 100);
    }
    on(window, 'resize', onResize);
    // Above handler holds on to the editor and its data structures.
    // Here we poll to unregister it when the editor is no longer in
    // the document, so that it can be garbage-collected.
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {
      }
      if (p)
        setTimeout(unregister, 5000);
      else
        off(window, 'resize', onResize);
    }
    setTimeout(unregister, 5000);
    on(d.input, 'keyup', operation(cm, function (e) {
      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
        return;
      if (e.keyCode == 16)
        cm.doc.sel.shift = false;
    }));
    on(d.input, 'input', bind(fastPoll, cm));
    on(d.input, 'keydown', operation(cm, onKeyDown));
    on(d.input, 'keypress', operation(cm, onKeyPress));
    on(d.input, 'focus', bind(onFocus, cm));
    on(d.input, 'blur', bind(onBlur, cm));
    function drag_(e) {
      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
        return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, 'dragstart', function (e) {
        onDragStart(cm, e);
      });
      on(d.scroller, 'dragenter', drag_);
      on(d.scroller, 'dragover', drag_);
      on(d.scroller, 'drop', operation(cm, onDrop));
    }
    on(d.scroller, 'paste', function (e) {
      if (eventInWidget(d, e))
        return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, 'paste', function () {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });
    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = '';
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, 'cut', prepareCopy);
    on(d.input, 'copy', prepareCopy);
    // Needed to handle Tab key in KHTML
    if (khtml)
      on(d.sizer, 'mouseup', function () {
        if (document.activeElement == d.input)
          d.input.blur();
        focusInput(cm);
      });
  }
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover)
        return true;
    }
  }
  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller || target == display.gutterFiller)
        return null;
    }
    var x, y, space = getRect(display.lineSpace);
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try {
      x = e.clientX;
      y = e.clientY;
    } catch (e) {
      return null;
    }
    return coordsChar(cm, x - space.left, y - space.top);
  }
  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    if (signalDOMEvent(this, e))
      return;
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function () {
          display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e))
      return;
    var start = posFromMouse(cm, e);
    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick)
        onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start)
        extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    // For button 1, if it was clicked inside the editor
    // (posFromMouse returning non-null), we have to adjust the
    // selection.
    if (!start) {
      if (e_target(e) == display.scroller)
        e_preventDefault(e);
      return;
    }
    if (!cm.state.focused)
      onFocus(cm);
    var now = +new Date(), type = 'single';
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = 'triple';
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = 'double';
      lastDoubleClick = {
        time: now,
        pos: start
      };
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else {
      lastClick = {
        time: now,
        pos: start
      };
    }
    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == 'single') {
      var dragEnd = operation(cm, function (e2) {
          if (webkit)
            display.scroller.draggable = false;
          cm.state.draggingText = false;
          off(document, 'mouseup', dragEnd);
          off(display.scroller, 'drop', dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            extendSelection(cm.doc, start);
            focusInput(cm);
          }
        });
      // Let the drag handler handle this.
      if (webkit)
        display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      // IE's approach to draggable
      if (display.scroller.dragDrop)
        display.scroller.dragDrop();
      on(document, 'mouseup', dragEnd);
      on(display.scroller, 'drop', dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == 'single')
      extendSelection(cm.doc, clipPos(doc, start));
    var startstart = sel.from, startend = sel.to, lastPos = start;
    function doSelect(cur) {
      if (posEq(lastPos, cur))
        return;
      lastPos = cur;
      if (type == 'single') {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }
      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == 'double') {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart))
          extendSelection(cm.doc, word.from, startend);
        else
          extendSelection(cm.doc, startstart, word.to);
      } else if (type == 'triple') {
        if (posLess(cur, startstart))
          extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else
          extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }
    var editorSize = getRect(display.wrapper);
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur)
        return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused)
          onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function () {
            if (counter == curCount)
              extend(e);
          }), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside)
          setTimeout(operation(cm, function () {
            if (counter != curCount)
              return;
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
      }
    }
    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, 'mousemove', move);
      off(document, 'mouseup', up);
    }
    var move = operation(cm, function (e) {
        if (!ie && !e_button(e))
          done(e);
        else
          extend(e);
      });
    var up = operation(cm, done);
    on(document, 'mousemove', move);
    on(document, 'mouseup', up);
  }
  function clickInGutter(cm, e) {
    var display = cm.display;
    try {
      var mX = e.clientX, mY = e.clientY;
    } catch (e) {
      return false;
    }
    if (mX >= Math.floor(getRect(display.gutters).right))
      return false;
    e_preventDefault(e);
    if (!hasHandler(cm, 'gutterClick'))
      return true;
    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom)
      return true;
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, 'gutterClick', cm, line, gutter, e);
        break;
      }
    }
    return true;
  }
  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;
  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
      return;
    e_preventDefault(e);
    if (ie)
      lastDrop = +new Date();
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm))
      return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        var reader = new FileReader();
        reader.onload = function () {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {
              from: pos,
              to: pos,
              text: splitLines(text.join('\n')),
              origin: 'paste'
            }, 'around');
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i)
        loadFile(files[i], i);
    } else {
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData('Text');
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText)
            replaceRange(cm.doc, '', curFrom, curTo, 'paste');
          cm.replaceSelection(text, null, 'paste');
          focusInput(cm);
          onFocus(cm);
        }
      } catch (e) {
      }
    }
  }
  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    var txt = cm.getSelection();
    e.dataTransfer.setData('Text', txt);
    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera)
        img.parentNode.removeChild(img);
    }
  }
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2)
      return;
    cm.doc.scrollTop = val;
    if (!gecko)
      updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val)
      cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val)
      cm.display.scrollbarV.scrollTop = val;
    if (gecko)
      updateDisplay(cm, []);
    startWorker(cm, 100);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
      return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val)
      cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val)
      cm.display.scrollbarH.scrollLeft = val;
  }
  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie)
    wheelPixelsPerUnit = -0.53;
  else if (gecko)
    wheelPixelsPerUnit = 15;
  else if (chrome)
    wheelPixelsPerUnit = -0.7;
  else if (safari)
    wheelPixelsPerUnit = -1 / 3;
  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
      dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
      dy = e.detail;
    else if (dy == null)
      dy = e.wheelDelta;
    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
      return;
    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }
    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null;
      // Abort measurement, if in progress
      return;
    }
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0)
        top = Math.max(0, top + pixels - 50);
      else
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null)
            return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample)
            return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == 'string') {
      bound = commands[bound];
      if (!bound)
        return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm))
      cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm))
        cm.state.suppressEdits = true;
      if (dropShift)
        doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys)
      maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }
  var maybeTransition;
  function handleKeyBinding(cm, e) {
    // Handle auto keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e))
      maybeTransition = setTimeout(function () {
        if (getKeyMap(cm.options.keyMap) == startMap) {
          cm.options.keyMap = next.call ? next.call(null, cm) : next;
          keyMapChanged(cm);
        }
      }, 50);
    var name = keyName(e, true), handled = false;
    if (!name)
      return false;
    var keymaps = allKeyMaps(cm);
    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey('Shift-' + name, keymaps, function (b) {
        return doHandleBinding(cm, b, true);
      }) || lookupKey(name, keymaps, function (b) {
        if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion)
          return doHandleBinding(cm, b);
      });
    } else {
      handled = lookupKey(name, keymaps, function (b) {
        return doHandleBinding(cm, b);
      });
    }
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) {
        e.oldKeyCode = e.keyCode;
        e.keyCode = 0;
      }
      signalLater(cm, 'keyHandled', cm, name, e);
    }
    return handled;
  }
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
        return doHandleBinding(cm, b, true);
      });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, 'keyHandled', cm, '\'' + ch + '\'', e);
    }
    return handled;
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused)
      onFocus(cm);
    if (ie && e.keyCode == 27) {
      e.returnValue = false;
    }
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var code = e.keyCode;
    // IE does strange things with escape.
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    // First give onKeyEvent option a chance to handle this.
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection('');
    }
  }
  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
      return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function () {
        indentLine(cm, cm.doc.sel.to.line, 'smart');
      }), 75);
    if (handleCharBinding(cm, e, ch))
      return;
    if (ie && !ie_lt9)
      cm.display.inputHasSelection = null;
    fastPoll(cm);
  }
  function onFocus(cm) {
    if (cm.options.readOnly == 'nocursor')
      return;
    if (!cm.state.focused) {
      signal(cm, 'focus', cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += ' CodeMirror-focused';
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, 'blur', cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-focused', '');
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused)
        cm.doc.sel.shift = false;
    }, 150);
  }
  var detectingSelectAll;
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, 'contextmenu'))
      return;
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e))
      return;
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera)
      return;
    // Opera is difficult.
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);
    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = 'absolute';
    display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: white; outline: none;' + 'border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);';
    focusInput(cm);
    resetInput(cm, true);
    // Adds "Select all" to context menu in FF
    if (posEq(sel.from, sel.to))
      display.input.value = display.prevInput = ' ';
    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var extval = display.input.value = ' ' + (posEq(sel.from, sel.to) ? '' : display.input.value);
        display.prevInput = ' ';
        display.input.selectionStart = 1;
        display.input.selectionEnd = extval.length;
      }
    }
    function rehide() {
      display.inputDiv.style.position = 'relative';
      display.input.style.cssText = oldCSS;
      if (ie_lt9)
        display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);
      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_lt9)
          prepareSelectAllHack();
        clearTimeout(detectingSelectAll);
        var i = 0, poll = function () {
            if (display.prevInput == ' ' && display.input.selectionStart == 0)
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10)
              detectingSelectAll = setTimeout(poll, 500);
            else
              resetInput(cm);
          };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (ie && !ie_lt9)
      prepareSelectAllHack();
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, 'mouseup', mouseup);
        setTimeout(rehide, 20);
      };
      on(window, 'mouseup', mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }
  // UPDATING
  var changeEnd = CodeMirror.changeEnd = function (change) {
      if (!change.text)
        return change.to;
      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    };
  // Make sure a position will be valid after the given change.
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos))
      return clipPos(doc, pos);
    var diff = change.text.length - 1 - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine)
        return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }
  // Hint can be null|"end"|"start"|"around"|{anchor,head}
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == 'object')
      // Assumed to be {anchor, head} object
      return {
        anchor: clipPostChange(doc, change, hint.anchor),
        head: clipPostChange(doc, change, hint.head)
      };
    if (hint == 'start')
      return {
        anchor: change.from,
        head: change.from
      };
    var end = changeEnd(change);
    if (hint == 'around')
      return {
        anchor: change.from,
        head: end
      };
    if (hint == 'end')
      return {
        anchor: end,
        head: end
      };
    // hint is null, leave the selection alone as much as possible
    var adjustPos = function (pos) {
      if (posLess(pos, change.from))
        return pos;
      if (!posLess(change.to, pos))
        return end;
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line)
        ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {
      anchor: adjustPos(doc.sel.anchor),
      head: adjustPos(doc.sel.head)
    };
  }
  function filterChange(doc, change, update) {
    var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function () {
          this.canceled = true;
        }
      };
    if (update)
      obj.update = function (from, to, text, origin) {
        if (from)
          this.from = clipPos(doc, from);
        if (to)
          this.to = clipPos(doc, to);
        if (text)
          this.text = text;
        if (origin !== undefined)
          this.origin = origin;
      };
    signal(doc, 'beforeChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeChange', doc.cm, obj);
    if (obj.canceled)
      return null;
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }
  // Replace the range from from to to by the strings in replacement.
  // change is a {from, to, text [, origin]} object
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp)
        return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits)
        return;
    }
    if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
      change = filterChange(doc, change, true);
      if (!change)
        return;
    }
    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {
          from: split[i].from,
          to: split[i].to,
          text: ['']
        });
      if (split.length)
        makeChangeNoReadonly(doc, {
          from: split[0].from,
          to: split[0].to,
          text: change.text
        }, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }
  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }
  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits)
      return;
    var hist = doc.history;
    var event = (type == 'undo' ? hist.done : hist.undone).pop();
    if (!event)
      return;
    var anti = {
        changes: [],
        anchorBefore: event.anchorAfter,
        headBefore: event.headAfter,
        anchorAfter: event.anchorBefore,
        headAfter: event.headBefore,
        generation: hist.generation
      };
    (type == 'undo' ? hist.undone : hist.done).push(anti);
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange');
    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        (type == 'undo' ? hist.done : hist.undone).length = 0;
        return;
      }
      anti.changes.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change, null) : {
          anchor: event.anchorBefore,
          head: event.headBefore
        };
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }
  function shiftDoc(doc, distance) {
    function shiftPos(pos) {
      return Pos(pos.line + distance, pos.ch);
    }
    doc.first += distance;
    if (doc.cm)
      regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head);
    doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from);
    doc.sel.to = shiftPos(doc.sel.to);
  }
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine())
      return;
    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter)
      selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm)
      makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else
      updateDoc(doc, change, spans, selAfter);
  }
  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;
    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength)
        cm.curOp.updateMaxLine = true;
    }
    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    regChange(cm, from.line, to.line + 1, lendiff);
    if (hasHandler(cm, 'change')) {
      var changeObj = {
          from: from,
          to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {
        }
        cur.next = changeObj;
      } else
        cm.curOp.textChanged = changeObj;
    }
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to)
      to = from;
    if (posLess(to, from)) {
      var tmp = to;
      to = from;
      from = tmp;
    }
    if (typeof code == 'string')
      code = splitLines(code);
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    }, null);
  }
  // POSITION OBJECT
  function Pos(line, ch) {
    if (!(this instanceof Pos))
      return new Pos(line, ch);
    this.line = line;
    this.ch = ch;
  }
  CodeMirror.Pos = Pos;
  function posEq(a, b) {
    return a.line == b.line && a.ch == b.ch;
  }
  function posLess(a, b) {
    return a.line < b.line || a.line == b.line && a.ch < b.ch;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  // SELECTION
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first)
      return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last)
      return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen)
      return Pos(pos.line, linelen);
    else if (ch < 0)
      return Pos(pos.line, 0);
    else
      return pos;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  // If shift is held, this will move the selection anchor. Otherwise,
  // it'll set the whole selection.
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm)
      doc.cm.curOp.userSelChange = true;
  }
  function filterSelectionChange(doc, anchor, head) {
    var obj = {
        anchor: anchor,
        head: head
      };
    signal(doc, 'beforeSelectionChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor);
    obj.head = clipPos(doc, obj.head);
    return obj;
  }
  // Update the selection. Last two args are only used by
  // updateDoc, since they have to be expressed in the line
  // numbers before the update.
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }
    var sel = doc.sel;
    sel.goalColumn = null;
    // Skip over atomic spans.
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != 'push');
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != 'push');
    if (posEq(sel.anchor, anchor) && posEq(sel.head, head))
      return;
    sel.anchor = anchor;
    sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;
    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;
    signalLater(doc, 'cursorActivity', doc);
  }
  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, 'push');
  }
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search:
      for (;;) {
        var line = getLine(doc, curPos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
              if (mayClear) {
                signal(m, 'beforeCursorEnter');
                if (m.explicitlyCleared) {
                  if (!line.markedSpans)
                    break;
                  else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic)
                continue;
              var newPos = m.find()[dir < 0 ? 'from' : 'to'];
              if (posEq(newPos, curPos)) {
                newPos.ch += dir;
                if (newPos.ch < 0) {
                  if (newPos.line > doc.first)
                    newPos = clipPos(doc, Pos(newPos.line - 1));
                  else
                    newPos = null;
                } else if (newPos.ch > line.text.length) {
                  if (newPos.line < doc.first + doc.size - 1)
                    newPos = Pos(newPos.line + 1, 0);
                  else
                    newPos = null;
                }
                if (!newPos) {
                  if (flipped) {
                    // Driven in a corner -- no valid cursor position found at all
                    // -- try again *with* clearing, if we didn't already
                    if (!mayClear)
                      return skipAtomic(doc, pos, bias, true);
                    // Otherwise, turn off editing until further notice, and return the start of the doc
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                  }
                  flipped = true;
                  newPos = pos;
                  dir = -dir;
                }
              }
              curPos = newPos;
              continue search;
            }
          }
        }
        return curPos;
      }
  }
  // SCROLLING
  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head, cm.options.cursorScrollMargin);
    if (!cm.state.focused)
      return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null;
    if (coords.top + box.top < 0)
      doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
      doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == 'none';
      if (hidden) {
        display.cursor.style.display = '';
        display.cursor.style.left = coords.left + 'px';
        display.cursor.style.top = coords.top - display.viewOffset + 'px';
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden)
        display.cursor.style.display = 'none';
    }
  }
  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null)
      margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1)
          changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
          changed = true;
      }
      if (!changed)
        return coords;
    }
  }
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null)
      setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null)
      setScrollLeft(cm, scrollPos.scrollLeft);
  }
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0)
      y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop)
        result.scrollTop = newTop;
    }
    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth;
    x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft)
        x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }
  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {
      scrollLeft: left == null ? cm.doc.scrollLeft : left,
      scrollTop: top == null ? cm.doc.scrollTop : top
    };
  }
  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
        scrollLeft: cm.doc.scrollLeft,
        scrollTop: cm.doc.scrollTop
      });
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }
  // API UTILITIES
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (how == null)
      how = 'add';
    if (how == 'smart') {
      if (!cm.doc.mode.indent)
        how = 'prev';
      else
        var state = getStateBefore(cm, n);
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == 'smart') {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive)
          return;
        how = 'prev';
      }
    }
    if (how == 'prev') {
      if (n > doc.first)
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      else
        indentation = 0;
    } else if (how == 'add') {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == 'subtract') {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == 'number') {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);
    var indentString = '', pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += '\t';
      }
    if (pos < indentation)
      indentString += spaceStr(indentation - pos);
    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
    line.stateAfter = null;
  }
  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == 'number')
      line = getLine(doc, clipLine(doc, handle));
    else
      no = lineNo(handle);
    if (no == null)
      return null;
    if (op(line, no))
      regChange(cm, no, no + 1);
    else
      return null;
    return line;
  }
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size)
        return possible = false;
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually)
            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else
            ch = dir < 0 ? lineObj.text.length : 0;
        } else
          return possible = false;
      } else
        ch = next;
      return true;
    }
    if (unit == 'char')
      moveOnce();
    else if (unit == 'column')
      moveOnce(true);
    else if (unit == 'word' || unit == 'group') {
      var sawType = null, group = unit == 'group';
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first))
          break;
        var cur = lineObj.text.charAt(ch) || '\n';
        var type = isWordChar(cur) ? 'w' : !group ? null : /\s/.test(cur) ? null : 'p';
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
          }
          break;
        }
        if (type)
          sawType = type;
        if (dir > 0 && !moveOnce(!first))
          break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible)
      result.hitSide = true;
    return result;
  }
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == 'page') {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
    } else if (unit == 'line') {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside)
        break;
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if ((pos.xRel < 0 || end == line.length) && start)
        --start;
      else
        ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
          return /\s/.test(ch);
        } : function (ch) {
          return !/\s/.test(ch) && !isWordChar(ch);
        };
      while (start > 0 && check(line.charAt(start - 1)))
        --start;
      while (end < line.length && check(line.charAt(end)))
        ++end;
    }
    return {
      from: Pos(pos.line, start),
      to: Pos(pos.line, end)
    };
  }
  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }
  // PROTOTYPE
  // The publicly visible API. Note that operation(null, f) means
  // 'wrap f in an operation, performed on its `this` parameter'
  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function () {
      window.focus();
      focusInput(this);
      onFocus(this);
      fastPoll(this);
    },
    setOption: function (option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != 'mode')
        return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },
    getOption: function (option) {
      return this.options[option];
    },
    getDoc: function () {
      return this.doc;
    },
    addKeyMap: function (map, bottom) {
      this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
    },
    removeKeyMap: function (map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || typeof maps[i] != 'string' && maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },
    addOverlay: operation(null, function (spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState)
        throw new Error('Overlays may not be stateful.');
      this.state.overlays.push({
        mode: mode,
        modeSpec: spec,
        opaque: options && options.opaque
      });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function (spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == 'string' && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),
    indentLine: operation(null, function (n, dir, aggressive) {
      if (typeof dir != 'string' && typeof dir != 'number') {
        if (dir == null)
          dir = this.options.smartIndent ? 'smart' : 'prev';
        else
          dir = dir ? 'add' : 'subtract';
      }
      if (isLine(this.doc, n))
        indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function (how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to))
        return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i)
        indentLine(this, i, how);
    }),
    getTokenAt: function (pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {
        start: stream.start,
        end: stream.pos,
        string: stream.current(),
        className: style || null,
        type: style || null,
        state: state
      };
    },
    getTokenTypeAt: function (pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      if (ch == 0)
        return styles[2];
      for (;;) {
        var mid = before + after >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
          after = mid;
        else if (styles[mid * 2 + 1] < ch)
          before = mid + 1;
        else
          return styles[mid * 2 + 2];
      }
    },
    getModeAt: function (pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode)
        return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },
    getHelper: function (pos, type) {
      if (!helpers.hasOwnProperty(type))
        return;
      var help = helpers[type], mode = this.getModeAt(pos);
      return mode[type] && help[mode[type]] || mode.helperType && help[mode.helperType] || help[mode.name];
    },
    getStateAfter: function (line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
      return getStateBefore(this, line + 1, precise);
    },
    cursorCoords: function (start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null)
        pos = sel.head;
      else if (typeof start == 'object')
        pos = clipPos(this.doc, start);
      else
        pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || 'page');
    },
    charCoords: function (pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || 'page');
    },
    coordsChar: function (coords, mode) {
      coords = fromCoordSystem(this, coords, mode || 'page');
      return coordsChar(this, coords.left, coords.top);
    },
    lineAtHeight: function (height, mode) {
      height = fromCoordSystem(this, {
        top: height,
        left: 0
      }, mode || 'page').top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function (line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first)
        line = this.doc.first;
      else if (line > last) {
        line = last;
        end = true;
      }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, getLine(this.doc, line), {
        top: 0,
        left: 0
      }, mode || 'page').top + (end ? lineObj.height : 0);
    },
    defaultTextHeight: function () {
      return textHeight(this.display);
    },
    defaultCharWidth: function () {
      return charWidth(this.display);
    },
    setGutterMarker: operation(null, function (line, gutterID, value) {
      return changeLine(this, line, function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers))
          line.gutterMarkers = null;
        return true;
      });
    }),
    clearGutter: operation(null, function (gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers))
            line.gutterMarkers = null;
        }
        ++i;
      });
    }),
    addLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        if (!line[prop])
          line[prop] = cls;
        else if (new RegExp('(?:^|\\s)' + cls + '(?:$|\\s)').test(line[prop]))
          return false;
        else
          line[prop] += ' ' + cls;
        return true;
      });
    }),
    removeLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        var cur = line[prop];
        if (!cur)
          return false;
        else if (cls == null)
          line[prop] = null;
        else {
          var found = cur.match(new RegExp('(?:^|\\s+)' + cls + '(?:$|\\s+)'));
          if (!found)
            return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;
        }
        return true;
      });
    }),
    addLineWidget: operation(null, function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    lineInfo: function (line) {
      if (typeof line == 'number') {
        if (!isLine(this.doc, line))
          return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line)
          return null;
      } else {
        var n = lineNo(line);
        if (n == null)
          return null;
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    getViewport: function () {
      return {
        from: this.display.showingFrom,
        to: this.display.showingTo
      };
    },
    addWidget: function (pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = 'absolute';
      display.sizer.appendChild(node);
      if (vert == 'over') {
        top = pos.top;
      } else if (vert == 'above' || vert == 'near') {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + 'px';
      node.style.left = node.style.right = '';
      if (horiz == 'right') {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = '0px';
      } else {
        if (horiz == 'left')
          left = 0;
        else if (horiz == 'middle')
          left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + 'px';
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },
    triggerOnKeyDown: operation(null, onKeyDown),
    execCommand: function (cmd) {
      return commands[cmd](this);
    },
    findPosH: function (from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveH: operation(null, function (dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),
    deleteH: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to))
        replaceRange(this.doc, '', sel.from, sel.to, '+delete');
      else
        replaceRange(this.doc, '', sel.from, findPosH(this.doc, sel.head, dir, unit, false), '+delete');
      this.curOp.userSelChange = true;
    }),
    findPosV: function (from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, 'div');
        if (x == null)
          x = coords.left;
        else
          coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveV: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, 'div');
      if (sel.goalColumn != null)
        pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);
      if (unit == 'page')
        addToScrollPos(this, 0, charCoords(this, target, 'div').top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),
    toggleOverwrite: function (value) {
      if (value != null && value == this.state.overwrite)
        return;
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += ' CodeMirror-overwrite';
      else
        this.display.cursor.className = this.display.cursor.className.replace(' CodeMirror-overwrite', '');
    },
    hasFocus: function () {
      return this.state.focused;
    },
    scrollTo: operation(null, function (x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function () {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - co,
        width: scroller.scrollWidth - co,
        clientHeight: scroller.clientHeight - co,
        clientWidth: scroller.clientWidth - co
      };
    },
    scrollIntoView: operation(null, function (pos, margin) {
      if (typeof pos == 'number')
        pos = Pos(pos, 0);
      if (!margin)
        margin = 0;
      var coords = pos;
      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),
    setSize: operation(null, function (width, height) {
      function interpret(val) {
        return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
      }
      if (width != null)
        this.display.wrapper.style.width = interpret(width);
      if (height != null)
        this.display.wrapper.style.height = interpret(height);
      if (this.options.lineWrapping)
        this.display.measureLineCache.length = this.display.measureLineCachePos = 0;
      this.curOp.forceUpdate = true;
    }),
    operation: function (f) {
      return runInOp(this, f);
    },
    refresh: operation(null, function () {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),
    swapDoc: operation(null, function (doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),
    getInputField: function () {
      return this.display.input;
    },
    getWrapperElement: function () {
      return this.display.wrapper;
    },
    getScrollerElement: function () {
      return this.display.scroller;
    },
    getGutterElement: function () {
      return this.display.gutters;
    }
  };
  eventMixin(CodeMirror);
  // OPTION DEFAULTS
  var optionHandlers = CodeMirror.optionHandlers = {};
  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle)
      optionHandlers[name] = notOnInit ? function (cm, val, old) {
        if (old != Init)
          handle(cm, val, old);
      } : handle;
  }
  var Init = CodeMirror.Init = {
      toString: function () {
        return 'CodeMirror.Init';
      }
    };
  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option('value', '', function (cm, val) {
    cm.setValue(val);
  }, true);
  option('mode', null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);
  option('indentUnit', 2, loadMode, true);
  option('indentWithTabs', false);
  option('smartIndent', true);
  option('tabSize', 4, function (cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option('electricChars', true);
  option('rtlMoveVisually', !windows);
  option('theme', 'default', function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option('keyMap', 'default', keyMapChanged);
  option('extraKeys', null);
  option('onKeyEvent', null);
  option('onDragEvent', null);
  option('lineWrapping', false, wrappingChanged, true);
  option('gutters', [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('fixedGutter', true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
    cm.refresh();
  }, true);
  option('coverGutterNextToScrollbar', false, updateScrollbars, true);
  option('lineNumbers', false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('firstLineNumber', 1, guttersChanged, true);
  option('lineNumberFormatter', function (integer) {
    return integer;
  }, guttersChanged, true);
  option('showCursorWhenSelecting', false, updateSelection, true);
  option('readOnly', false, function (cm, val) {
    if (val == 'nocursor') {
      onBlur(cm);
      cm.display.input.blur();
    } else if (!val)
      resetInput(cm, true);
  });
  option('dragDrop', true);
  option('cursorBlinkRate', 530);
  option('cursorScrollMargin', 0);
  option('cursorHeight', 1);
  option('workTime', 100);
  option('workDelay', 100);
  option('flattenSpans', true);
  option('pollInterval', 100);
  option('undoDepth', 40, function (cm, val) {
    cm.doc.history.undoDepth = val;
  });
  option('historyEventDelay', 500);
  option('viewportMargin', 10, function (cm) {
    cm.refresh();
  }, true);
  option('maxHighlightLength', 10000, function (cm) {
    loadMode(cm);
    cm.refresh();
  }, true);
  option('moveInputWithCursor', true, function (cm, val) {
    if (!val)
      cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });
  option('tabindex', null, function (cm, val) {
    cm.display.input.tabIndex = val || '';
  });
  option('autofocus', null);
  // MODE DEFINITION AND QUERYING
  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
  CodeMirror.defineMode = function (name, mode) {
    if (!CodeMirror.defaults.mode && name != 'null')
      CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i)
        mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };
  CodeMirror.defineMIME = function (mime, spec) {
    mimeModes[mime] = spec;
  };
  CodeMirror.resolveMode = function (spec) {
    if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode('application/xml');
    }
    if (typeof spec == 'string')
      return { name: spec };
    else
      return spec || { name: 'null' };
  };
  CodeMirror.getMode = function (options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory)
      return CodeMirror.getMode(options, 'text/plain');
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop))
          continue;
        if (modeObj.hasOwnProperty(prop))
          modeObj['_' + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    return modeObj;
  };
  CodeMirror.defineMode('null', function () {
    return {
      token: function (stream) {
        stream.skipToEnd();
      }
    };
  });
  CodeMirror.defineMIME('text/plain', 'null');
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function (mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  };
  // EXTENSIONS
  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;
  var initHooks = [];
  CodeMirror.defineInitHook = function (f) {
    initHooks.push(f);
  };
  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function (type, name, value) {
    if (!helpers.hasOwnProperty(type))
      helpers[type] = CodeMirror[type] = {};
    helpers[type][name] = value;
  };
  // UTILITIES
  CodeMirror.isWordChar = isWordChar;
  // MODE STATE HANDLING
  // Utility functions for working with state. Exported because modes
  // sometimes need to do this.
  function copyState(mode, state) {
    if (state === true)
      return state;
    if (mode.copyState)
      return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array)
        val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;
  CodeMirror.innerMode = function (mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode)
        break;
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  };
  // STANDARD COMMANDS
  var commands = CodeMirror.commands = {
      selectAll: function (cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
      },
      killLine: function (cm) {
        var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
        if (!sel && cm.getLine(from.line).length == from.ch)
          cm.replaceRange('', from, Pos(from.line + 1, 0), '+delete');
        else
          cm.replaceRange('', from, sel ? to : Pos(from.line), '+delete');
      },
      deleteLine: function (cm) {
        var l = cm.getCursor().line;
        cm.replaceRange('', Pos(l, 0), Pos(l), '+delete');
      },
      delLineLeft: function (cm) {
        var cur = cm.getCursor();
        cm.replaceRange('', Pos(cur.line, 0), cur, '+delete');
      },
      undo: function (cm) {
        cm.undo();
      },
      redo: function (cm) {
        cm.redo();
      },
      goDocStart: function (cm) {
        cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function (cm) {
        cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function (cm) {
        cm.extendSelection(lineStart(cm, cm.getCursor().line));
      },
      goLineStartSmart: function (cm) {
        var cur = cm.getCursor(), start = lineStart(cm, cur.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
          cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
        } else
          cm.extendSelection(start);
      },
      goLineEnd: function (cm) {
        cm.extendSelection(lineEnd(cm, cm.getCursor().line));
      },
      goLineRight: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, 'div'));
      },
      goLineLeft: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: 0,
          top: top
        }, 'div'));
      },
      goLineUp: function (cm) {
        cm.moveV(-1, 'line');
      },
      goLineDown: function (cm) {
        cm.moveV(1, 'line');
      },
      goPageUp: function (cm) {
        cm.moveV(-1, 'page');
      },
      goPageDown: function (cm) {
        cm.moveV(1, 'page');
      },
      goCharLeft: function (cm) {
        cm.moveH(-1, 'char');
      },
      goCharRight: function (cm) {
        cm.moveH(1, 'char');
      },
      goColumnLeft: function (cm) {
        cm.moveH(-1, 'column');
      },
      goColumnRight: function (cm) {
        cm.moveH(1, 'column');
      },
      goWordLeft: function (cm) {
        cm.moveH(-1, 'word');
      },
      goGroupRight: function (cm) {
        cm.moveH(1, 'group');
      },
      goGroupLeft: function (cm) {
        cm.moveH(-1, 'group');
      },
      goWordRight: function (cm) {
        cm.moveH(1, 'word');
      },
      delCharBefore: function (cm) {
        cm.deleteH(-1, 'char');
      },
      delCharAfter: function (cm) {
        cm.deleteH(1, 'char');
      },
      delWordBefore: function (cm) {
        cm.deleteH(-1, 'word');
      },
      delWordAfter: function (cm) {
        cm.deleteH(1, 'word');
      },
      delGroupBefore: function (cm) {
        cm.deleteH(-1, 'group');
      },
      delGroupAfter: function (cm) {
        cm.deleteH(1, 'group');
      },
      indentAuto: function (cm) {
        cm.indentSelection('smart');
      },
      indentMore: function (cm) {
        cm.indentSelection('add');
      },
      indentLess: function (cm) {
        cm.indentSelection('subtract');
      },
      insertTab: function (cm) {
        cm.replaceSelection('\t', 'end', '+input');
      },
      defaultTab: function (cm) {
        if (cm.somethingSelected())
          cm.indentSelection('add');
        else
          cm.replaceSelection('\t', 'end', '+input');
      },
      transposeChars: function (cm) {
        var cur = cm.getCursor(), line = cm.getLine(cur.line);
        if (cur.ch > 0 && cur.ch < line.length - 1)
          cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
      },
      newlineAndIndent: function (cm) {
        operation(cm, function () {
          cm.replaceSelection('\n', 'end', '+input');
          cm.indentLine(cm.getCursor().line, null, true);
        })();
      },
      toggleOverwrite: function (cm) {
        cm.toggleOverwrite();
      }
    };
  // STANDARD KEYMAPS
  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    'Left': 'goCharLeft',
    'Right': 'goCharRight',
    'Up': 'goLineUp',
    'Down': 'goLineDown',
    'End': 'goLineEnd',
    'Home': 'goLineStartSmart',
    'PageUp': 'goPageUp',
    'PageDown': 'goPageDown',
    'Delete': 'delCharAfter',
    'Backspace': 'delCharBefore',
    'Tab': 'defaultTab',
    'Shift-Tab': 'indentAuto',
    'Enter': 'newlineAndIndent',
    'Insert': 'toggleOverwrite'
  };
  // Note that the save and find-related commands aren't defined by
  // default. Unknown commands are simply ignored.
  keyMap.pcDefault = {
    'Ctrl-A': 'selectAll',
    'Ctrl-D': 'deleteLine',
    'Ctrl-Z': 'undo',
    'Shift-Ctrl-Z': 'redo',
    'Ctrl-Y': 'redo',
    'Ctrl-Home': 'goDocStart',
    'Alt-Up': 'goDocStart',
    'Ctrl-End': 'goDocEnd',
    'Ctrl-Down': 'goDocEnd',
    'Ctrl-Left': 'goGroupLeft',
    'Ctrl-Right': 'goGroupRight',
    'Alt-Left': 'goLineStart',
    'Alt-Right': 'goLineEnd',
    'Ctrl-Backspace': 'delGroupBefore',
    'Ctrl-Delete': 'delGroupAfter',
    'Ctrl-S': 'save',
    'Ctrl-F': 'find',
    'Ctrl-G': 'findNext',
    'Shift-Ctrl-G': 'findPrev',
    'Shift-Ctrl-F': 'replace',
    'Shift-Ctrl-R': 'replaceAll',
    'Ctrl-[': 'indentLess',
    'Ctrl-]': 'indentMore',
    fallthrough: 'basic'
  };
  keyMap.macDefault = {
    'Cmd-A': 'selectAll',
    'Cmd-D': 'deleteLine',
    'Cmd-Z': 'undo',
    'Shift-Cmd-Z': 'redo',
    'Cmd-Y': 'redo',
    'Cmd-Up': 'goDocStart',
    'Cmd-End': 'goDocEnd',
    'Cmd-Down': 'goDocEnd',
    'Alt-Left': 'goGroupLeft',
    'Alt-Right': 'goGroupRight',
    'Cmd-Left': 'goLineStart',
    'Cmd-Right': 'goLineEnd',
    'Alt-Backspace': 'delGroupBefore',
    'Ctrl-Alt-Backspace': 'delGroupAfter',
    'Alt-Delete': 'delGroupAfter',
    'Cmd-S': 'save',
    'Cmd-F': 'find',
    'Cmd-G': 'findNext',
    'Shift-Cmd-G': 'findPrev',
    'Cmd-Alt-F': 'replace',
    'Shift-Cmd-Alt-F': 'replaceAll',
    'Cmd-[': 'indentLess',
    'Cmd-]': 'indentMore',
    'Cmd-Backspace': 'delLineLeft',
    fallthrough: [
      'basic',
      'emacsy'
    ]
  };
  keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    'Ctrl-F': 'goCharRight',
    'Ctrl-B': 'goCharLeft',
    'Ctrl-P': 'goLineUp',
    'Ctrl-N': 'goLineDown',
    'Alt-F': 'goWordRight',
    'Alt-B': 'goWordLeft',
    'Ctrl-A': 'goLineStart',
    'Ctrl-E': 'goLineEnd',
    'Ctrl-V': 'goPageDown',
    'Shift-Ctrl-V': 'goPageUp',
    'Ctrl-D': 'delCharAfter',
    'Ctrl-H': 'delCharBefore',
    'Alt-D': 'delWordAfter',
    'Alt-Backspace': 'delWordBefore',
    'Ctrl-K': 'killLine',
    'Ctrl-T': 'transposeChars'
  };
  // KEYMAP DISPATCH
  function getKeyMap(val) {
    if (typeof val == 'string')
      return keyMap[val];
    else
      return val;
  }
  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false)
        return 'stop';
      if (found != null && handle(found))
        return true;
      if (map.nofallthrough)
        return 'stop';
      var fallthrough = map.fallthrough;
      if (fallthrough == null)
        return false;
      if (Object.prototype.toString.call(fallthrough) != '[object Array]')
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done)
          return done;
      }
      return false;
    }
    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done)
        return done != 'stop';
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event['char'])
      return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey)
      return false;
    if (event.altKey)
      name = 'Alt-' + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
      name = 'Ctrl-' + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
      name = 'Cmd-' + name;
    if (!noShift && event.shiftKey)
      name = 'Shift-' + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;
  // FROMTEXTAREA
  CodeMirror.fromTextArea = function (textarea, options) {
    if (!options)
      options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = document.body;
      // doc.activeElement occasionally throws on IE
      try {
        hasFocus = document.activeElement;
      } catch (e) {
      }
      options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    if (textarea.form) {
      on(textarea.form, 'submit', save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
        } catch (e) {
        }
      }
    }
    textarea.style.display = 'none';
    var cm = CodeMirror(function (node) {
        textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
    cm.save = save;
    cm.getTextArea = function () {
      return textarea;
    };
    cm.toTextArea = function () {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = '';
      if (textarea.form) {
        off(textarea.form, 'submit', save);
        if (typeof textarea.form.submit == 'function')
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };
  // STRING STREAM
  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.
  // The character stream used by a mode's parser.
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }
  StringStream.prototype = {
    eol: function () {
      return this.pos >= this.string.length;
    },
    sol: function () {
      return this.pos == 0;
    },
    peek: function () {
      return this.string.charAt(this.pos) || undefined;
    },
    next: function () {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function (match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == 'string')
        var ok = ch == match;
      else
        var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {
        ++this.pos;
        return ch;
      }
    },
    eatWhile: function (match) {
      var start = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start;
    },
    eatSpace: function () {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
        ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function () {
      this.pos = this.string.length;
    },
    skipTo: function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    },
    backUp: function (n) {
      this.pos -= n;
    },
    column: function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function () {
      return countColumn(this.string, null, this.tabSize);
    },
    match: function (pattern, consume, caseInsensitive) {
      if (typeof pattern == 'string') {
        var cased = function (str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false)
            this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0)
          return null;
        if (match && consume !== false)
          this.pos += match[0].length;
        return match;
      }
    },
    current: function () {
      return this.string.slice(this.start, this.pos);
    }
  };
  CodeMirror.StringStream = StringStream;
  // TEXTMARKERS
  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;
  eventMixin(TextMarker);
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp)
      startOperation(cm);
    if (hasHandler(this, 'clear')) {
      var found = this.find();
      if (found)
        signalLater(this, 'clear', found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null)
        max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping)
      for (var i = 0; i < this.lines.length; ++i) {
        var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    if (min != null && cm)
      regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm)
        reCheckSelection(cm);
    }
    if (withOp)
      endOperation(cm);
  };
  TextMarker.prototype.find = function () {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null)
          from = Pos(found, span.from);
        if (span.to != null)
          to = Pos(found, span.to);
      }
    }
    if (this.type == 'bookmark')
      return from;
    return from && {
      from: from,
      to: to
    };
  };
  TextMarker.prototype.changed = function () {
    var pos = this.find(), cm = this.doc.cm;
    if (!pos || !cm)
      return;
    var line = getLine(this.doc, pos.from.line);
    clearCachedMeasurement(cm, line);
    if (pos.from.line >= cm.display.showingFrom && pos.from.line < cm.display.showingTo) {
      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling)
        if (node.lineObj == line) {
          if (node.offsetHeight != line.height)
            updateLineHeight(line, node.offsetHeight);
          break;
        }
      runInOp(cm, function () {
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;
      });
    }
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  function markText(doc, from, to, options, type) {
    if (options && options.shared)
      return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, markText)(doc, from, to, options, type);
    var marker = new TextMarker(doc, type);
    if (type == 'range' && !posLess(from, to))
      return marker;
    if (options)
      copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt('span', [marker.replacedWith], 'CodeMirror-widget');
      if (!options.handleMouseEvents)
        marker.replacedWith.ignoreEvents = true;
    }
    if (marker.collapsed)
      sawCollapsedSpans = true;
    if (marker.addToHistory)
      addToHistory(doc, {
        from: from,
        to: to,
        origin: 'markText'
      }, {
        head: doc.sel.head,
        anchor: doc.sel.anchor
      }, NaN);
    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {
          from: null,
          to: null,
          marker: marker
        };
      size += line.text.length;
      if (curLine == from.line) {
        span.from = from.ch;
        size -= from.ch;
      }
      if (curLine == to.line) {
        span.to = to.ch;
        size -= line.text.length - to.ch;
      }
      if (marker.collapsed) {
        if (curLine == to.line)
          collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line)
          collapsedAtStart = collapsedSpanAt(line, from.ch);
        else
          updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed)
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line))
          updateLineHeight(line, 0);
      });
    if (marker.clearOnEnter)
      on(marker, 'beforeCursorEnter', function () {
        marker.clear();
      });
    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error('Inserting collapsed marker overlapping an existing one');
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine)
        cm.curOp.updateMaxLine = true;
      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic)
        reCheckSelection(cm);
    }
    return marker;
  }
  // SHARED TEXTMARKERS
  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], 'clear', function () {
        me.clear();
      });
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;
  eventMixin(SharedTextMarker);
  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, 'clear');
  };
  SharedTextMarker.prototype.find = function () {
    return this.primary.find();
  };
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function (doc) {
      if (widget)
        options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent)
          return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  // TEXTMARKER SPANS
  function getMarkedSpanFor(spans, marker) {
    if (spans)
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker)
          return span;
      }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span)
        (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }
  function markedSpansBefore(old, startCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || marker.type == 'bookmark' && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push({
            from: span.from,
            to: endsAfter ? null : span.to,
            marker: marker
          });
        }
      }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || marker.type == 'bookmark' && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push({
            from: startsBefore ? null : span.from - endCh,
            to: span.to == null ? null : span.to - endCh,
            marker: marker
          });
        }
      }
    return nw;
  }
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast)
      return null;
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found)
            span.to = startCh;
          else if (sameLine)
            span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null)
          span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine)
              (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine)
            (first || (first = [])).push(span);
        }
      }
    }
    if (sameLine && first) {
      // Make sure we didn't create any zero-length spans
      for (var i = 0; i < first.length; ++i)
        if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != 'bookmark')
          first.splice(i--, 1);
      if (!first.length)
        first = null;
    }
    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({
              from: null,
              to: null,
              marker: first[i].marker
            });
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old)
      return stretched;
    if (!stretched)
      return old;
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans:
          for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              if (oldCur[k].marker == span.marker)
                continue spans;
            oldCur.push(span);
          }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans)
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            (markers || (markers = [])).push(mark);
        }
    });
    if (!markers)
      return null;
    var parts = [{
          from: from,
          to: to
        }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from))
          continue;
        var newParts = [
            j,
            1
          ];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({
            from: p.from,
            to: m.from
          });
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({
            from: m.to,
            to: p.to
          });
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }
  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width))
          found = sp.marker;
      }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAt(line, -1);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAt(line, line.text.length + 1);
  }
  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if (sp.from == null)
          return true;
        if (sp.marker.replacedWith)
          continue;
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          return true;
      }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }
  // LINE WIDGETS
  var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
      if (options)
        for (var opt in options)
          if (options.hasOwnProperty(opt))
            this[opt] = options[opt];
      this.cm = cm;
      this.node = node;
    };
  eventMixin(LineWidget);
  function widgetOperation(f) {
    return function () {
      var withOp = !this.cm.curOp;
      if (withOp)
        startOperation(this.cm);
      try {
        var result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function () {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws)
      return;
    for (var i = 0; i < ws.length; ++i)
      if (ws[i] == this)
        ws.splice(i--, 1);
    if (!ws.length)
      this.line.widgets = null;
    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    if (aboveVisible)
      addToScrollPos(this.cm, 0, -this.height);
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function () {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff)
      return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });
  function widgetHeight(widget) {
    if (widget.height != null)
      return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
    return widget.height = widget.node.offsetHeight;
  }
  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll)
      cm.display.alignWidgets = true;
    changeLine(cm, handle, function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null)
        widgets.push(widget);
      else
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible)
          addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }
  // LINE DATA STRUCTURE
  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
      this.text = text;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight ? estimateHeight(this) : 1;
    };
  eventMixin(Line);
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter)
      line.stateAfter = null;
    if (line.styles)
      line.styles = null;
    if (line.order != null)
      line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height)
      updateLineHeight(line, estHeight);
  }
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  // Run the given mode's parser over a line, update the styles
  // array, which contains alternating fragments of text and CSS
  // classes.
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null)
      flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        // Webkit seems to refuse to render text nodes longer than 57444 characters
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start)
          f(stream.start, curStyle);
        curStart = stream.start;
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    if (curStart < stream.pos)
      f(stream.pos, curStyle);
  }
  function highlightLine(cm, line, state) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen];
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
      st.push(end, style);
    });
    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i + 1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style)
          return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = cur ? cur + ' ' + style : style;
          }
        }
      });
    }
    return st;
  }
  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }
  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array.
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }
  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style)
      return null;
    return styleToClassCache[style] || (styleToClassCache[style] = 'cm-' + style.replace(/ +/g, ' cm-'));
  }
  function lineContent(cm, realLine, measure, copyWidgets) {
    var merged, line = realLine, empty = true;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(cm.doc, merged.find().from.line);
    var builder = {
        pre: elt('pre'),
        col: 0,
        pos: 0,
        measure: null,
        measuredSomething: false,
        cm: cm,
        copyWidgets: copyWidgets
      };
    if (line.textClass)
      builder.pre.className = line.textClass;
    do {
      if (line.text)
        empty = false;
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption('lineWrapping'))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      if (measure && line == realLine && !builder.measuredSomething) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.measuredSomething = true;
      }
      if (next)
        line = getLine(cm.doc, next.to.line);
    } while (next);
    if (measure && !builder.measuredSomething && !measure[0])
      measure[0] = builder.pre.appendChild(empty ? elt('span', '\xa0') : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode('\xa0'));
    var order;
    // Work around problem with the reported dimensions of single-char
    // direction spans on IE (issue #1129). See also the comment in
    // cursorCoords.
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to)
        --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span)
          span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
      }
    }
    signal(cm, 'renderLine', cm, realLine, builder.pre);
    return builder.pre;
  }
  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle, title) {
    if (!text)
      return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m)
          break;
        pos += skipped + 1;
        if (m[0] == '\t') {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
          builder.col += tabWidth;
        } else {
          var token = elt('span', '\u2022', 'cm-invalidchar');
          token.title = '\\u' + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || '';
      if (startStyle)
        fullStyle += startStyle;
      if (endStyle)
        fullStyle += endStyle;
      var token = elt('span', [content], fullStyle);
      if (title)
        token.title = title;
      return builder.pre.appendChild(token);
    }
    builder.pre.appendChild(content);
  }
  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= '\ud800' && ch < '\udbff' && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping(text, i)) {
        builder.pre.appendChild(elt('wbr'));
      }
      var old = builder.measure[builder.pos];
      var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
      if (old)
        span.leftSide = old.leftSide || old;
      // In IE single-space nodes wrap differently than spaces
      // embedded in larger text nodes, except when set to
      // white-space: normal (issue #1268).
      if (ie && wrapping && ch == ' ' && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = 'normal';
      builder.pos += ch.length;
    }
    if (text.length)
      builder.measuredSomething = true;
  }
  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = ' ';
      for (var i = 0; i < old.length - 2; ++i)
        out += i % 2 ? ' ' : '\xa0';
      out += ' ';
      return out;
    }
    return function (builder, text, style, startStyle, endStyle, title) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle, title);
    };
  }
  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.replacedWith;
    if (widget) {
      if (builder.copyWidgets)
        widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure) {
        if (size) {
          builder.measure[builder.pos] = widget;
        } else {
          var elt = builder.measure[builder.pos] = zeroWidthElement(builder.cm.display.measure);
          if (marker.type != 'bookmark' || marker.insertLeft)
            builder.pre.insertBefore(elt, widget);
          else
            builder.pre.appendChild(elt);
        }
        builder.measuredSomething = true;
      }
    }
    builder.pos += size;
  }
  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i += 2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), styleToClass(styles[i + 1]));
      return;
    }
    var len = allText.length, pos = 0, i = 1, text = '', style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = '';
        collapsed = null;
        nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = '';
            }
            if (m.className)
              spanStyle += ' ' + m.className;
            if (m.startStyle && sp.from == pos)
              spanStartStyle += ' ' + m.startStyle;
            if (m.endStyle && sp.to == nextChange)
              spanEndStyle += ' ' + m.endStyle;
            if (m.title && !title)
              title = m.title;
            if (m.collapsed && (!collapsed || collapsed.marker.size < m.size))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == 'bookmark' && sp.from == pos && m.replacedWith)
            foundBookmark = m;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
          if (collapsed.to == null)
            return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed)
          buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len)
        break;
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', title);
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = '';
        }
        text = allText.slice(at, at = styles[i++]);
        style = styleToClass(styles[i++]);
      }
    }
  }
  // DOCUMENT DATA STRUCTURE
  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, 'change', line, change);
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    // First adjust the line structure
    if (from.ch == 0 && to.ch == 0 && lastText == '') {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines)
        doc.remove(from.line, nlines);
      if (added.length)
        doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1)
        doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }
    signalLater(doc, 'change', doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function () {
      return this.lines.length;
    },
    removeInner: function (at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, 'delete');
      }
      this.lines.splice(at, n);
    },
    collapse: function (lines) {
      lines.splice.apply(lines, [
        lines.length,
        0
      ].concat(this.lines));
    },
    insertInner: function (at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i)
        lines[i].parent = this;
    },
    iterN: function (at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at]))
          return true;
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function () {
      return this.size;
    },
    removeInner: function (at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function (lines) {
      for (var i = 0, e = this.children.length; i < e; ++i)
        this.children[i].collapse(lines);
    },
    insertInner: function (at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function () {
      if (this.children.length <= 10)
        return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [
            copy,
            sibling
          ];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function (at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op))
            return true;
          if ((n -= used) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
    }
  };
  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
      if (!(this instanceof Doc))
        return new Doc(text, mode, firstLine);
      if (firstLine == null)
        firstLine = 0;
      BranchChunk.call(this, [new LeafChunk([new Line('', null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.history = makeHistory();
      this.cleanGeneration = 1;
      this.frontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = {
        from: start,
        to: start,
        head: start,
        anchor: start,
        shift: false,
        extend: false,
        goalColumn: null
      };
      this.id = ++nextDocId;
      this.modeOption = mode;
      if (typeof text == 'string')
        text = splitLines(text);
      updateDoc(this, {
        from: start,
        to: start,
        text: text
      }, null, {
        head: start,
        anchor: start
      });
    };
  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    iter: function (from, to, op) {
      if (op)
        this.iterN(from - this.first, to - from, op);
      else
        this.iterN(this.first, this.first + this.size, from);
    },
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i)
        height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    setValue: function (code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: splitLines(code),
        origin: 'setValue'
      }, {
        head: top,
        anchor: top
      }, true);
    },
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    setLine: function (line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function (line) {
      if (line)
        replaceRange(this, '', clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else
        replaceRange(this, '', Pos(0, 0), clipPos(this, Pos(1, 0)));
    },
    getLineHandle: function (line) {
      if (isLine(this, line))
        return getLine(this, line);
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function (line) {
      if (typeof line == 'number')
        line = getLine(this, line);
      return visualLine(this, line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var sel = this.sel, pos;
      if (start == null || start == 'head')
        pos = sel.head;
      else if (start == 'anchor')
        pos = sel.anchor;
      else if (start == 'end' || start === false)
        pos = sel.to;
      else
        pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function () {
      return !posEq(this.sel.head, this.sel.anchor);
    },
    setCursor: docOperation(function (line, ch, extend) {
      var pos = clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line);
      if (extend)
        extendSelection(this, pos);
      else
        setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function (anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function (from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),
    getSelection: function (lineSep) {
      return this.getRange(this.sel.from, this.sel.to, lineSep);
    },
    replaceSelection: function (code, collapse, origin) {
      makeChange(this, {
        from: this.sel.from,
        to: this.sel.to,
        text: splitLines(code),
        origin: origin
      }, collapse || 'around');
    },
    undo: docOperation(function () {
      makeChangeFromHistory(this, 'undo');
    }),
    redo: docOperation(function () {
      makeChangeFromHistory(this, 'redo');
    }),
    setExtending: function (val) {
      this.sel.extend = val;
    },
    historySize: function () {
      var hist = this.history;
      return {
        undo: hist.done.length,
        redo: hist.undone.length
      };
    },
    clearHistory: function () {
      this.history = makeHistory(this.history.maxGeneration);
    },
    markClean: function () {
      this.cleanGeneration = this.changeGeneration();
    },
    changeGeneration: function () {
      this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = makeHistory(this.history.maxGeneration);
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
    },
    setBookmark: function (pos, options) {
      var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft
        };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, 'bookmark');
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans)
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
            markers.push(span.marker.parent || span.marker);
        }
      return markers;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i)
            if (sps[i].from != null)
              markers.push(sps[i].marker);
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch, lineNo = this.first;
      this.iter(function (line) {
        var sz = line.text.length + 1;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0)
        return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = {
        from: this.sel.from,
        to: this.sel.to,
        head: this.sel.head,
        anchor: this.sel.anchor,
        shift: this.sel.shift,
        extend: false,
        goalColumn: this.sel.goalColumn
      };
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options)
        options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from)
        from = options.from;
      if (options.to != null && options.to < to)
        to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist)
        copy.history = this.history;
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
          doc: this,
          isParent: true,
          sharedHist: options.sharedHist
        }];
      return copy;
    },
    unlinkDoc: function (other) {
      if (other instanceof CodeMirror)
        other = other.doc;
      if (this.linked)
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other)
            continue;
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          break;
        }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          splitIds.push(doc.id);
        }, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    }
  });
  Doc.prototype.eachLine = Doc.prototype.iter;
  // The Doc methods that should be available on CodeMirror instances
  var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
  for (var prop in Doc.prototype)
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
  eventMixin(Doc);
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked)
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip)
            continue;
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared)
            continue;
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
    }
    propagate(doc, null, true);
  }
  function attachDoc(cm, doc) {
    if (doc.cm)
      throw new Error('This document is already in use.');
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping)
      computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  // LINE UTILITIES
  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line)
        text = text.slice(0, end.ch);
      if (n == start.line)
        text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    });
    return out;
  }
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent)
      n.height += diff;
  }
  function lineNo(line) {
    if (line.parent == null)
      return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur)
          break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer:
      do {
        for (var i = 0, e = chunk.children.length; i < e; ++i) {
          var child = chunk.children[i], ch = child.height;
          if (h < ch) {
            chunk = child;
            continue outer;
          }
          h -= ch;
          n += child.chunkSize();
        }
        return n;
      } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh)
        break;
      h -= lh;
    }
    return n + i;
  }
  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj)
        break;
      else
        h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk)
          break;
        else
          h += cur.height;
      }
    }
    return h;
  }
  function getOrder(line) {
    var order = line.order;
    if (order == null)
      order = line.order = bidiOrdering(line.text);
    return order;
  }
  // HISTORY
  function makeHistory(startGen) {
    return {
      done: [],
      undone: [],
      undoDepth: Infinity,
      lastTime: 0,
      lastOp: null,
      lastOrigin: null,
      generation: startGen || 1,
      maxGeneration: startGen || 1
    };
  }
  function attachLocalSpans(doc, change, from, to) {
    var existing = change['spans_' + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }
  function historyChangeFromChange(doc, change) {
    var from = {
        line: change.from.line,
        ch: change.from.ch
      };
    var histChange = {
        from: from,
        to: changeEnd(change),
        text: getBetween(doc, change.from, change.to)
      };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(), cur = lst(hist.done);
    if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*'))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor;
      cur.headAfter = selAfter.head;
    } else {
      // Can not be merged, start a new event.
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation,
        anchorBefore: doc.sel.anchor,
        headBefore: doc.sel.head,
        anchorAfter: selAfter.anchor,
        headAfter: selAfter.head
      };
      hist.done.push(cur);
      hist.generation = ++hist.maxGeneration;
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }
  function removeClearedSpans(spans) {
    if (!spans)
      return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out)
          out = spans.slice(0, i);
      } else if (out)
        out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }
  function getOldSpans(doc, change) {
    var found = change['spans_' + doc.id];
    if (!found)
      return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }
  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({
        changes: newChanges,
        anchorBefore: event.anchorBefore,
        headBefore: event.headBefore,
        anchorAfter: event.anchorAfter,
        headAfter: event.headAfter
      });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup)
          for (var prop in change)
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
      }
    }
    return copy;
  }
  // Rebasing/resetting history to deal with externally-sourced changes
  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) {
          cur.from = copyPos(cur.from);
          cur.to = copyPos(cur.to);
        }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore);
        sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter);
        sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore);
        rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter);
        rebaseHistSel(sub.headAfter);
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  // EVENT OPERATORS
  function stopMethod() {
    e_stop(this);
  }
  // Ensure an event has a stop method.
  function addStop(event) {
    if (!event.stop)
      event.stop = stopMethod;
    return event;
  }
  function e_preventDefault(e) {
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation)
      e.stopPropagation();
    else
      e.cancelBubble = true;
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1)
        b = 1;
      else if (e.button & 2)
        b = 3;
      else if (e.button & 4)
        b = 2;
    }
    if (mac && e.ctrlKey && b == 1)
      b = 3;
    return b;
  }
  // EVENT HANDLING
  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent('on' + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }
  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent('on' + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr)
        return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) {
          arr.splice(i, 1);
          break;
        }
    }
  }
  function signal(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i)
      arr[i].apply(null, args);
  }
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {
      return function () {
        f.apply(null, args);
      };
    }
    ;
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }
  function signalDOMEvent(cm, e, override) {
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }
  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i)
      delayed[i]();
  }
  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }
  CodeMirror.on = on;
  CodeMirror.off = off;
  CodeMirror.signal = signal;
  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };
    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  }
  // MISC UTILITIES
  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;
  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {
      toString: function () {
        return 'CodeMirror.Pass';
      }
    };
  function Delayed() {
    this.id = null;
  }
  Delayed.prototype = {
    set: function (ms, f) {
      clearTimeout(this.id);
      this.id = setTimeout(f, ms);
    }
  };
  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1)
        end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == '\t')
        n += tabSize - n % tabSize;
      else
        ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;
  var spaceStrs = [''];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + ' ');
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function selectInput(node) {
    if (ios) {
      // Mobile Safari apparently has a bug where select() is broken.
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else {
      // Suppress mysterious IE10 errors
      try {
        node.select();
      } catch (_e) {
      }
    }
  }
  function indexOf(collection, elt) {
    if (collection.indexOf)
      return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt)
        return i;
    return -1;
  }
  function createObj(base, props) {
    function Obj() {
    }
    Obj.prototype = base;
    var inst = new Obj();
    if (props)
      copyObj(props, inst);
    return inst;
  }
  function copyObj(obj, target) {
    if (!target)
      target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop))
        target[prop] = obj[prop];
    return target;
  }
  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i)
      a.push(undefined);
    return a;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isEmpty(obj) {
    for (var n in obj)
      if (obj.hasOwnProperty(n) && obj[n])
        return false;
    return true;
  }
  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
  // DOM UTILITIES
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className)
      e.className = className;
    if (style)
      e.style.cssText = style;
    if (typeof content == 'string')
      setTextContent(e, content);
    else if (content)
      for (var i = 0; i < content.length; ++i)
        e.appendChild(content[i]);
    return e;
  }
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = '';
      e.appendChild(document.createTextNode(str));
    } else
      e.textContent = str;
  }
  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function (f) {
    getRect = f;
  };
  // FEATURE DETECTION
  // Detect drag-and-drop
  var dragAndDrop = function () {
      // There is *some* kind of drag-and-drop support in IE6-8, but I
      // couldn't get it to work yet.
      if (ie_lt9)
        return false;
      var div = elt('div');
      return 'draggable' in div || 'dragDrop' in div;
    }();
  // For a reason I have yet to figure out, some browsers disallow
  // word wrapping between certain characters *only* if a new inline
  // element is started between them. This makes it hard to reliably
  // measure the position of things, since that requires inserting an
  // extra span. This terribly fragile set of tests matches the
  // character combinations that suffer from this phenomenon on the
  // various browsers.
  function spanAffectsWrapping() {
    return false;
  }
  if (gecko)
    // Only for "$'"
    spanAffectsWrapping = function (str, i) {
      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
    };
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = function (str, i) {
      return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1));
    };
  else if (webkit && !/Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent))
    spanAffectsWrapping = function (str, i) {
      if (i > 1 && str.charCodeAt(i - 1) == 45) {
        if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i)))
          return true;
        if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i)))
          return false;
      }
      return /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));
    };
  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null)
      return knownScrollbarWidth;
    var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt('span', '\u200b');
      removeChildrenAndAdd(measure, elt('span', [
        test,
        document.createTextNode('x')
      ]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported)
      return elt('span', '\u200b');
    else
      return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
  }
  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf('\n', pos);
        if (nl == -1)
          nl = string.length;
        var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
        var rt = line.indexOf('\r');
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function (string) {
      return string.split(/\r\n?|\n/);
    };
  CodeMirror.splitLines = splitLines;
  var hasSelection = window.getSelection ? function (te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function (te) {
      try {
        var range = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range || range.parentElement() != te)
        return false;
      return range.compareEndPoints('StartToEnd', range) != 0;
    };
  var hasCopyEvent = function () {
      var e = elt('div');
      if ('oncopy' in e)
        return true;
      e.setAttribute('oncopy', 'return;');
      return typeof e.oncopy == 'function';
    }();
  // KEY NAMING
  var keyNames = {
      3: 'Enter',
      8: 'Backspace',
      9: 'Tab',
      13: 'Enter',
      16: 'Shift',
      17: 'Ctrl',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Esc',
      32: 'Space',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      44: 'PrintScrn',
      45: 'Insert',
      46: 'Delete',
      59: ';',
      91: 'Mod',
      92: 'Mod',
      93: 'Mod',
      109: '-',
      107: '=',
      127: 'Delete',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: '\'',
      63276: 'PageUp',
      63277: 'PageDown',
      63275: 'End',
      63273: 'Home',
      63234: 'Left',
      63232: 'Up',
      63235: 'Right',
      63233: 'Down',
      63302: 'Insert',
      63272: 'Delete'
    };
  CodeMirror.keyNames = keyNames;
  (function () {
    // Number keys
    for (var i = 0; i < 10; i++)
      keyNames[i + 48] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++)
      keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++)
      keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
  }());
  // BIDI HELPERS
  function iterateBidiSections(order, from, to, f) {
    if (!order)
      return f(from, to, 'ltr');
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
        found = true;
      }
    }
    if (!found)
      f(from, to, 'ltr');
  }
  function bidiLeft(part) {
    return part.level % 2 ? part.to : part.from;
  }
  function bidiRight(part) {
    return part.level % 2 ? part.from : part.to;
  }
  function lineLeft(line) {
    var order = getOrder(line);
    return order ? bidiLeft(order[0]) : 0;
  }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order)
      return line.text.length;
    return bidiRight(lst(order));
  }
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line)
      lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }
  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir)
      return true;
    if (b == linedir)
      return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) {
        bidiOther = null;
        return i;
      }
      if (cur.from == pos || cur.to == pos) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          bidiOther = found;
          return i;
        } else {
          bidiOther = i;
          return found;
        }
      }
    }
    bidiOther = null;
    return found;
  }
  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit)
      return pos + dir;
    do
      pos += dir;
    while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
    return pos;
  }
  // This is somewhat involved. It is needed in order to move
  // 'visually' through bi-directional text -- i.e., pressing left
  // should make the cursor go left, even when in RTL text. The
  // tricky part is the 'jumps', where RTL and LTR text touch each
  // other. This often requires the cursor offset to move more than
  // one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi)
      return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
    for (;;) {
      if (target > part.from && target < part.to)
        return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos)
          return target;
        part = bidi[pos += dir];
        return dir > 0 == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part)
          return null;
        if (dir > 0 == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }
  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit)
      while (target > 0 && isExtendingChar.test(line.text.charAt(target)))
        target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }
  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.
  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals
  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = function () {
      // Character types for codepoints 0 to 0xff
      var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL';
      // Character types for codepoints 0x600 to 0x6ff
      var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr';
      function charType(code) {
        if (code <= 255)
          return lowTypes.charAt(code);
        else if (1424 <= code && code <= 1524)
          return 'R';
        else if (1536 <= code && code <= 1791)
          return arabicTypes.charAt(code - 1536);
        else if (1792 <= code && code <= 2220)
          return 'r';
        else
          return 'L';
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      // Browsers seem to always treat the boundaries of block elements as being L.
      var outerType = 'L';
      return function (str) {
        if (!bidiRE.test(str))
          return false;
        var len = str.length, types = [];
        for (var i = 0, type; i < len; ++i)
          types.push(type = charType(str.charCodeAt(i)));
        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        for (var i = 0, prev = outerType; i < len; ++i) {
          var type = types[i];
          if (type == 'm')
            types[i] = prev;
          else
            prev = type;
        }
        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (type == '1' && cur == 'r')
            types[i] = 'n';
          else if (isStrong.test(type)) {
            cur = type;
            if (type == 'r')
              types[i] = 'R';
          }
        }
        // W4. A single European separator between two European numbers
        // changes to a European number. A single common separator between
        // two numbers of the same type changes to that type.
        for (var i = 1, prev = types[0]; i < len - 1; ++i) {
          var type = types[i];
          if (type == '+' && prev == '1' && types[i + 1] == '1')
            types[i] = '1';
          else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
            types[i] = prev;
          prev = type;
        }
        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        for (var i = 0; i < len; ++i) {
          var type = types[i];
          if (type == ',')
            types[i] = 'N';
          else if (type == '%') {
            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
            }
            var replace = i && types[i - 1] == '!' || end < len - 1 && types[end] == '1' ? '1' : 'N';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (cur == 'L' && type == '1')
            types[i] = 'L';
          else if (isStrong.test(type))
            cur = type;
        }
        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        for (var i = 0; i < len; ++i) {
          if (isNeutral.test(types[i])) {
            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
            }
            var before = (i ? types[i - 1] : outerType) == 'L';
            var after = (end < len - 1 ? types[end] : outerType) == 'L';
            var replace = before || after ? 'L' : 'R';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        // Here we depart from the documented algorithm, in order to avoid
        // building up an actual levels array. Since there are only three
        // levels (0, 1, 2) in an implementation that doesn't take
        // explicit embedding into account, we can build up the order on
        // the fly, without following the level-based algorithm.
        var order = [], m;
        for (var i = 0; i < len;) {
          if (countsAsLeft.test(types[i])) {
            var start = i;
            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
            }
            order.push({
              from: start,
              to: i,
              level: 0
            });
          } else {
            var pos = i, at = order.length;
            for (++i; i < len && types[i] != 'L'; ++i) {
            }
            for (var j = pos; j < i;) {
              if (countsAsNum.test(types[j])) {
                if (pos < j)
                  order.splice(at, 0, {
                    from: pos,
                    to: j,
                    level: 1
                  });
                var nstart = j;
                for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                }
                order.splice(at, 0, {
                  from: nstart,
                  to: j,
                  level: 2
                });
                pos = j;
              } else
                ++j;
            }
            if (pos < i)
              order.splice(at, 0, {
                from: pos,
                to: i,
                level: 1
              });
          }
        }
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift({
            from: 0,
            to: m[0].length,
            level: 0
          });
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push({
            from: len - m[0].length,
            to: len,
            level: 0
          });
        }
        if (order[0].level != lst(order).level)
          order.push({
            from: len,
            to: len,
            level: order[0].level
          });
        return order;
      };
    }();
  // THE END
  CodeMirror.version = '3.15.0';
  return CodeMirror;
}();
(function () {
  'use strict';
  function doFold(cm, pos, options) {
    var finder = options && (options.call ? options : options.rangeFinder);
    if (!finder)
      finder = cm.getHelper(pos, 'fold');
    if (!finder)
      return;
    if (typeof pos == 'number')
      pos = CodeMirror.Pos(pos, 0);
    var minSize = options && options.minFoldSize || 0;
    function getRange(allowFolded) {
      var range = finder(cm, pos);
      if (!range || range.to.line - range.from.line < minSize)
        return null;
      var marks = cm.findMarksAt(range.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold) {
          if (!allowFolded)
            return null;
          range.cleared = true;
          marks[i].clear();
        }
      }
      return range;
    }
    var range = getRange(true);
    if (options && options.scanUp)
      while (!range && pos.line > cm.firstLine()) {
        pos = CodeMirror.Pos(pos.line - 1, 0);
        range = getRange(false);
      }
    if (!range || range.cleared)
      return;
    var myWidget = makeWidget(options);
    CodeMirror.on(myWidget, 'mousedown', function () {
      myRange.clear();
    });
    var myRange = cm.markText(range.from, range.to, {
        replacedWith: myWidget,
        clearOnEnter: true,
        __isFold: true
      });
    myRange.on('clear', function (from, to) {
      CodeMirror.signal(cm, 'unfold', cm, from, to);
    });
    CodeMirror.signal(cm, 'fold', cm, range.from, range.to);
  }
  function makeWidget(options) {
    var widget = options && options.widget || '\u2194';
    if (typeof widget == 'string') {
      var text = document.createTextNode(widget);
      widget = document.createElement('span');
      widget.appendChild(text);
      widget.className = 'CodeMirror-foldmarker';
    }
    return widget;
  }
  // Clumsy backwards-compatible interface
  CodeMirror.newFoldFunction = function (rangeFinder, widget) {
    return function (cm, pos) {
      doFold(cm, pos, {
        rangeFinder: rangeFinder,
        widget: widget
      });
    };
  };
  // New-style interface
  CodeMirror.defineExtension('foldCode', function (pos, options) {
    doFold(this, pos, options);
  });
  CodeMirror.registerHelper('fold', 'combine', function () {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function (cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found)
          return found;
      }
    };
  });
}());
(function () {
  'use strict';
  CodeMirror.defineOption('foldGutter', false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off('gutterClick', onGutterClick);
      cm.off('change', onChange);
      cm.off('viewportChange', onViewportChange);
      cm.off('fold', onFold);
      cm.off('unfold', onFold);
      cm.off('swapDoc', updateInViewport);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on('gutterClick', onGutterClick);
      cm.on('change', onChange);
      cm.on('viewportChange', onViewportChange);
      cm.on('fold', onFold);
      cm.on('unfold', onFold);
      cm.on('swapDoc', updateInViewport);
    }
  });
  var Pos = CodeMirror.Pos;
  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }
  function parseOptions(opts) {
    if (opts === true)
      opts = {};
    if (opts.gutter == null)
      opts.gutter = 'CodeMirror-foldgutter';
    if (opts.indicatorOpen == null)
      opts.indicatorOpen = 'CodeMirror-foldgutter-open';
    if (opts.indicatorFolded == null)
      opts.indicatorFolded = 'CodeMirror-foldgutter-folded';
    return opts;
  }
  function isFolded(cm, line) {
    var marks = cm.findMarksAt(Pos(line));
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold && marks[i].find().from.line == line)
        return true;
  }
  function marker(spec) {
    if (typeof spec == 'string') {
      var elt = document.createElement('div');
      elt.className = spec;
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }
  function updateFoldInfo(cm, from, to) {
    var opts = cm.state.foldGutter.options, cur = from;
    cm.eachLine(from, to, function (line) {
      var mark = null;
      if (isFolded(cm, cur)) {
        mark = marker(opts.indicatorFolded);
      } else {
        var pos = Pos(cur, 0), func = opts.rangeFinder || cm.getHelper(pos, 'fold');
        var range = func && func(cm, pos);
        if (range && range.from.line + 1 < range.to.line)
          mark = marker(opts.indicatorOpen);
      }
      cm.setGutterMarker(line, opts.gutter, mark);
      ++cur;
    });
  }
  function updateInViewport(cm) {
    var vp = cm.getViewport(), state = cm.state.foldGutter;
    if (!state)
      return;
    cm.operation(function () {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from;
    state.to = vp.to;
  }
  function onGutterClick(cm, line, gutter) {
    var opts = cm.state.foldGutter.options;
    if (gutter != opts.gutter)
      return;
    cm.foldCode(Pos(line, 0), opts.rangeFinder);
  }
  function onChange(cm) {
    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function () {
      updateInViewport(cm);
    }, opts.foldOnChangeTimeSpan || 600);
  }
  function onViewportChange(cm) {
    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function () {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function () {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts.updateViewportTimeSpan);
  }
  function onFold(cm, from) {
    var state = cm.state.foldGutter, line = from.line;
    if (line >= state.from && line < state.to)
      updateFoldInfo(cm, line, line + 1);
  }
}());
CodeMirror.defineMode('gfm', function (config) {
  var codeDepth = 0;
  function blankLine(state) {
    state.code = false;
    return null;
  }
  var gfmOverlay = {
      startState: function () {
        return {
          code: false,
          codeBlock: false,
          ateSpace: false
        };
      },
      copyState: function (s) {
        return {
          code: s.code,
          codeBlock: s.codeBlock,
          ateSpace: s.ateSpace
        };
      },
      token: function (stream, state) {
        // Hack to prevent formatting override inside code blocks (block and inline)
        if (state.codeBlock) {
          if (stream.match(/^```/)) {
            state.codeBlock = false;
            return null;
          }
          stream.skipToEnd();
          return null;
        }
        if (stream.sol()) {
          state.code = false;
        }
        if (stream.sol() && stream.match(/^```/)) {
          stream.skipToEnd();
          state.codeBlock = true;
          return null;
        }
        // If this block is changed, it may need to be updated in Markdown mode
        if (stream.peek() === '`') {
          stream.next();
          var before = stream.pos;
          stream.eatWhile('`');
          var difference = 1 + stream.pos - before;
          if (!state.code) {
            codeDepth = difference;
            state.code = true;
          } else {
            if (difference === codeDepth) {
              // Must be exact
              state.code = false;
            }
          }
          return null;
        } else if (state.code) {
          stream.next();
          return null;
        }
        // Check if space. If so, links can be formatted later on
        if (stream.eatSpace()) {
          state.ateSpace = true;
          return null;
        }
        if (stream.sol() || state.ateSpace) {
          state.ateSpace = false;
          if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
            // User/Project@SHA
            // User@SHA
            // SHA
            return 'link';
          } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
            // User/Project#Num
            // User#Num
            // #Num
            return 'link';
          }
        }
        if (stream.match(/^((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`!()\[\]{};:'".,<>?]))/i)) {
          // URLs
          // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
          // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
          return 'link';
        }
        stream.next();
        return null;
      },
      blankLine: blankLine
    };
  CodeMirror.defineMIME('gfmBase', {
    name: 'markdown',
    underscoresBreakWords: false,
    taskLists: true,
    fencedCodeBlocks: true
  });
  return CodeMirror.overlayMode(CodeMirror.getMode(config, 'gfmBase'), gfmOverlay);
}, 'markdown');
// TODO actually recognize syntax of TypeScript constructs
CodeMirror.defineMode('javascript', function (config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonMode = parserConfig.json;
  var isTS = parserConfig.typescript;
  // Tokenizer
  var keywords = function () {
      function kw(type) {
        return {
          type: type,
          style: 'keyword'
        };
      }
      var A = kw('keyword a'), B = kw('keyword b'), C = kw('keyword c');
      var operator = kw('operator'), atom = {
          type: 'atom',
          style: 'atom'
        };
      var jsKeywords = {
          'if': kw('if'),
          'while': A,
          'with': A,
          'else': B,
          'do': B,
          'try': B,
          'finally': B,
          'return': C,
          'break': C,
          'continue': C,
          'new': C,
          'delete': C,
          'throw': C,
          'var': kw('var'),
          'const': kw('var'),
          'let': kw('var'),
          'function': kw('function'),
          'catch': kw('catch'),
          'for': kw('for'),
          'switch': kw('switch'),
          'case': kw('case'),
          'default': kw('default'),
          'in': operator,
          'typeof': operator,
          'instanceof': operator,
          'true': atom,
          'false': atom,
          'null': atom,
          'undefined': atom,
          'NaN': atom,
          'Infinity': atom,
          'this': kw('this')
        };
      // Extend the 'normal' keywords with the TypeScript language extensions
      if (isTS) {
        var type = {
            type: 'variable',
            style: 'variable-3'
          };
        var tsKeywords = {
            'interface': kw('interface'),
            'class': kw('class'),
            'extends': kw('extends'),
            'constructor': kw('constructor'),
            'public': kw('public'),
            'private': kw('private'),
            'protected': kw('protected'),
            'static': kw('static'),
            'super': kw('super'),
            'string': type,
            'number': type,
            'bool': type,
            'any': type
          };
        for (var attr in tsKeywords) {
          jsKeywords[attr] = tsKeywords[attr];
        }
      }
      return jsKeywords;
    }();
  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }
  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return false;
      escaped = !escaped && next == '\\';
    }
    return escaped;
  }
  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp;
    content = cont;
    return style;
  }
  function jsTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == '\'')
      return chain(stream, state, jsTokenString(ch));
    else if (ch == '.' && stream.match(/^\d+(?:[eE][+\-]?\d+)?/))
      return ret('number', 'number');
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == '0' && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret('number', 'number');
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret('number', 'number');
    } else if (ch == '/') {
      if (stream.eat('*')) {
        return chain(stream, state, jsTokenComment);
      } else if (stream.eat('/')) {
        stream.skipToEnd();
        return ret('comment', 'comment');
      } else if (state.lastType == 'operator' || state.lastType == 'keyword c' || /^[\[{}\(,;:]$/.test(state.lastType)) {
        nextUntilUnescaped(stream, '/');
        stream.eatWhile(/[gimy]/);
        // 'y' is "sticky" option in Mozilla
        return ret('regexp', 'string-2');
      } else {
        stream.eatWhile(isOperatorChar);
        return ret('operator', null, stream.current());
      }
    } else if (ch == '#') {
      stream.skipToEnd();
      return ret('error', 'error');
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret('operator', null, stream.current());
    } else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return known && state.lastType != '.' ? ret(known.type, known.style, word) : ret('variable', 'variable', word);
    }
  }
  function jsTokenString(quote) {
    return function (stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = jsTokenBase;
      return ret('string', 'string');
    };
  }
  function jsTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == '/' && maybeEnd) {
        state.tokenize = jsTokenBase;
        break;
      }
      maybeEnd = ch == '*';
    }
    return ret('comment', 'comment');
  }
  // Parser
  var atomicTypes = {
      'atom': true,
      'number': true,
      'variable': true,
      'string': true,
      'regexp': true,
      'this': true
    };
  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null)
      this.align = align;
  }
  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname)
        return true;
  }
  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state;
    cx.stream = stream;
    cx.marked = null, cx.cc = cc;
    if (!state.lexical.hasOwnProperty('align'))
      state.lexical.align = true;
    while (true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while (cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked)
          return cx.marked;
        if (type == 'variable' && inScope(state, content))
          return 'variable-2';
        return style;
      }
    }
  }
  // Combinator utils
  var cx = {
      state: null,
      column: null,
      marked: null,
      cc: null
    };
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--)
      cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname)
          return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = 'def';
      if (inList(state.localVars))
        return;
      state.localVars = {
        name: varname,
        next: state.localVars
      };
    } else {
      if (inList(state.globalVars))
        return;
      state.globalVars = {
        name: varname,
        next: state.globalVars
      };
    }
  }
  // Combinators
  var defaultVars = {
      name: 'this',
      next: { name: 'arguments' }
    };
  function pushcontext() {
    cx.state.context = {
      prev: cx.state.context,
      vars: cx.state.localVars
    };
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function () {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == 'stat')
        indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ')')
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;
  function expect(wanted) {
    return function (type) {
      if (type == wanted)
        return cont();
      else if (wanted == ';')
        return pass();
      else
        return cont(arguments.callee);
    };
  }
  function statement(type) {
    if (type == 'var')
      return cont(pushlex('vardef'), vardef1, expect(';'), poplex);
    if (type == 'keyword a')
      return cont(pushlex('form'), expression, statement, poplex);
    if (type == 'keyword b')
      return cont(pushlex('form'), statement, poplex);
    if (type == '{')
      return cont(pushlex('}'), block, poplex);
    if (type == ';')
      return cont();
    if (type == 'if')
      return cont(pushlex('form'), expression, statement, poplex, maybeelse);
    if (type == 'function')
      return cont(functiondef);
    if (type == 'for')
      return cont(pushlex('form'), expect('('), pushlex(')'), forspec1, expect(')'), poplex, statement, poplex);
    if (type == 'variable')
      return cont(pushlex('stat'), maybelabel);
    if (type == 'switch')
      return cont(pushlex('form'), expression, pushlex('}', 'switch'), expect('{'), block, poplex, poplex);
    if (type == 'case')
      return cont(expression, expect(':'));
    if (type == 'default')
      return cont(expect(':'));
    if (type == 'catch')
      return cont(pushlex('form'), pushcontext, expect('('), funarg, expect(')'), statement, poplex, popcontext);
    return pass(pushlex('stat'), expression, expect(';'), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type))
      return cont(maybeop);
    if (type == 'function')
      return cont(functiondef);
    if (type == 'keyword c')
      return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == '(')
      return cont(pushlex(')'), maybeexpression, expect(')'), poplex, maybeop);
    if (type == 'operator')
      return cont(noComma ? expressionNoComma : expression);
    if (type == '[')
      return cont(pushlex(']'), commasep(expressionNoComma, ']'), poplex, maybeop);
    if (type == '{')
      return cont(pushlex('}'), commasep(objprop, '}'), poplex, maybeop);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/))
      return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/))
      return pass();
    return pass(expressionNoComma);
  }
  function maybeoperatorComma(type, value) {
    if (type == ',')
      return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == 'operator') {
      if (/\+\+|--/.test(value))
        return cont(me);
      if (value == '?')
        return cont(expression, expect(':'), expr);
      return cont(expr);
    }
    if (type == ';')
      return;
    if (type == '(')
      return cont(pushlex(')', 'call'), commasep(expressionNoComma, ')'), poplex, me);
    if (type == '.')
      return cont(property, me);
    if (type == '[')
      return cont(pushlex(']'), maybeexpression, expect(']'), poplex, me);
  }
  function maybelabel(type) {
    if (type == ':')
      return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(';'), poplex);
  }
  function property(type) {
    if (type == 'variable') {
      cx.marked = 'property';
      return cont();
    }
  }
  function objprop(type, value) {
    if (type == 'variable') {
      cx.marked = 'property';
      if (value == 'get' || value == 'set')
        return cont(getterSetter);
    } else if (type == 'number' || type == 'string') {
      cx.marked = type + ' property';
    }
    if (atomicTypes.hasOwnProperty(type))
      return cont(expect(':'), expressionNoComma);
  }
  function getterSetter(type) {
    if (type == ':')
      return cont(expression);
    if (type != 'variable')
      return cont(expect(':'), expression);
    cx.marked = 'property';
    return cont(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ',') {
        var lex = cx.state.lexical;
        if (lex.info == 'call')
          lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end)
        return cont();
      return cont(expect(end));
    }
    return function (type) {
      if (type == end)
        return cont();
      else
        return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == '}')
      return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (type == ':')
      return cont(typedef);
    return pass();
  }
  function typedef(type) {
    if (type == 'variable') {
      cx.marked = 'variable-3';
      return cont();
    }
    return pass();
  }
  function vardef1(type, value) {
    if (type == 'variable') {
      register(value);
      return isTS ? cont(maybetype, vardef2) : cont(vardef2);
    }
    return pass();
  }
  function vardef2(type, value) {
    if (value == '=')
      return cont(expressionNoComma, vardef2);
    if (type == ',')
      return cont(vardef1);
  }
  function maybeelse(type, value) {
    if (type == 'keyword b' && value == 'else')
      return cont(pushlex('form'), statement, poplex);
  }
  function forspec1(type) {
    if (type == 'var')
      return cont(vardef1, expect(';'), forspec2);
    if (type == ';')
      return cont(forspec2);
    if (type == 'variable')
      return cont(formaybein);
    return pass(expression, expect(';'), forspec2);
  }
  function formaybein(_type, value) {
    if (value == 'in')
      return cont(expression);
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ';')
      return cont(forspec3);
    if (value == 'in')
      return cont(expression);
    return pass(expression, expect(';'), forspec3);
  }
  function forspec3(type) {
    if (type != ')')
      cont(expression);
  }
  function functiondef(type, value) {
    if (type == 'variable') {
      register(value);
      return cont(functiondef);
    }
    if (type == '(')
      return cont(pushlex(')'), pushcontext, commasep(funarg, ')'), poplex, statement, popcontext);
  }
  function funarg(type, value) {
    if (type == 'variable') {
      register(value);
      return isTS ? cont(maybetype) : cont();
    }
  }
  // Interface
  return {
    startState: function (basecolumn) {
      return {
        tokenize: jsTokenBase,
        lastType: null,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, 'block', false),
        localVars: parserConfig.localVars,
        globalVars: parserConfig.globalVars,
        context: parserConfig.localVars && { vars: parserConfig.localVars },
        indented: 0
      };
    },
    token: function (stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty('align'))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (state.tokenize != jsTokenComment && stream.eatSpace())
        return null;
      var style = state.tokenize(stream, state);
      if (type == 'comment')
        return style;
      state.lastType = type == 'operator' && (content == '++' || content == '--') ? 'incdec' : type;
      return parseJS(state, style, type, content, stream);
    },
    indent: function (state, textAfter) {
      if (state.tokenize == jsTokenComment)
        return CodeMirror.Pass;
      if (state.tokenize != jsTokenBase)
        return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex)
          lexical = lexical.prev;
        else if (c != maybeelse || /^else\b/.test(textAfter))
          break;
      }
      if (lexical.type == 'stat' && firstChar == '}')
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ')' && lexical.prev.type == 'stat')
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;
      if (type == 'vardef')
        return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? 4 : 0);
      else if (type == 'form' && firstChar == '{')
        return lexical.indented;
      else if (type == 'form')
        return lexical.indented + indentUnit;
      else if (type == 'stat')
        return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? statementIndent || indentUnit : 0);
      else if (lexical.info == 'switch' && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align)
        return lexical.column + (closing ? 0 : 1);
      else
        return lexical.indented + (closing ? 0 : indentUnit);
    },
    electricChars: ':{}',
    blockCommentStart: jsonMode ? null : '/*',
    blockCommentEnd: jsonMode ? null : '*/',
    lineComment: jsonMode ? null : '//',
    fold: 'brace',
    helperType: jsonMode ? 'json' : 'javascript',
    jsonMode: jsonMode
  };
});
CodeMirror.defineMIME('text/javascript', 'javascript');
CodeMirror.defineMIME('text/ecmascript', 'javascript');
CodeMirror.defineMIME('application/javascript', 'javascript');
CodeMirror.defineMIME('application/ecmascript', 'javascript');
CodeMirror.defineMIME('application/json', {
  name: 'javascript',
  json: true
});
CodeMirror.defineMIME('application/x-json', {
  name: 'javascript',
  json: true
});
CodeMirror.defineMIME('text/typescript', {
  name: 'javascript',
  typescript: true
});
CodeMirror.defineMIME('application/typescript', {
  name: 'javascript',
  typescript: true
});
CodeMirror.defineMode('markdown', function (cmCfg, modeCfg) {
  var htmlFound = CodeMirror.modes.hasOwnProperty('xml');
  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {
      name: 'xml',
      htmlMode: true
    } : 'text/plain');
  var aliases = {
      html: 'htmlmixed',
      js: 'javascript',
      json: 'application/json',
      c: 'text/x-csrc',
      'c++': 'text/x-c++src',
      java: 'text/x-java',
      csharp: 'text/x-csharp',
      'c#': 'text/x-csharp',
      scala: 'text/x-scala'
    };
  var getMode = function () {
      var i, modes = {}, mimes = {}, mime;
      var list = [];
      for (var m in CodeMirror.modes)
        if (CodeMirror.modes.propertyIsEnumerable(m))
          list.push(m);
      for (i = 0; i < list.length; i++) {
        modes[list[i]] = list[i];
      }
      var mimesList = [];
      for (var m in CodeMirror.mimeModes)
        if (CodeMirror.mimeModes.propertyIsEnumerable(m))
          mimesList.push({
            mime: m,
            mode: CodeMirror.mimeModes[m]
          });
      for (i = 0; i < mimesList.length; i++) {
        mime = mimesList[i].mime;
        mimes[mime] = mimesList[i].mime;
      }
      for (var a in aliases) {
        if (aliases[a] in modes || aliases[a] in mimes)
          modes[a] = aliases[a];
      }
      return function (lang) {
        return modes[lang] ? CodeMirror.getMode(cmCfg, modes[lang]) : null;
      };
    }();
  // Should underscores in words open/close em/strong?
  if (modeCfg.underscoresBreakWords === undefined)
    modeCfg.underscoresBreakWords = true;
  // Turn on fenced code blocks? ("```" to start/end)
  if (modeCfg.fencedCodeBlocks === undefined)
    modeCfg.fencedCodeBlocks = false;
  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined)
    modeCfg.taskLists = false;
  var codeDepth = 0;
  var header = 'header', code = 'comment', quote1 = 'atom', quote2 = 'number', list1 = 'variable-2', list2 = 'variable-3', list3 = 'keyword', hr = 'hr', image = 'tag', linkinline = 'link', linkemail = 'link', linktext = 'link', linkhref = 'string', em = 'em', strong = 'strong';
  var hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/, ulRE = /^[*\-+]\s+/, olRE = /^[0-9]+\.\s+/, taskListRE = /^\[(x| )\](?=\s)/, headerRE = /^(?:\={1,}|-{1,})$/, textRE = /^[^!\[\]*_\\<>` "'(]+/;
  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }
  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }
  // Blocks
  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset state.quote
    state.quote = 0;
    if (!htmlFound && state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.thisLineHasContent = false;
    return null;
  }
  function blockNormal(stream, state) {
    var prevLineIsList = state.list !== false;
    if (state.list !== false && state.indentationDiff >= 0) {
      // Continued list
      if (state.indentationDiff < 4) {
        // Only adjust indentation if *not* a code block
        state.indentation -= state.indentationDiff;
      }
      state.list = null;
    } else if (state.list !== false && state.indentation > 0) {
      state.list = null;
      state.listDepth = Math.floor(state.indentation / 4);
    } else if (state.list !== false) {
      // No longer a list
      state.list = false;
      state.listDepth = 0;
    }
    if (state.indentationDiff >= 4) {
      state.indentation -= 4;
      stream.skipToEnd();
      return code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (stream.peek() === '#' || state.prevLineHasContent && stream.match(headerRE)) {
      state.header = true;
    } else if (stream.eat('>')) {
      state.indentation++;
      state.quote = 1;
      stream.eatSpace();
      while (stream.eat('>')) {
        stream.eatSpace();
        state.quote++;
      }
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    } else if (stream.match(hrRE, true)) {
      return hr;
    } else if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, true) || stream.match(olRE, true))) {
      state.indentation += 4;
      state.list = true;
      state.listDepth++;
      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
    } else if (modeCfg.fencedCodeBlocks && stream.match(/^```([\w+#]*)/, true)) {
      // try switching mode
      state.localMode = getMode(RegExp.$1);
      if (state.localMode)
        state.localState = state.localMode.startState();
      switchBlock(stream, state, local);
      return code;
    }
    return switchInline(stream, state, state.inline);
  }
  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if (htmlFound && style === 'tag' && state.htmlState.type !== 'openTag' && !state.htmlState.context) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    if (state.md_inside && stream.current().indexOf('>') != -1) {
      state.f = inlineNormal;
      state.block = blockNormal;
      state.htmlState.context = undefined;
    }
    return style;
  }
  function local(stream, state) {
    if (stream.sol() && stream.match(/^```/, true)) {
      state.localMode = state.localState = null;
      state.f = inlineNormal;
      state.block = blockNormal;
      return code;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return code;
    }
  }
  // Inline
  function getType(state) {
    var styles = [];
    if (state.taskOpen) {
      return 'meta';
    }
    if (state.taskClosed) {
      return 'property';
    }
    if (state.strong) {
      styles.push(strong);
    }
    if (state.em) {
      styles.push(em);
    }
    if (state.linkText) {
      styles.push(linktext);
    }
    if (state.code) {
      styles.push(code);
    }
    if (state.header) {
      styles.push(header);
    }
    if (state.quote) {
      styles.push(state.quote % 2 ? quote1 : quote2);
    }
    if (state.list !== false) {
      var listMod = (state.listDepth - 1) % 3;
      if (!listMod) {
        styles.push(list1);
      } else if (listMod === 1) {
        styles.push(list2);
      } else {
        styles.push(list3);
      }
    }
    if (state.trailingSpaceNewLine) {
      styles.push('trailing-space-new-line');
    } else if (state.trailingSpace) {
      styles.push('trailing-space-' + (state.trailingSpace % 2 ? 'a' : 'b'));
    }
    return styles.length ? styles.join(' ') : null;
  }
  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }
  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;
    if (state.list) {
      // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }
    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] !== 'x';
      if (taskOpen)
        state.taskOpen = true;
      else
        state.taskClosed = true;
      state.taskList = false;
      return getType(state);
    }
    state.taskOpen = false;
    state.taskClosed = false;
    var ch = stream.next();
    if (ch === '\\') {
      stream.next();
      return getType(state);
    }
    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return linkhref;
      }
    }
    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var t = getType(state);
      var before = stream.pos;
      stream.eatWhile('`');
      var difference = 1 + stream.pos - before;
      if (!state.code) {
        codeDepth = difference;
        state.code = true;
        return getType(state);
      } else {
        if (difference === codeDepth) {
          // Must be exact
          state.code = false;
          return t;
        }
        return getType(state);
      }
    } else if (state.code) {
      return getType(state);
    }
    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      stream.match(/\[[^\]]*\]/);
      state.inline = state.f = linkHref;
      return image;
    }
    if (ch === '[' && stream.match(/.*\](\(| ?\[)/, false)) {
      state.linkText = true;
      return getType(state);
    }
    if (ch === ']' && state.linkText) {
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = linkHref;
      return type;
    }
    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      return switchInline(stream, state, inlineElement(linkinline, '>'));
    }
    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      return switchInline(stream, state, inlineElement(linkemail, '>'));
    }
    if (ch === '<' && stream.match(/^\w/, false)) {
      if (stream.string.indexOf('>') != -1) {
        var atts = stream.string.substring(1, stream.string.indexOf('>'));
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) {
          state.md_inside = true;
        }
      }
      stream.backUp(1);
      return switchBlock(stream, state, htmlBlock);
    }
    if (ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return 'tag';
    }
    var ignoreUnderscore = false;
    if (!modeCfg.underscoresBreakWords) {
      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
        var prevPos = stream.pos - 2;
        if (prevPos >= 0) {
          var prevCh = stream.string.charAt(prevPos);
          if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
            ignoreUnderscore = true;
          }
        }
      }
    }
    var t = getType(state);
    if (ch === '*' || ch === '_' && !ignoreUnderscore) {
      if (state.strong === ch && stream.eat(ch)) {
        // Remove STRONG
        state.strong = false;
        return t;
      } else if (!state.strong && stream.eat(ch)) {
        // Add STRONG
        state.strong = ch;
        return getType(state);
      } else if (state.em === ch) {
        // Remove EM
        state.em = false;
        return t;
      } else if (!state.em) {
        // Add EM
        state.em = ch;
        return getType(state);
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) {
        // Probably surrounded by spaces
        if (stream.peek() === ' ') {
          // Surrounded by spaces, ignore
          return getType(state);
        } else {
          // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }
    if (ch === ' ') {
      if (stream.match(/ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }
    return getType(state);
  }
  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if (stream.eatSpace()) {
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      return switchInline(stream, state, inlineElement(linkhref, ch === '(' ? ')' : ']'));
    }
    return 'error';
  }
  function footnoteLink(stream, state) {
    if (stream.match(/^[^\]]*\]:/, true)) {
      state.f = footnoteUrl;
      return linktext;
    }
    return switchInline(stream, state, inlineNormal);
  }
  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if (stream.eatSpace()) {
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) {
      // End of line, set flag to check next line
      state.linkTitle = true;
    } else {
      // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return linkhref;
  }
  var savedInlineRE = [];
  function inlineRE(endChar) {
    if (!savedInlineRE[endChar]) {
      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)
      endChar = (endChar + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      // Match any non-endChar, escaped character, as well as the closing
      // endChar.
      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
    }
    return savedInlineRE[endChar];
  }
  function inlineElement(type, endChar, next) {
    next = next || inlineNormal;
    return function (stream, state) {
      stream.match(inlineRE(endChar));
      state.inline = state.f = next;
      return type;
    };
  }
  return {
    startState: function () {
      return {
        f: blockNormal,
        prevLineHasContent: false,
        thisLineHasContent: false,
        block: blockNormal,
        htmlState: CodeMirror.startState(htmlMode),
        indentation: 0,
        inline: inlineNormal,
        text: handleText,
        linkText: false,
        linkTitle: false,
        em: false,
        strong: false,
        header: false,
        taskList: false,
        list: false,
        listDepth: 0,
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false,
        parentIndentation: 0
      };
    },
    copyState: function (s) {
      return {
        f: s.f,
        prevLineHasContent: s.prevLineHasContent,
        thisLineHasContent: s.thisLineHasContent,
        block: s.block,
        htmlState: CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,
        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,
        inline: s.inline,
        text: s.text,
        linkTitle: s.linkTitle,
        em: s.em,
        strong: s.strong,
        header: s.header,
        taskList: s.taskList,
        list: s.list,
        listDepth: s.listDepth,
        quote: s.quote,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        parentIndentation: s.parentIndentation,
        md_inside: s.md_inside
      };
    },
    token: function (stream, state) {
      if (stream.sol()) {
        if (stream.match(/^\s*$/, true)) {
          state.prevLineHasContent = false;
          return blankLine(state);
        } else {
          state.prevLineHasContent = state.thisLineHasContent;
          state.thisLineHasContent = true;
        }
        // Reset state.header
        state.header = false;
        // Reset state.taskList
        state.taskList = false;
        // Reset state.code
        state.code = false;
        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;
        state.f = state.block;
        var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length - state.parentIndentation;
        var difference = Math.floor((indentation - state.indentation - state.parentIndentation) / 4) * 4;
        if (difference > 4)
          difference = 4;
        var adjustedIndentation = state.indentation + difference - state.parentIndentation;
        state.indentationDiff = adjustedIndentation - state.indentation - state.parentIndentation;
        state.indentation = adjustedIndentation;
        if (indentation > 0)
          return null;
      }
      return state.f(stream, state);
    },
    blankLine: blankLine,
    getType: getType
  };
}, 'xml');
CodeMirror.defineMIME('text/x-markdown', 'markdown');
// Utility function that allows modes to be combined. The mode given
// as the base argument takes care of most of the normal mode
// functionality, but a second (typically simple) mode is used, which
// can override the style of text. Both modes get to parse all of the
// text, but when both assign a non-null style to a piece of code, the
// overlay wins, unless the combine argument was true, in which case
// the styles are combined.
// overlayParser is the old, deprecated name
CodeMirror.overlayMode = CodeMirror.overlayParser = function (base, overlay, combine) {
  return {
    startState: function () {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0,
        baseCur: null,
        overlayPos: 0,
        overlayCur: null
      };
    },
    copyState: function (state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos,
        baseCur: null,
        overlayPos: state.overlayPos,
        overlayCur: null
      };
    },
    token: function (stream, state) {
      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);
      if (stream.eol())
        state.basePos = state.overlayPos = 0;
      if (state.overlayCur == null)
        return state.baseCur;
      if (state.baseCur != null && combine)
        return state.baseCur + ' ' + state.overlayCur;
      else
        return state.overlayCur;
    },
    indent: base.indent && function (state, textAfter) {
      return base.indent(state.base, textAfter);
    },
    electricChars: base.electricChars,
    innerMode: function (state) {
      return {
        state: state.base,
        mode: base
      };
    },
    blankLine: function (state) {
      if (base.blankLine)
        base.blankLine(state.base);
      if (overlay.blankLine)
        overlay.blankLine(state.overlay);
    }
  };
};
(function () {
  'use strict';
  CodeMirror.showHint = function (cm, getHints, options) {
    // We want a single cursor position.
    if (cm.somethingSelected())
      return;
    if (getHints == null)
      getHints = cm.getHelper(cm.getCursor(), 'hint');
    if (getHints == null)
      return;
    if (cm.state.completionActive)
      cm.state.completionActive.close();
    var completion = cm.state.completionActive = new Completion(cm, getHints, options || {});
    CodeMirror.signal(cm, 'startCompletion', cm);
    if (completion.options.async)
      getHints(cm, function (hints) {
        completion.showHints(hints);
      }, completion.options);
    else
      return completion.showHints(getHints(cm, completion.options));
  };
  function Completion(cm, getHints, options) {
    this.cm = cm;
    this.getHints = getHints;
    this.options = options;
    this.widget = this.onClose = null;
  }
  Completion.prototype = {
    close: function () {
      if (!this.active())
        return;
      if (this.widget)
        this.widget.close();
      if (this.onClose)
        this.onClose();
      this.cm.state.completionActive = null;
      CodeMirror.signal(this.cm, 'endCompletion', this.cm);
    },
    active: function () {
      return this.cm.state.completionActive == this;
    },
    pick: function (data, i) {
      var completion = data.list[i];
      if (completion.hint)
        completion.hint(this.cm, data, completion);
      else
        this.cm.replaceRange(getText(completion), data.from, data.to);
      this.close();
    },
    showHints: function (data) {
      if (!data || !data.list.length || !this.active())
        return this.close();
      if (!this.options.ghosting && this.options.completeSingle != false && data.list.length == 1)
        this.pick(data, 0);
      else
        this.showWidget(data);
    },
    showWidget: function (data) {
      this.widget = new Widget(this, data);
      CodeMirror.signal(data, 'shown');
      var debounce = null, completion = this, finished;
      var closeOn = this.options.closeCharacters || /[\s()\[\]{};:>,]/;
      var startPos = this.cm.getCursor(), startLen = this.cm.getLine(startPos.line).length;
      function done() {
        if (finished)
          return;
        finished = true;
        completion.close();
        completion.cm.off('cursorActivity', activity);
        CodeMirror.signal(data, 'close');
      }
      function isDone() {
        if (finished)
          return true;
        if (!completion.widget) {
          done();
          return true;
        }
      }
      function update() {
        if (isDone())
          return;
        if (completion.options.async)
          completion.getHints(completion.cm, finishUpdate, completion.options);
        else
          finishUpdate(completion.getHints(completion.cm, completion.options));
      }
      function finishUpdate(data) {
        if (isDone())
          return;
        if (!data || !data.list.length)
          return done();
        completion.widget.close();
        completion.widget = new Widget(completion, data);
      }
      function activity() {
        clearTimeout(debounce);
        var pos = completion.cm.getCursor(), line = completion.cm.getLine(pos.line);
        if (pos.line != startPos.line || line.length - pos.ch != startLen - startPos.ch || pos.ch < startPos.ch || completion.cm.somethingSelected() || pos.ch && closeOn.test(line.charAt(pos.ch - 1)))
          completion.close();
        else
          debounce = setTimeout(update, 170);
      }
      this.cm.on('cursorActivity', activity);
      this.onClose = done;
    }
  };
  function getText(completion) {
    if (typeof completion == 'string')
      return completion;
    else
      return completion.text;
  }
  function buildKeyMap(options, handle) {
    var baseMap = {
        Up: function () {
          handle.moveFocus(-1);
        },
        Down: function () {
          handle.moveFocus(1);
        },
        PageUp: function () {
          handle.moveFocus(-handle.menuSize());
        },
        PageDown: function () {
          handle.moveFocus(handle.menuSize());
        },
        Home: function () {
          handle.setFocus(0);
        },
        End: function () {
          handle.setFocus(handle.length);
        },
        Enter: handle.pick,
        Tab: handle.pick,
        Esc: handle.close
      };
    var ourMap = options.customKeys ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != 'string')
        bound = function (cm) {
          return val(cm, handle);
        };  // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (options.customKeys)
      for (var key in options.customKeys)
        if (options.customKeys.hasOwnProperty(key))
          addBinding(key, options.customKeys[key]);
    if (options.extraKeys)
      for (var key in options.extraKeys)
        if (options.extraKeys.hasOwnProperty(key))
          addBinding(key, options.extraKeys[key]);
    return ourMap;
  }
  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.options = completion.options || {};
    var widget = this, cm = completion.cm, options = completion.options;
    var hints = this.hints = document.createElement('ul');
    hints.className = 'CodeMirror-hints';
    this.selectedHint = 0;
    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement('li')), cur = completions[i];
      var className = 'CodeMirror-hint' + (i ? '' : ' CodeMirror-hint-active');
      if (cur.className != null)
        className = cur.className + ' ' + className;
      elt.className = className;
      if (cur.render)
        cur.render(elt, data, cur);
      else
        elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }
    var pos = cm.cursorCoords(options.alignWithWord !== false ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + 'px';
    hints.style.top = top + 'px';
    if (this.options.ghosting) {
      hints.style.display = completions.length > 1 ? 'block' : 'none';
    }
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    var box = hints.getBoundingClientRect();
    var overlapX = box.right - winW, overlapY = box.bottom - winH;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + 'px';
        overlapX -= box.right - box.left - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + 'px';
    }
    if (overlapY > 0) {
      var height = box.bottom - box.top;
      if (box.top - (pos.bottom - pos.top) - height > 0) {
        overlapY = height + (pos.bottom - pos.top);
        below = false;
      } else if (height > winH) {
        hints.style.height = winH - 5 + 'px';
        overlapY -= height - winH;
      }
      hints.style.top = (top = pos.bottom - overlapY) + 'px';
    }
    (options.container || document.body).appendChild(hints);
    cm.addKeyMap(this.keyMap = buildKeyMap(options, {
      moveFocus: function (n) {
        widget.changeActive(widget.selectedHint + n);
      },
      setFocus: function (n) {
        widget.changeActive(n);
      },
      menuSize: function () {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function () {
        completion.close();
      },
      pick: function () {
        widget.pick();
      }
    }));
    if (options.closeOnUnfocus !== false) {
      var closingOnBlur;
      cm.on('blur', this.onBlur = function () {
        closingOnBlur = setTimeout(function () {
          completion.close();
        }, 100);
      });
      cm.on('focus', this.onFocus = function () {
        clearTimeout(closingOnBlur);
      });
    }
    var startScroll = cm.getScrollInfo();
    cm.on('scroll', this.onScroll = function () {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below)
        point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom)
        return completion.close();
      hints.style.top = newTop + 'px';
      hints.style.left = left + startScroll.left - curScroll.left + 'px';
    });
    CodeMirror.on(hints, 'dblclick', function (e) {
      var t = widget.getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        widget.pick();
      }
    });
    CodeMirror.on(hints, 'click', function (e) {
      var t = widget.getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null)
        widget.changeActive(t.hintId);
    });
    CodeMirror.on(hints, 'mousedown', function () {
      setTimeout(function () {
        cm.focus();
      }, 20);
    });
    CodeMirror.signal(data, 'select', completions[0], hints.firstChild);
    if (this.options.ghosting && this.data.list[0]) {
      this.removeGhost();
      this.ghost = new Ghost(this, this.data, this.data.list[0].displayText, this.pick.bind(this));
    }
    return true;
  }
  Widget.prototype = {
    close: function () {
      if (this.completion.widget != this)
        return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      this.removeGhost();
      var cm = this.completion.cm;
      if (this.options.closeOnUnfocus !== false) {
        cm.off('blur', this.onBlur);
        cm.off('focus', this.onFocus);
      }
      cm.off('scroll', this.onScroll);
    },
    pick: function () {
      this.completion.pick(this.data, this.selectedHint);
    },
    changeActive: function (i) {
      i = Math.max(0, Math.min(i, this.data.list.length - 1));
      if (this.selectedHint == i)
        return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(' CodeMirror-hint-active', '');
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += ' CodeMirror-hint-active';
      if (this.options.ghosting) {
        this.removeGhost();
        this.ghost = new Ghost(this, this.data, this.data.list[i].displayText, this.pick.bind(this));
      }
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, 'select', this.data.list[this.selectedHint], node);
    },
    screenAmount: function () {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    },
    removeGhost: function () {
      if (!this.ghost) {
        return;
      }
      this.ghost.remove();
      return this;
    },
    getHintElement: function (parent, el) {
      while (el && el !== parent && !this.isHintElement(el)) {
        el = el.parentNode;
      }
      return el === parent ? void 0 : el;
      ;
    },
    isHintElement: function (el) {
      return el.nodeName && el.nodeName.toUpperCase() === 'LI' && el.className.split(/\s/).indexOf('CodeMirror-hint') !== -1;
      ;
    }
  };
  function Ghost(widget, data, text, accept) {
    var that = this;
    this.cm = widget.completion.cm;
    this.data = data;
    this.widget = widget;
    this.completion = widget.completion;
    this.cm.addKeyMap(this.keyMap = {
      'Tab': accept || function () {
        that.accept();
      },
      'Right': accept || function () {
        that.accept();
      }
    });
    if (!text) {
      return this.remove();
    }
    // At the moment, the ghost is going to assume the prefix text is accurate
    var suffix = this.suffix = text.substr(data.word.length);
    if (!suffix.length) {
      return this.remove();
    }
    // Creates the ghost element to be styled.
    var ghostHint = document.createElement('span');
    ghostHint.className = 'CodeMirror-hint-ghost';
    ghostHint.appendChild(document.createTextNode(suffix));
    // Abuse the bookmark feature of CodeMirror to achieve the desired completion
    // effect without modifying source code.
    this._ghost = this.cm.setBookmark(this.data.to, {
      widget: ghostHint,
      insertLeft: true
    });
  }
  Ghost.prototype = {
    accept: function () {
      if (this.suffix && this.data) {
        this.cm.replaceRange(this.suffix, this.data.to, this.data.to);
      }
      return this.remove();
    },
    remove: function () {
      if (this._ghost) {
        this._ghost.clear();
      }
      this.cm.removeKeyMap(this.keyMap);
      delete this.ghost;
      delete this.suffix;
      delete this.widget.ghost;
      return this;
    }
  };
}());
CodeMirror.defineMode('xml', function (config, parserConfig) {
  var indentUnit = config.indentUnit;
  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;
  var Kludges = parserConfig.htmlMode ? {
      autoSelfClosers: {
        'area': true,
        'base': true,
        'br': true,
        'col': true,
        'command': true,
        'embed': true,
        'frame': true,
        'hr': true,
        'img': true,
        'input': true,
        'keygen': true,
        'link': true,
        'meta': true,
        'param': true,
        'source': true,
        'track': true,
        'wbr': true
      },
      implicitlyClosed: {
        'dd': true,
        'li': true,
        'optgroup': true,
        'option': true,
        'p': true,
        'rp': true,
        'rt': true,
        'tbody': true,
        'td': true,
        'tfoot': true,
        'th': true,
        'tr': true
      },
      contextGrabbers: {
        'dd': {
          'dd': true,
          'dt': true
        },
        'dt': {
          'dd': true,
          'dt': true
        },
        'li': { 'li': true },
        'option': {
          'option': true,
          'optgroup': true
        },
        'optgroup': { 'optgroup': true },
        'p': {
          'address': true,
          'article': true,
          'aside': true,
          'blockquote': true,
          'dir': true,
          'div': true,
          'dl': true,
          'fieldset': true,
          'footer': true,
          'form': true,
          'h1': true,
          'h2': true,
          'h3': true,
          'h4': true,
          'h5': true,
          'h6': true,
          'header': true,
          'hgroup': true,
          'hr': true,
          'menu': true,
          'nav': true,
          'ol': true,
          'p': true,
          'pre': true,
          'section': true,
          'table': true,
          'ul': true
        },
        'rp': {
          'rp': true,
          'rt': true
        },
        'rt': {
          'rp': true,
          'rt': true
        },
        'tbody': {
          'tbody': true,
          'tfoot': true
        },
        'td': {
          'td': true,
          'th': true
        },
        'tfoot': { 'tbody': true },
        'th': {
          'td': true,
          'th': true
        },
        'thead': {
          'tbody': true,
          'tfoot': true
        },
        'tr': { 'tr': true }
      },
      doNotIndent: { 'pre': true },
      allowUnquoted: true,
      allowMissing: true
    } : {
      autoSelfClosers: {},
      implicitlyClosed: {},
      contextGrabbers: {},
      doNotIndent: {},
      allowUnquoted: false,
      allowMissing: false
    };
  var alignCDATA = parserConfig.alignCDATA;
  // Return variables for tokenizers
  var tagName, type;
  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }
    var ch = stream.next();
    if (ch == '<') {
      if (stream.eat('!')) {
        if (stream.eat('[')) {
          if (stream.match('CDATA['))
            return chain(inBlock('atom', ']]>'));
          else
            return null;
        } else if (stream.match('--')) {
          return chain(inBlock('comment', '-->'));
        } else if (stream.match('DOCTYPE', true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat('?')) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock('meta', '?>');
        return 'meta';
      } else {
        var isClose = stream.eat('/');
        tagName = '';
        var c;
        while (c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))
          tagName += c;
        if (!tagName)
          return 'error';
        type = isClose ? 'closeTag' : 'openTag';
        state.tokenize = inTag;
        return 'tag';
      }
    } else if (ch == '&') {
      var ok;
      if (stream.eat('#')) {
        if (stream.eat('x')) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(';');
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(';');
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(';');
      }
      return ok ? 'atom' : 'error';
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == '>' || ch == '/' && stream.eat('>')) {
      state.tokenize = inText;
      type = ch == '>' ? 'endTag' : 'selfcloseTag';
      return 'tag';
    } else if (ch == '=') {
      type = 'equals';
      return null;
    } else if (ch == '<') {
      return 'error';
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.eatWhile(/[^\s\u00a0=<>\"\']/);
      return 'word';
    }
  }
  function inAttribute(quote) {
    var closure = function (stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return 'string';
    };
    closure.isInAttribute = true;
    return closure;
  }
  function inBlock(style, terminator) {
    return function (stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function (stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == '<') {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == '>') {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return 'meta';
    };
  }
  var curState, curStream, setStyle;
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--)
      curState.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function pushContext(tagName, startOfLine) {
    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || curState.context && curState.context.noIndent;
    curState.context = {
      prev: curState.context,
      tagName: tagName,
      indent: curState.indented,
      startOfLine: startOfLine,
      noIndent: noIndent
    };
  }
  function popContext() {
    if (curState.context)
      curState.context = curState.context.prev;
  }
  function element(type) {
    if (type == 'openTag') {
      curState.tagName = tagName;
      curState.tagStart = curStream.column();
      return cont(attributes, endtag(curState.startOfLine));
    } else if (type == 'closeTag') {
      var err = false;
      if (curState.context) {
        if (curState.context.tagName != tagName) {
          if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
            popContext();
          }
          err = !curState.context || curState.context.tagName != tagName;
        }
      } else {
        err = true;
      }
      if (err)
        setStyle = 'error';
      return cont(endclosetag(err));
    }
    return cont();
  }
  function endtag(startOfLine) {
    return function (type) {
      var tagName = curState.tagName;
      curState.tagName = curState.tagStart = null;
      if (type == 'selfcloseTag' || type == 'endTag' && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {
        maybePopContext(tagName.toLowerCase());
        return cont();
      }
      if (type == 'endTag') {
        maybePopContext(tagName.toLowerCase());
        pushContext(tagName, startOfLine);
        return cont();
      }
      return cont();
    };
  }
  function endclosetag(err) {
    return function (type) {
      if (err)
        setStyle = 'error';
      if (type == 'endTag') {
        popContext();
        return cont();
      }
      setStyle = 'error';
      return cont(arguments.callee);
    };
  }
  function maybePopContext(nextTagName) {
    var parentTagName;
    while (true) {
      if (!curState.context) {
        return;
      }
      parentTagName = curState.context.tagName.toLowerCase();
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext();
    }
  }
  function attributes(type) {
    if (type == 'word') {
      setStyle = 'attribute';
      return cont(attribute, attributes);
    }
    if (type == 'endTag' || type == 'selfcloseTag')
      return pass();
    setStyle = 'error';
    return cont(attributes);
  }
  function attribute(type) {
    if (type == 'equals')
      return cont(attvalue, attributes);
    if (!Kludges.allowMissing)
      setStyle = 'error';
    else if (type == 'word') {
      setStyle = 'attribute';
      return cont(attribute, attributes);
    }
    return type == 'endTag' || type == 'selfcloseTag' ? pass() : cont();
  }
  function attvalue(type) {
    if (type == 'string')
      return cont(attvaluemaybe);
    if (type == 'word' && Kludges.allowUnquoted) {
      setStyle = 'string';
      return cont();
    }
    setStyle = 'error';
    return type == 'endTag' || type == 'selfCloseTag' ? pass() : cont();
  }
  function attvaluemaybe(type) {
    if (type == 'string')
      return cont(attvaluemaybe);
    else
      return pass();
  }
  return {
    startState: function () {
      return {
        tokenize: inText,
        cc: [],
        indented: 0,
        startOfLine: true,
        tagName: null,
        tagStart: null,
        context: null
      };
    },
    token: function (stream, state) {
      if (!state.tagName && stream.sol()) {
        state.startOfLine = true;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace())
        return null;
      setStyle = type = tagName = null;
      var style = state.tokenize(stream, state);
      state.type = type;
      if ((style || type) && style != 'comment') {
        curState = state;
        curStream = stream;
        while (true) {
          var comb = state.cc.pop() || element;
          if (comb(type || style))
            break;
        }
      }
      state.startOfLine = false;
      return setStyle || style;
    },
    indent: function (state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        return state.stringStartCol + 1;
      }
      if (state.tokenize != inTag && state.tokenize != inText || context && context.noIndent)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (multilineTagIndentPastTag)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * multilineTagIndentFactor;
      }
      if (alignCDATA && /<!\[CDATA\[/.test(textAfter))
        return 0;
      if (context && /^<\//.test(textAfter))
        context = context.prev;
      while (context && !context.startOfLine)
        context = context.prev;
      if (context)
        return context.indent + indentUnit;
      else
        return 0;
    },
    electricChars: '/',
    blockCommentStart: '<!--',
    blockCommentEnd: '-->',
    configuration: parserConfig.htmlMode ? 'html' : 'xml',
    helperType: parserConfig.htmlMode ? 'html' : 'xml'
  };
});
CodeMirror.defineMIME('text/xml', 'xml');
CodeMirror.defineMIME('application/xml', 'xml');
if (!CodeMirror.mimeModes.hasOwnProperty('text/html'))
  CodeMirror.defineMIME('text/html', {
    name: 'xml',
    htmlMode: true
  });
(function () {
  'use strict';
  angular.module('ramlEditorApp', [
    'ui.bootstrap.modal',
    'ui.bootstrap.tpls',
    'ui.tree',
    'ramlConsoleApp',
    'codeMirror',
    'fs',
    'raml',
    'stringFilters',
    'utils',
    'lightweightDOM',
    'splitter',
    'validate',
    'autoFocus',
    'rightClick',
    'dragAndDrop'
  ]).run([
    '$window',
    function ($window) {
      // Adding proxy settings for api console
      $window.RAML.Settings.proxy = '/proxy/';
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('utils', []).value('indentUnit', 2).factory('safeApply', [
    '$rootScope',
    '$exceptionHandler',
    function safeApplyFactory($rootScope, $exceptionHandler) {
      return function safeApply(scope, expr) {
        scope = scope || $rootScope;
        if ([
            '$apply',
            '$digest'
          ].indexOf(scope.$root && scope.$root.$$phase || scope.$$phase) !== -1) {
          try {
            return scope.$eval(expr);
          } catch (e) {
            $exceptionHandler(e);
          }
        } else {
          return scope.$apply(expr);
        }
      };
    }
  ]).factory('safeApplyWrapper', [
    'safeApply',
    function safeApplyWrapperFactory(safeApply) {
      return function safeApplyWrapper(scope, expr) {
        return function safeApplyWrapperInner1() {
          var args = Array.prototype.slice.call(arguments, 0);
          return safeApply(scope, function safeApplyWrapperInner2() {
            return expr.apply(this, args);
          });
        };
      };
    }
  ]).factory('getTime', function () {
    return Date.now || function () {
      return new Date().getTime();
    };
  }).factory('debounce', [
    '$timeout',
    '$q',
    function debounceFactory($timeout, $q) {
      /**
      * Ensures that a function will be called just once
      * after a period of time expires.
      *
      * @param {Function} target the function to debounce
      * @param {number} wait the wait delay in miliseconds
      */
      return function (target, wait) {
        var timeout = null;
        var deferred = $q.defer();
        return function () {
          var context = this;
          var args = arguments;
          var invokeTarget = function invokeTarget() {
            // call the target function, resolve the promise and reset local state for following calls
            timeout = null;
            deferred.resolve(target.apply(context, args));
            deferred = $q.defer();
          };
          // if timeout exists means that the function is being called again before the delay has finished
          // so we cancel the delayed execution in order to re-schedule it
          timeout && $timeout.cancel(timeout);
          // schedule (or re-schedule) the delayed execution
          timeout = $timeout(invokeTarget, wait);
          // return a promise that will be resolved when the target function is called
          return deferred.promise;
        };
      };
    }
  ]).factory('throttle', [
    'getTime',
    '$timeout',
    function (getTime, $timeout) {
      function throttle(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options || (options = {});
        var later = function () {
          previous = options.leading === false ? 0 : getTime();
          timeout = null;
          result = func.apply(context, args);
        };
        return function () {
          var now = getTime();
          if (!previous && options.leading === false) {
            previous = now;
          }
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0) {
            $timeout.cancel(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
          } else if (!timeout && options.trailing !== false) {
            timeout = $timeout(later, remaining);
          }
          return result;
        };
      }
      return throttle;
    }
  ]).value('generateSpaces', function (spaceCount) {
    spaceCount = spaceCount || 0;
    return new Array(spaceCount + 1).join(' ');
  }).factory('generateTabs', [
    'generateSpaces',
    'indentUnit',
    function (generateSpaces, indentUnit) {
      return function (tabs, customIndentUnit) {
        customIndentUnit = customIndentUnit || indentUnit;
        tabs = tabs || 0;
        return new Array(tabs + 1).join(generateSpaces(indentUnit));
      };
    }
  ]).value('$prompt', function (message, value) {
    return window.prompt(message, value);
  }).value('$confirm', function (message) {
    return window.confirm(message);
  }).factory('generateName', function () {
    // generateName(names, defaultName, extension)
    // Takes a list of names under the current directory, uses defaultName as a pattern,
    // and add enumeration to the end of the defaultName.
    //
    // For example:
    // name        = ["Untitled-1.raml", "Untitled-2.raml", "test.raml"]
    // defaultName = 'Untitled-'
    // extension   = 'raml'
    //
    // will return 'Untitled-3.raml'
    return function generateName(names, defaultName, extension) {
      extension = extension ? '.' + extension : '';
      var currentMax = Math.max.apply(undefined, names.map(function (name) {
          var re = new RegExp(defaultName + '(\\d+)');
          var match = name.match(re);
          return match ? match[1] : 0;
        }).concat(0));
      return defaultName + (currentMax + 1) + extension;
    };
  }).factory('scroll', function () {
    var keys = {
        37: true,
        38: true,
        39: true,
        40: true
      };
    function preventDefault(e) {
      e = e || window.event;
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
    function keyDown(e) {
      if (keys[e.keyCode]) {
        preventDefault(e);
        return;
      }
    }
    function wheel(e) {
      preventDefault(e);
    }
    return {
      enable: function () {
        if (window.removeEventListener) {
          window.removeEventListener('DOMMouseScroll', wheel, false);
        }
        window.onmousewheel = document.onmousewheel = document.onkeydown = null;
      },
      disable: function () {
        if (window.addEventListener) {
          window.addEventListener('DOMMouseScroll', wheel, false);
        }
        window.onmousewheel = document.onmousewheel = wheel;
        document.onkeydown = keyDown;
      }
    };
  }).factory('resolveUri', [
    '$window',
    function resolveUri($window) {
      return function resolveUri(uri) {
        // starts with "http://" OR "https://" OR <scheme>://"
        if (/^\w+:\/\//.test(uri)) {
          return uri;
        }
        // starts with "/"
        if (uri[0] === '/') {
          return $window.location.origin + uri;
        }
        return $window.location.origin + $window.location.pathname.split('/').slice(0, -1).concat(uri).join('/');
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('raml').value('config', {
    set: function (key, value) {
      localStorage['config.' + key] = value;
    },
    get: function (key, defaultValue) {
      key = 'config.' + key;
      if (key in localStorage) {
        return localStorage[key];
      }
      return defaultValue;
    },
    remove: function (key) {
      delete localStorage['config.' + key];
    },
    clear: function () {
      localStorage.clear();
    }
  });
  ;
}());
/**
 * The lightweight-dom module provides a DOM-like API over raml documents. For
 * performance reasons, this DOM is lazy; navigation from one node to
 * another involves parsing RAML rather than walking an actual DOM.
 *
 * The parsing code is built on lightweight-parse, for which this module is
 * intended to be a facade.
 * It is designed for editor purposes and not intended to be a compliant
 * RAML parser, but an MVP implementation designed to make things like reliably
 * showing the right shelf items a matter not of string parsing but of RAML DOM
 * inspection/traversal.
 *
 * Since this is a designer DOM, it attempts to return as much data as possible
 * even if a document is correctly formed. To this end, parents/children are
 * defined as having a less than/greater than tab count. For example:
 * Foo:
 *     Bar:
 *           Baz:
 * The child of Foo is Bar and the child of Bar is Baz. The reverse traversal
 * is Baz to Bar to Foo. So, it is thus up to client code to detect proper
 * nesting by inspecting nodes' tabCount. For example, code could autocorrect
 * users' code, show an error, or ignore the issue and let the user fix the
 * errors themselves.
 */
(function () {
  'use strict';
  angular.module('lightweightDOM', ['lightweightParse']).factory('getNode', [
    'getSpaceCount',
    'getTabCount',
    'getLineIndent',
    'isArrayStarter',
    'isCommentStarter',
    'extractKeyValue',
    function getNodeFactory(getSpaceCount, getTabCount, getLineIndent, isArrayStarter, isCommentStarter, extractKeyValue) {
      var cache = {};
      //region LazyNode Class Definition
      /**
       * Builds a new lazy node from the given content.
       * @param editor The CodeMirror raml editor containing the RAML document
       * @param lineNumber The line to read the node from.
       * @constructor
       * @throws If lineNumber is out of range of the editor's contents
       */
      function LazyNode(editor, lineNumber, line) {
        this.editor = editor;
        this.lineNumber = lineNumber;
        this.line = line;
        this.lineIndent = getLineIndent(this.line, editor.getOption('indentUnit'));
        this.isEmpty = this.lineIndent.spaceCount === this.line.length;
        this.isComment = !this.isEmpty && isCommentStarter(this.line);
        this.isArrayStarter = !this.isComment && isArrayStarter(this.line);
        this.isStructural = !this.isEmpty && !this.isComment;
      }
      LazyNode.prototype.getKeyValue = function getKeyValue() {
        if (!this.keyValue) {
          this.keyValue = extractKeyValue(this.line);
        }
        return this.keyValue;
      };
      LazyNode.prototype.getKey = function getKey() {
        return this.getKeyValue().key;
      };
      LazyNode.prototype.getValue = function getValue() {
        return this.getKeyValue().value;
      };
      /**
       * @returns {LazyNode} The next structural sibling node, or null.
       */
      LazyNode.prototype.getNextSibling = function getNextSibling() {
        // Calculate the correct tab indent for the next sibling:
        // For non-array nodes, the indent is identical
        // For array node, the indent is one greater
        var nextLineNumber = this.lineNumber;
        while (true) {
          var nextNode = getNode(this.editor, ++nextLineNumber);
          if (nextNode === null) {
            return null;
          }
          // Skip empty elements and comments
          if (!nextNode.isStructural) {
            continue;
          }
          // If the next node is at our tab level it is always a sibling
          if (nextNode.lineIndent.tabCount === this.lineIndent.tabCount) {
            return nextNode;
          }
          // Array case:
          // Previous element is non-starter in previous array:
          if (this.isArrayStarter && !nextNode.isArrayStarter && nextNode.lineIndent.tabCount === this.lineIndent.tabCount + 1) {
            return nextNode;
          }
          // Previous element is starter in previous array:
          if (!this.isArrayStarter && nextNode.isArrayStarter && nextNode.lineIndent.tabCount === this.lineIndent.tabCount - 1) {
            return nextNode;
          }
          // If we end up at a lower tab count, then there are no more siblings possible
          if (nextNode.lineIndent.tabCount < this.lineIndent.tabCount) {
            return null;
          }
        }
      };
      /**
       * @returns {LazyNode} The previous structural sibling node, or null.
       */
      LazyNode.prototype.getPreviousSibling = function getPreviousSibling() {
        // Calculate the correct tab indent for the previous sibling:
        // For non-array nodes, the indent is identical
        // For array node, the indent is one less OR an element that is an array starter
        var prevLineNumber = this.lineNumber;
        while (true) {
          prevLineNumber -= 1;
          var prevNode = getNode(this.editor, prevLineNumber);
          if (prevNode === null) {
            return null;
          }
          // Ignore comments and empty lines
          if (!prevNode.isStructural) {
            continue;
          }
          // If the previous node is at our tab level it is always a sibling
          if (prevNode.lineIndent.tabCount === this.lineIndent.tabCount) {
            return prevNode;
          }
          // Array cases:
          // Previous element is non-starter in previous array:
          if (this.isArrayStarter && !prevNode.isArrayStarter && prevNode.lineIndent.tabCount === this.lineIndent.tabCount + 1) {
            return prevNode;
          }
          // Previous element is starter in previous array:
          if (!this.isArrayStarter && prevNode.isArrayStarter && prevNode.lineIndent.tabCount === this.lineIndent.tabCount - 1) {
            return prevNode;
          }
          //If we end up at a lower tab count, then there are no more siblings possible
          if (prevNode.lineIndent.tabCount < this.lineIndent.tabCount) {
            return null;
          }
        }
      };
      /**
       * @returns {LazyNode} The first structural child node, or null.
       */
      LazyNode.prototype.getFirstChild = function getFirstChild() {
        var nextNodeTabCount = this.lineIndent.tabCount + (this.isArrayStarter ? 2 : 1);
        var nextLineNumber = this.lineNumber;
        while (true) {
          var nextNode = getNode(this.editor, ++nextLineNumber);
          if (nextNode === null) {
            return null;
          }
          // If we end up at the same or lower tab count, then there are no children possible
          if (nextNode.lineIndent.tabCount < nextNodeTabCount) {
            return null;
          }
          // look at any node at or beyond the tabCount since the document could be malformed,
          // but we still want to return children.
          if (nextNode.lineIndent.tabCount >= nextNodeTabCount && nextNode.isStructural) {
            return nextNode;
          }
        }
      };
      /**
       * @returns {LazyNode} The parent node, or null if this is a root node
       */
      LazyNode.prototype.getParent = function getParent() {
        // For members of arrays that aren't the first array element, the parent is
        // two tabs over, e.g
        // documentation:
        //   - title: foo
        //     content: bar <- 2 tabs over from parent
        var parentNodeTabCount = this.lineIndent.tabCount - (!this.isArrayStarter && this.getIsInArray() ? 2 : 1);
        var prevLineNumber = this.lineNumber;
        while (true) {
          var prevNode = getNode(this.editor, --prevLineNumber);
          if (prevNode === null) {
            return null;
          }
          // look at any node at or beyond the tabCount since the document could be malformed,
          // but we still want to return a parent if we can find one.
          if (prevNode.lineIndent.tabCount <= parentNodeTabCount && prevNode.isStructural) {
            return prevNode;
          }
        }
      };
      /**
       * @returns {[LazyNode]} All direct descendants of this node
       */
      LazyNode.prototype.getChildren = function getChildren() {
        var children = [];
        var child = this.getFirstChild();
        while (child !== null) {
          children.push(child);
          child = child.getNextSibling();
        }
        return children;
      };
      /**
       * @returns {[LazyNode]} The current node plus any nodes at the same tab
       * level with the same parent. For arrays, returns all members of the
       * node's array. Array consists first of current node, then previous neighbors
       * then next neighbors.
       */
      LazyNode.prototype.getSelfAndNeighbors = function getSelfAndNeighbors() {
        var nodes = [];
        var inArray = this.getIsInArray();
        var node = this;
        while (node && node.getIsInArray() === inArray) {
          nodes.push(node);
          if (node.isArrayStarter) {
            break;
          }
          node = node.getPreviousSibling();
        }
        node = this.getNextSibling();
        while (node && !node.isArrayStarter && node.getIsInArray() === inArray) {
          nodes.push(node);
          node = node.getNextSibling();
        }
        return nodes;
      };
      /**
       * @returns {Boolean} Whether or not the node is in an array
       */
      LazyNode.prototype.getIsInArray = function getIsInArray() {
        // Walk previous siblings until we find one that starts an array, or we run
        // out of siblings.
        // Note: We don't use recursion here since JS has a low recursion limit of 1000
        if (this.isArrayStarter) {
          return true;
        }
        // Move up until we find a node one tab count less: If it is
        // an array starter, we are in an array
        var node = this.getPreviousSibling();
        while (node && node.lineIndent.tabCount >= this.lineIndent.tabCount) {
          node = node.getPreviousSibling();
        }
        return !!(node && node.isArrayStarter && node.lineIndent.tabCount === this.lineIndent.tabCount - 1);
      };
      /**
       * @returns {Array} Returns array containing all parent nodes of
       * this node, with the direct parent being the last element in the
       * array.
       */
      LazyNode.prototype.getPath = function getPath() {
        var path = [];
        var node = this;
        while (node = node.getParent()) {
          path.unshift(node);
        }
        return path;
      };
      /**
       * Executes the testFunc against this node and its parents, moving up the
       * tree until no more nodes are found.  Will halt if the test function
       * returns true.
       * @param testFunc Function to execute against current node and parents
       * @returns {LazyNode} The first node where testFunc returns true, or null.
       */
      LazyNode.prototype.selfOrParent = function selfOrParent(testFunc) {
        return this.first(this.getParent, testFunc);
      };
      /**
       * Executes the testFunc against this node and its prior siblings. Will
       * halt if the test function returns true.
       * @param testFunc Function to execute against current node and parents
       * @returns {LazyNode} The first node where testFunc returns true, or null.
       */
      LazyNode.prototype.selfOrPrevious = function selfOrPrevious(testFunc) {
        return this.first(this.getPreviousSibling, testFunc);
      };
      /**
       * Executes the test function against all nodes, including the current one,
       * returned by nextNodeFunc. Halts when no more nodes are found or testFunc
       * returns a truthy value.
       * @param nextNodeFunc Function that returns the next node to search.
       * @param testFunc Function that returns a node that matches a filter.
       * @returns {LazyNode} The first node where testFunc returns true, or null.
       */
      LazyNode.prototype.first = function first(nextNodeFunc, testFunc) {
        var node = this;
        while (node) {
          if (testFunc(node)) {
            return node;
          }
          node = nextNodeFunc.apply(node);
        }
        return null;
      };
      //endregion
      /**
       * @param editor The CodeMirror raml editor containing the RAML document
       * @param lineNumber The line to read the node from, or the current cursor
       *                line if not specified.
       * @returns {LazyNode} Instance of LazyNode at given line, or null if the
       * line is not a number or out of editor bounds.
       */
      function getNode(editor, lineNumber) {
        // If the line number is a number but out of bounds then we return null.
        // If the line number is not a number, we use the current editor line.
        var cursor = editor.getCursor();
        var codeLineNum = arguments.length > 1 ? lineNumber : cursor.line;
        var line = editor.getLine(codeLineNum);
        var cachedNode = cache[codeLineNum];
        if (line === undefined) {
          return null;
        }
        // Special case: If a node is non-structural, e.g. an empty line or a comment, then by
        // contract with upper layers, we use the cursor position if it is at the line.
        // This matches the behavior of the shelf and autocomplete features.
        // It is, admittedly, a little bit obscure but based on all editor use cases we've looked at, it works.
        if (cursor.line === codeLineNum) {
          var spaceCount = getSpaceCount(line);
          if (spaceCount === line.length || line[spaceCount] === '#') {
            line = line.slice(0, cursor.ch);
          }
        }
        if (!cachedNode || cachedNode.line !== line) {
          cachedNode = cache[codeLineNum] = new LazyNode(editor, codeLineNum, line);
        }
        return cachedNode;
      }
      return getNode;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('lightweightParse', ['utils']).factory('getEditorTextAsArrayOfLines', function getEditorTextAsArrayOfLinesFactory() {
    var cachedValue = '';
    var cachedLines = [];
    return function getEditorTextAsArrayOfLines(editor) {
      if (cachedValue === editor.getValue()) {
        return cachedLines;
      }
      cachedValue = editor.getValue();
      cachedLines = [];
      for (var i = 0, lineCount = editor.lineCount(); i < lineCount; i++) {
        cachedLines.push(editor.getLine(i));
      }
      return cachedLines;
    };
  }).factory('getSpaceCount', function getSpaceCountFactory() {
    return function getSpaceCount(line) {
      for (var i = 0, length = line.length; i < length; i++) {
        if (line[i] !== ' ') {
          break;
        }
      }
      return i;
    };
  }).factory('getTabCount', [
    'indentUnit',
    function getTabCountFactory(indentUnit) {
      return function getTabCount(spaceCount, indentSize) {
        indentSize = indentSize || indentUnit;
        return Math.floor(spaceCount / indentSize);
      };
    }
  ]).factory('getLineIndent', [
    'getSpaceCount',
    'getTabCount',
    function getLineIndentFactory(getSpaceCount, getTabCount) {
      return function getLineIndent(line, indentSize) {
        var spaceCount = getSpaceCount(line);
        return {
          spaceCount: spaceCount,
          tabCount: getTabCount(spaceCount, indentSize),
          content: spaceCount ? line.slice(spaceCount) : line
        };
      };
    }
  ]).factory('isArrayStarter', [
    'getSpaceCount',
    function isArrayStarterFactory(getSpaceCount) {
      return function isArrayStarter(line) {
        var spaceCount = getSpaceCount(line);
        return line[spaceCount] === '-' && line[spaceCount + 1] === ' ';
      };
    }
  ]).factory('isCommentStarter', [
    'getSpaceCount',
    function isCommentStarterFactory(getSpaceCount) {
      return function isCommentStarter(line) {
        var spaceCount = getSpaceCount(line);
        return line[spaceCount] === '#';
      };
    }
  ]).factory('extractKeyValue', function extractKeyValueFactory() {
    /**
       * Removes the whitespaces from the line between start and end indices.
       *
       * @param line The line that needs to be trimmed.
       * @param start The index of left border of the line where trimming should begin.
       * If value is negative, it'll be computed based on length of the line as [length + start].
       * @param end The index of the right border of the line where trimming should end.
       * If value is negative, it'll be computed based on length of the line as [length + end].
       *
       * @returns The trimmed line without whitespaces between start and end.
       */
    function trim(line, start, end) {
      start = start || 0;
      end = end || line.length;
      if (start < 0) {
        start = line.length + start;
      }
      if (end < 0) {
        end = line.length + end;
      }
      while (start < end && line[start] === ' ') {
        start += 1;
      }
      while (start < end && line[end - 1] === ' ') {
        end -= 1;
      }
      if (start === 0 && end === line.length) {
        return line;
      }
      return line.slice(start, end);
    }
    /**
       * Transforms a value which is a string into an object that provides additional
       * information such as whether value is an alias or a reference.
       *
       * @param value The value that needs to be transformed.
       *
       * @returns {{text, isAlias, isReference}}
       */
    function transformValue(value) {
      if (!value) {
        return null;
      }
      return {
        text: value,
        isAlias: value[0] === '&',
        isReference: value[0] === '*'
      };
    }
    return function extractKeyValue(line) {
      var start = 0;
      var end = line.length;
      var indexOf = line.indexOf('#');
      if (indexOf !== -1) {
        end = indexOf;
      }
      indexOf = line.indexOf('- ');
      if (indexOf !== -1 && indexOf < end) {
        start = indexOf + 2;
      }
      indexOf = line.indexOf(': ', start);
      if (indexOf !== -1 && indexOf < end) {
        return {
          key: trim(line, start, indexOf),
          value: transformValue(trim(line, indexOf + 2, end))
        };
      }
      indexOf = line.lastIndexOf(':', end);
      if (indexOf === end - 1) {
        return {
          key: trim(line, start, end - 1),
          value: null
        };
      }
      return {
        key: null,
        value: transformValue(trim(line, start, end))
      };
    };
  }).factory('getScopes', [
    'getLineIndent',
    function getScopesFactory(getLineIndent) {
      var lastArrayCache;
      function areArraysEqual(a, b) {
        if (a === undefined || b === undefined) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      return function getScopes(arrayOfLines) {
        if (lastArrayCache && areArraysEqual(lastArrayCache.key, arrayOfLines)) {
          return lastArrayCache.value;
        }
        var currentIndexes = {};
        var zipValues = arrayOfLines.map(function (line, index) {
            var lineIndentInfo = getLineIndent(line);
            return {
              tabCount: lineIndentInfo.tabCount,
              content: lineIndentInfo.content,
              lineNumber: index
            };
          });
        var levelTable = zipValues.reduce(function (result, currentLine) {
            var currentArray = currentIndexes[currentLine.tabCount - 1], lastArrayIndex, currentIndex;
            if (currentArray) {
              lastArrayIndex = currentArray.length - 1;
              currentIndex = currentIndexes[currentLine.tabCount - 1][lastArrayIndex];
            } else if (currentLine.tabCount > 1) {
              // Case for lists, we fetch a level lower
              currentArray = currentIndexes[currentLine.tabCount - 2];
              // Ignore this line if the tab level is invalid
              if (currentArray) {
                lastArrayIndex = currentArray.length - 1;
                currentIndex = currentIndexes[currentLine.tabCount - 2][lastArrayIndex];
                result[currentIndex] = result[currentIndex] || [];
                result[currentIndex].push({
                  lineNumber: currentLine.lineNumber,
                  content: currentLine.content,
                  tabCount: currentLine.tabCount
                });
                currentIndexes[currentLine.tabCount - 1] = currentIndexes[currentLine.tabCount - 1] || [];
                currentIndexes[currentLine.tabCount - 1].push(currentLine.lineNumber);
              }
              return result;
            } else {
              // Case of the first element of the first level
              currentIndex = 0;
            }
            result[currentIndex] = result[currentIndex] || [];
            result[currentIndex].push({
              lineNumber: currentLine.lineNumber,
              content: currentLine.content,
              tabCount: currentLine.tabCount
            });
            currentIndexes[currentLine.tabCount] = currentIndexes[currentLine.tabCount] || [];
            currentIndexes[currentLine.tabCount].push(currentLine.lineNumber);
            return result;
          }, {});
        lastArrayCache = {
          result: {
            scopeLevels: currentIndexes,
            scopesByLine: levelTable
          },
          lines: arrayOfLines
        };
        return {
          scopeLevels: currentIndexes,
          scopesByLine: levelTable
        };
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeFolding', [
    'raml',
    'lightweightParse'
  ]).factory('getFoldRange', [
    'getLineIndent',
    function getFoldRangeFactory(getLineIndent) {
      return function getFoldRange(cm, start) {
        var line = cm.getLine(start.line);
        var lineIndentInfo = getLineIndent(line);
        var nextLineIndentInfo;
        if (!lineIndentInfo.content) {
          return;
        }
        var nextLine = cm.getLine(start.line + 1);
        if (!nextLine) {
          return;
        }
        var tabCount = lineIndentInfo.tabCount;
        var nextTabCount = getLineIndent(nextLine).tabCount;
        if (nextTabCount > tabCount) {
          for (var i = start.line + 2, end = cm.lineCount(); i < end; i++) {
            nextLine = cm.getLine(i);
            nextLineIndentInfo = getLineIndent(nextLine);
            nextTabCount = nextLineIndentInfo.tabCount;
            if (nextTabCount <= tabCount && nextLineIndentInfo.content) {
              nextLine = cm.getLine(i - 1);
              return {
                from: CodeMirror.Pos(start.line, line.length),
                to: CodeMirror.Pos(i - 1, nextLine.length)
              };
            }
            if (i === end - 1) {
              nextLine = cm.getLine(end - 1);
              return {
                from: CodeMirror.Pos(start.line, line.length),
                to: CodeMirror.Pos(end - 1, nextLine.length)
              };
            }
          }
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror', [
    'raml',
    'ramlEditorApp',
    'codeFolding'
  ]).factory('codeMirror', [
    '$rootScope',
    'ramlSuggest',
    'codeMirrorHighLight',
    'generateSpaces',
    'generateTabs',
    'getFoldRange',
    'isArrayStarter',
    'getSpaceCount',
    'getTabCount',
    'config',
    'extractKeyValue',
    function ($rootScope, ramlSuggest, codeMirrorHighLight, generateSpaces, generateTabs, getFoldRange, isArrayStarter, getSpaceCount, getTabCount, config, extractKeyValue) {
      var editor = null;
      var service = { CodeMirror: CodeMirror };
      service.removeTabs = function (line, indentUnit) {
        var spaceCount = getTabCount(getSpaceCount(line), indentUnit) * indentUnit;
        return spaceCount ? line.slice(spaceCount) : line;
      };
      service.tabKey = function (cm) {
        var cursor = cm.getCursor();
        var line = cm.getLine(cursor.line);
        var indentUnit = cm.getOption('indentUnit');
        var spaces;
        var result;
        var unitsToIndent;
        if (cm.somethingSelected()) {
          cm.indentSelection('add');
          return;
        }
        result = service.removeTabs(line, indentUnit);
        result = result.length ? result : '';
        // if in half/part of a tab, add the necessary spaces to complete the tab
        if (result !== '' && result.replace(/ /g, '') === '') {
          unitsToIndent = indentUnit - result.length;  // if not ident normally
        } else {
          unitsToIndent = indentUnit;
        }
        spaces = generateSpaces(unitsToIndent);
        cm.replaceSelection(spaces, 'end', '+input');
      };
      service.backspaceKey = function (cm) {
        var cursor = cm.getCursor();
        var line = cm.getLine(cursor.line).slice(0, cursor.ch);
        var indentUnit = cm.getOption('indentUnit');
        var spaceCount = line.length - line.replace(/\s+$/, '').length;
        var lineEndsWithTab = spaceCount >= indentUnit;
        // delete indentation if there is at least one right before
        // the cursor and number of whitespaces is a multiple of indentUnit
        //
        // we do it for better user experience as if you had 3 whitespaces
        // before cursor and pressed Backspace, you'd expect cursor to stop
        // at second whitespace to continue typing RAML content, otherwise
        // you'd end up at first whitespace and be forced to hit Spacebar
        if (lineEndsWithTab && spaceCount % indentUnit === 0) {
          for (var i = 0; i < indentUnit; i++) {
            cm.deleteH(-1, 'char');
          }
          return;
        }
        cm.deleteH(-1, 'char');
      };
      var MODES = {
          xml: { name: 'xml' },
          xsd: {
            name: 'xml',
            alignCDATA: true
          },
          json: {
            name: 'javascript',
            json: true
          },
          md: { name: 'gfm' },
          raml: { name: 'raml' }
        };
      var defaultKeys = {
          'Cmd-S': 'save',
          'Ctrl-S': 'save',
          'Shift-Tab': 'indentLess',
          'Shift-Ctrl-T': 'toggleTheme'
        };
      var ramlKeys = {
          'Ctrl-Space': 'autocomplete',
          'Cmd-S': 'save',
          'Ctrl-S': 'save',
          'Shift-Tab': 'indentLess',
          'Shift-Ctrl-T': 'toggleTheme'
        };
      var autocomplete = function onChange(cm) {
        if (cm.getLine(cm.getCursor().line).trim()) {
          cm.execCommand('autocomplete');
        }
      };
      service.configureEditor = function (editor, extension) {
        var mode = MODES[extension] || MODES.raml;
        editor.setOption('mode', mode);
        if (mode.name === 'raml') {
          editor.setOption('extraKeys', ramlKeys);
          editor.on('change', autocomplete);
        } else {
          editor.setOption('extraKeys', defaultKeys);
          editor.off('change', autocomplete);
        }
      };
      service.enterKey = function (cm) {
        function getParent(lineNumber, spaceCount) {
          for (var i = lineNumber - 1; i >= 0; i--) {
            if (getSpaceCount(cm.getLine(i)) < spaceCount) {
              return extractKeyValue(cm.getLine(i)).key;
            }
          }
        }
        var cursor = cm.getCursor();
        var endOfLine = cursor.ch >= cm.getLine(cursor.line).length - 1;
        var line = cm.getLine(cursor.line).slice(0, cursor.ch);
        var lineStartsArray = isArrayStarter(line);
        var spaceCount = getSpaceCount(line);
        var spaces = generateSpaces(spaceCount);
        var parent = getParent(cursor.line, spaceCount);
        var traitOrType = [
            'traits',
            'resourceTypes'
          ].indexOf(parent) !== -1;
        if (endOfLine) {
          (function () {
            if (traitOrType) {
              spaces += generateTabs(2);
              return;
            } else if (lineStartsArray) {
              spaces += generateTabs(1);
            }
            if (line.replace(/\s+$/, '').slice(-1) === '|') {
              spaces += generateTabs(1);
              return;
            }
            var nextLine = cm.getLine(cursor.line + 1);
            if (nextLine && getSpaceCount(nextLine) > spaceCount) {
              spaces += generateTabs(1);
            }
          }());
        } else {
          if (lineStartsArray) {
            spaces += generateTabs(1);
          }
        }
        cm.replaceSelection('\n' + spaces, 'end', '+input');
      };
      service.createEditor = function (el, extraOptions) {
        var shouldEnableFoldGutter = JSON.parse(config.get('folding', 'true'));
        var foldGutterConfig = false;
        var cm;
        var options;
        if (shouldEnableFoldGutter) {
          foldGutterConfig = {
            rangeFinder: CodeMirror.fold.indent,
            foldOnChangeTimeSpan: 300,
            updateViewportTimeSpan: 200
          };
        }
        options = {
          mode: 'raml',
          theme: 'solarized dark',
          lineNumbers: true,
          lineWrapping: true,
          autofocus: true,
          indentWithTabs: false,
          indentUnit: 2,
          tabSize: 2,
          keyMap: 'tabSpace',
          foldGutter: foldGutterConfig,
          gutters: [
            'CodeMirror-lint-markers',
            'CodeMirror-linenumbers',
            'CodeMirror-foldgutter'
          ]
        };
        if (extraOptions) {
          Object.keys(extraOptions).forEach(function (key) {
            options[key] = extraOptions[key];
          });
        }
        cm = new CodeMirror(el, options);
        cm.setSize('100%', '100%');
        cm.foldCode(0, { rangeFinder: CodeMirror.fold.indent });
        var charWidth = cm.defaultCharWidth();
        var basePadding = 4;
        cm.on('renderLine', function (cm, line, el) {
          var offset = CodeMirror.countColumn(line.text, null, cm.getOption('tabSize')) * charWidth;
          el.style.textIndent = '-' + offset + 'px';
          el.style.paddingLeft = basePadding + offset + 'px';
        });
        return cm;
      };
      service.initEditor = function () {
        var el = document.getElementById('code');
        var cm = service.createEditor(el);
        // for testing automation purposes
        editor = window.editor = cm;
        return cm;
      };
      service.getEditor = function () {
        return editor;
      };
      (function bootstrap() {
        CodeMirror.keyMap.tabSpace = {
          Tab: service.tabKey,
          Backspace: service.backspaceKey,
          Enter: service.enterKey,
          fallthrough: ['default']
        };
        CodeMirror.commands.save = function () {
          $rootScope.$broadcast('event:save');
        };
        CodeMirror.commands.autocomplete = function (cm) {
          CodeMirror.showHint(cm, CodeMirror.hint.raml, {
            ghosting: true,
            async: true
          });
        };
        CodeMirror.commands.toggleTheme = function () {
          $rootScope.$broadcast('event:toggle-theme');
        };
        CodeMirror.defineMode('raml', codeMirrorHighLight.highlight);
        CodeMirror.defineMIME('text/x-raml', 'raml');
        CodeMirror.registerHelper('hint', 'raml', ramlSuggest.autocompleteHelper.bind(ramlSuggest));
        CodeMirror.registerHelper('fold', 'indent', getFoldRange);
      }());
      return service;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror').factory('codeMirrorErrors', [
    'codeMirror',
    '$timeout',
    function (codeMirror, $timeout) {
      var CodeMirror = codeMirror.CodeMirror;
      var GUTTER_ID = 'CodeMirror-lint-markers';
      var SEVERITIES = /^(?:error|warning)$/;
      var service = {};
      function showTooltip(content) {
        var tt = document.createElement('div');
        tt.className = 'CodeMirror-lint-tooltip';
        tt.appendChild(content.cloneNode(true));
        if (tt.style.opacity !== null) {
          tt.style.opacity = 1;
        }
        return tt;
      }
      function rm(elt) {
        if (elt.parentNode) {
          elt.parentNode.removeChild(elt);
        }
      }
      function hideTooltip(tt) {
        if (!tt.parentNode) {
          return;
        }
        if (tt.style.opacity === null) {
          rm(tt);
        }
        tt.style.opacity = 0;
        $timeout(function () {
          rm(tt);
        }, 200);
      }
      function showTooltipFor(content, node) {
        var tooltip = showTooltip(content, node);
        node.appendChild(tooltip);
        node.parentElement.parentElement.id = 'tooltip-over';
        var openTrace = function (event) {
          var path = event.target.dataset.path;
          if (path) {
            var $scope = angular.element(event.target).scope();
            $scope.$emit('event:raml-editor-file-select', path);
          }
        };
        function hide() {
          CodeMirror.off(node, 'mouseleave', hide);
          CodeMirror.off(node, 'mousedown', openTrace);
          if (tooltip) {
            hideTooltip(tooltip);
            tooltip = null;
          }
        }
        var poll = setInterval(function () {
            if (tooltip) {
              for (var n = node;; n = n.parentNode) {
                if (n === document.body) {
                  return;
                }
                if (!n) {
                  hide();
                  break;
                }
              }
            } else {
              return clearInterval(poll);
            }
          }, 400);
        CodeMirror.on(node, 'mouseleave', hide);
        CodeMirror.on(node, 'mousedown', openTrace);
      }
      function clearMarks(cm) {
        cm.clearGutter(GUTTER_ID);
      }
      function getMaxSeverity(a, b) {
        return a === 'error' ? a : b;
      }
      function groupByLine(annotations) {
        var lines = [];
        for (var i = 0; i < annotations.length; ++i) {
          var ann = annotations[i], line = ann.line || 1;
          (lines[line] || (lines[line] = [])).push(ann);
        }
        return lines;
      }
      function annotationTooltip(ann) {
        var severity = ann.severity;
        if (!SEVERITIES.test(severity)) {
          severity = 'error';
        }
        var tip = document.createElement('div');
        tip.className = 'CodeMirror-lint-message-' + severity;
        var message = ann.message;
        // if error belongs to different file, add tracing information to message
        if (ann.path) {
          var line = ann.tracingLine + 1;
          message += ' at line ' + line + ' col ' + ann.tracingColumn + ' in ' + '<a href="#/' + ann.path + '" data-path="/' + ann.path + '">' + ann.path + '</a>';
        }
        tip.innerHTML = '<p class=CodeMirror-tag-' + severity + '>' + severity + '</p>' + '<p class="CodeMirror-message">' + message + '</p>';
        return tip;
      }
      function makeMarker(labels, severity, multiple, tooltips, annotations) {
        var marker = document.createElement('div');
        var inner = marker;
        marker.className = 'CodeMirror-lint-marker-' + severity;
        if (multiple) {
          inner = marker.appendChild(document.createElement('div'));
          inner.className = 'CodeMirror-lint-marker-multiple';
        }
        if (tooltips !== false) {
          CodeMirror.on(inner, 'mouseenter', function () {
            showTooltipFor(labels, inner);
          });
        }
        //For testing automation purposes
        marker.setAttribute('data-marker-line', annotations[0].line);
        marker.setAttribute('data-marker-message', annotations[0].message);
        return marker;
      }
      service.displayAnnotations = function (annotationsNotSorted) {
        var editor = codeMirror.getEditor();
        var annotations = groupByLine(annotationsNotSorted);
        this.clearAnnotations();
        for (var line = 0; line < annotations.length; ++line) {
          var anns = annotations[line];
          if (!anns) {
            continue;
          }
          var maxSeverity = null;
          var tipLabel = document.createDocumentFragment();
          for (var i = 0; i < anns.length; ++i) {
            var ann = anns[i];
            var severity = ann.severity;
            if (!SEVERITIES.test(severity)) {
              severity = 'error';
            }
            maxSeverity = getMaxSeverity(maxSeverity, severity);
            tipLabel.appendChild(annotationTooltip(ann));
          }
          editor.setGutterMarker(line - 1, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1, true, anns));
        }
      };
      service.clearAnnotations = function () {
        var editor = codeMirror.getEditor();
        clearMarks(editor);
      };
      return service;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('ramlParserAdapter', [
    '$http',
    '$q',
    '$window',
    function ramlParserAdapter($http, $q, $window) {
      var jsonOptions = {
          serializeMetadata: false,
          dumpSchemaContents: true
        };
      return {
        load: toQ(load),
        loadPath: toQ(loadPath),
        expandApiToJSON: expandApiToJSON
      };
      // ---
      function load(text, contentAsyncFn, options) {
        var virtualPath = '/' + Date.now() + '.raml';
        return loadApi(virtualPath, function contentAsync(path) {
          return path === virtualPath ? $q.when(text) : contentAsyncFn ? contentAsyncFn(path) : $q.reject(new Error('ramlParser: load: contentAsync: ' + path + ': no such path'));
        }, options);
      }
      function loadPath(path, contentAsyncFn, options) {
        return loadApi(path, function contentAsync(path) {
          return contentAsyncFn ? contentAsyncFn(path) : $q.reject(new Error('ramlParser: loadPath: contentAsync: ' + path + ': no such path'));
        }, options);
      }
      // ---
      function toQ(fn) {
        return function toQWrapper() {
          return $q.when(fn.apply(this, arguments));
        };
      }
      function expandApiToJSON(api, expandFlag) {
        api = api.expand ? api.expand(expandFlag) : api;
        var apiJSON = api.toJSON(jsonOptions);
        if (api.uses && api.uses()) {
          apiJSON.uses = {};
          api.uses().forEach(function (usesItem) {
            var libraryAST = usesItem.ast();
            libraryAST = libraryAST.expand ? libraryAST.expand() : libraryAST;
            apiJSON.uses[usesItem.key()] = libraryAST.toJSON(jsonOptions);
          });
        }
        return apiJSON;
      }
      /**
       * @param  {String}   path
       * @param  {Function} contentAsyncFn
       * @param  {Object}   options
       * @param  {Boolean}  options.bypassProxy
       */
      function loadApi(path, contentAsyncFn, options) {
        options = options || {};
        return RAML.Parser.loadApi(path, {
          attributeDefaults: true,
          rejectOnErrors: true,
          fsResolver: {
            contentAsync: contentAsyncFn,
            content: content
          },
          httpResolver: {
            getResourceAsync: function getResourceAsync(url) {
              var settings = ($window.RAML || {}).Settings || {};
              var proxy = (options.bypassProxy ? {} : settings).proxy || '';
              var req = {
                  method: 'GET',
                  url: proxy + url,
                  headers: { 'Accept': 'application/raml+yaml' },
                  transformResponse: null
                };
              return $http(req).then(function (res) {
                return { content: res.data };
              });
              ;
            }
          }
        });
        // ---
        function content(path) {
          throw new Error('ramlParser: loadPath: loadApi: content: ' + path + ': no such path');
        }
      }
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('raml').value('snippets', {
    options: [
      'options:',
      '  description: <<insert text or markdown here>>'
    ],
    head: [
      'head:',
      '  description: <<insert text or markdown here>>'
    ],
    get: [
      'get:',
      '  description: <<insert text or markdown here>>'
    ],
    post: [
      'post:',
      '  description: <<insert text or markdown here>>'
    ],
    put: [
      'put:',
      '  description: <<insert text or markdown here>>'
    ],
    delete: [
      'delete:',
      '  description: <<insert text or markdown here>>'
    ],
    trace: [
      'trace:',
      '  description: <<insert text or markdown here>>'
    ],
    connect: [
      'connect:',
      '  description: <<insert text or markdown here>>'
    ],
    patch: [
      'patch:',
      '  description: <<insert text or markdown here>>'
    ],
    '<resource>': [
      '/newResource:',
      '  displayName: resourceName'
    ],
    title: ['title: My API'],
    version: ['version: v0.1'],
    baseuri: ['baseUri: http://server/api/{version}']
  }).factory('ramlSnippets', [
    'snippets',
    function (snippets) {
      var service = {};
      service.getEmptyRaml = function () {
        return [
          '#%RAML 1.0',
          'title:'
        ].join('\n');
      };
      service.getSnippet = function getSnippet(suggestion) {
        var key = suggestion.key;
        var metadata = suggestion.metadata || {};
        var snippet = snippets[key.toLowerCase()];
        if (snippet) {
          return snippet;
        }
        if (metadata.isText) {
          //For text elements that are part of an array
          //we do not add an empty line break:
          return suggestion.isList ? [key] : [
            key,
            ''
          ];
        }
        return [key + ':'];
      };
      return service;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror').value('highlightRootElement', function (name, titleClass, contentClass, state, level, key) {
    // Using one level of nesting nest (ie. [name + '.level']) instead of
    // [name].level to use default copy state function.
    if (level <= state[name + '.level']) {
      state[name + '.level'] = 0;
      state[name + '.inside'] = false;
    }
    if (name.indexOf(key) >= 0) {
      state[name + '.level'] = level;
      state[name + '.inside'] = true;
      return titleClass;
    }
    if (state[name + '.inside']) {
      return contentClass;
    }
    return false;
  }).value('booleanValues', [
    'true',
    'false'
  ]).factory('keywordRegex', [
    'booleanValues',
    function (booleanValues) {
      return new RegExp('\\b((' + booleanValues.join(')|(') + '))$', 'i');
    }
  ]).factory('token', [
    'keywordRegex',
    'highlightRootElement',
    'getLineIndent',
    'indentUnit',
    function (keywordRegex, highlightRootElement, getLineIndent, indentUnit) {
      return function (stream, state) {
        var ch = stream.peek();
        var esc = state.escaped;
        state.escaped = false;
        /* RAML tag */
        if (ch === '#' && /^#%RAML (0\.8|1\.0|1\.0\s\w+)$/.test(stream.string.trim())) {
          stream.skipToEnd();
          return 'raml-tag';
        }
        /* comments */
        if (ch === '#' && (stream.pos === 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
          stream.skipToEnd();
          return 'comment';
        }
        if (state.literal && stream.indentation() > state.keyCol) {
          stream.skipToEnd();
          return 'none';
        } else if (state.literal) {
          state.literal = false;
        }
        if (stream.sol()) {
          state.keyCol = 0;
          state.pair = false;
          state.pairStart = false;
          /* document start */
          if (stream.match(/---/)) {
            return 'def';
          }
          /* document end */
          if (stream.match(/\.\.\./)) {
            return 'def';
          }
          /* array list item */
          if (stream.match(/\s*-\s+/)) {
            return 'meta';
          }
        }
        /* pairs (associative arrays) -> key */
        if (!state.pair && stream.match(/^\s*([a-z0-9\?\/\{\}\._\-])+(?=\s*:)/i)) {
          var key = stream.string.replace(/^\s+|\s+$/g, '').split(':')[0];
          var sanitizedKey = key.slice(-1) === '?' ? key.slice(0, -1) : key;
          var level = getLineIndent(stream.string).tabCount;
          state.pair = true;
          state.keyCol = stream.indentation();
          if (stream.string.match(/^\s*\- /i)) {
            state.keyCol += indentUnit;
          }
          /* methods */
          if (level <= state.methodLevel || key.indexOf('/') === 0) {
            state.methodLevel = 0;
            state.insideMethod = false;
          }
          if ([
              'options',
              'get',
              'head',
              'post',
              'put',
              'delete',
              'trace',
              'connect',
              'patch'
            ].indexOf(sanitizedKey) !== -1) {
            state.methodLevel = level;
            state.insideMethod = true;
            return 'method-title';
          }
          if (state.insideMethod) {
            return 'method-content';
          }
          var rootElements = highlightRootElement('traits', 'trait-title', 'trait-content', state, level, key) || highlightRootElement('resourceTypes', 'resource-type-title', 'resource-type-content', state, level, key) || highlightRootElement('schemas', 'schema-title', 'schema-content', state, level, key) || highlightRootElement('securitySchemes', 'security-scheme-title', 'security-scheme-content', state, level, key);
          if (rootElements) {
            return rootElements;
          }
          /* resources */
          if (key.indexOf('/') === 0) {
            return 'resource';
          }
          return 'key';
        }
        if (state.pair && stream.match(/^:\s*/)) {
          state.pairStart = true;
          return 'meta';
        }
        /* inline pairs/lists */
        if (stream.match(/^(\{|\}|\[|\])/)) {
          if (ch === '{') {
            state.inlinePairs++;
          } else if (ch === '}') {
            state.inlinePairs--;
          } else if (ch === '[') {
            state.inlineList++;
          } else {
            state.inlineList--;
          }
          return 'meta';
        }
        /* list seperator */
        if (state.inlineList > 0 && !esc && ch === ',') {
          stream.next();
          return 'meta';
        }
        /* pairs seperator */
        if (state.inlinePairs > 0 && !esc && ch === ',') {
          state.keyCol = 0;
          state.pair = false;
          state.pairStart = false;
          stream.next();
          return 'meta';
        }
        /* start of value of a pair */
        if (state.pairStart) {
          /* block literals */
          if (stream.match(/^\s*(\||\>)\s*/)) {
            state.literal = true;
            return 'meta';
          }
          /* references */
          if (stream.match(/^\s*(\&|\*)[a-z0-9\._\-]+\b/i)) {
            return 'variable-2';
          }
          /* numbers */
          if (state.inlinePairs === 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) {
            return 'number';
          }
          if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|\}))/)) {
            return 'number';
          }
          /* keywords */
          if (stream.match(keywordRegex)) {
            return 'keyword';
          }
        }
        /* nothing found, continue */
        state.pairStart = false;
        state.escaped = ch === '\\';
        stream.next();
        return null;
      };
    }
  ]).value('startState', function () {
    return {
      pair: false,
      pairStart: false,
      keyCol: 0,
      inlinePairs: 0,
      inlineList: 0,
      literal: false,
      escaped: false
    };
  }).factory('yamlMode', [
    'token',
    'startState',
    function (token, startState) {
      return function () {
        return {
          token: token,
          startState: startState
        };
      };
    }
  ]).run([
    'codeMirror',
    'yamlMode',
    function (codeMirror, yamlMode) {
      var CodeMirror = codeMirror.CodeMirror;
      CodeMirror.defineMode('yaml', yamlMode);
      CodeMirror.defineMIME('text/x-yaml', 'yaml');
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror').factory('codeMirrorHighLight', [
    'indentUnit',
    function (indentUnit) {
      var mode = {};
      mode.highlight = function highlight(config) {
        mode.indentationOverlay = {
          token: function token(stream, state) {
            if (state.cutoff === undefined || stream.column() <= state.cutoff) {
              if (stream.match('  ')) {
                return 'indent indent-col-' + stream.column();
              } else if (stream.match(' ')) {
                return 'indent-incomplete';
              }
            }
            stream.skipToEnd();
          },
          startState: function startState() {
            return {};
          }
        };
        mode.yaml = CodeMirror.overlayMode(CodeMirror.getMode(config, 'yaml'), mode.indentationOverlay);
        mode.xml = CodeMirror.overlayMode(CodeMirror.getMode(config, 'xml'), mode.indentationOverlay);
        mode.json = CodeMirror.overlayMode(CodeMirror.getMode(config, {
          name: 'javascript',
          json: true
        }), mode.indentationOverlay);
        mode.markdown = CodeMirror.overlayMode(CodeMirror.getMode(config, 'gfm'), mode.indentationOverlay);
        return {
          startState: function startState() {
            return {
              token: mode._yaml,
              localMode: null,
              localState: null,
              yamlState: mode.yaml.startState()
            };
          },
          copyState: function copyState(state) {
            var local;
            if (state.localState) {
              local = CodeMirror.copyState(state.localMode, state.localState);
              if (!local.parentIndentation) {
                local.parentIndentation = state.localState.parentIndentation;
              }
            }
            return {
              token: state.token,
              localMode: state.localMode,
              localState: local,
              yamlState: CodeMirror.copyState(mode.yaml, state.yamlState)
            };
          },
          innerMode: function innerMode(state) {
            return {
              state: state.localState || state.yamlState,
              mode: state.localMode || mode.yaml
            };
          },
          token: function token(stream, state) {
            return state.token(stream, state);
          }
        };
      };
      mode._yaml = function (stream, state) {
        if (/(content|description):(\s?)\|/.test(stream.string)) {
          mode._setMode('markdown', stream, state);
        }
        if (/application\/json:/.test(stream.string)) {
          mode._setMode('json', stream, state, 2);
        }
        if (/text\/xml:/.test(stream.string)) {
          mode._setMode('xml', stream, state, 2);
        }
        return mode.yaml.token(stream, state.yamlState);
      };
      mode._xml = function (stream, state) {
        return mode._applyMode('xml', stream, state);
      };
      mode._json = function (stream, state) {
        return mode._applyMode('json', stream, state);
      };
      mode._markdown = function (stream, state) {
        return mode._applyMode('markdown', stream, state);
      };
      mode._setMode = function (modeName, stream, state, indent) {
        state.token = mode['_' + modeName];
        state.localMode = mode[modeName];
        state.localState = mode[modeName].startState();
        state.localState.parentIndentation = stream.indentation() + (indent || 0);
        if (stream.string.match(/^\s*\- /i)) {
          state.localState.parentIndentation += indentUnit;
        }
        if (modeName === 'markdown') {
          state.localState.base.parentIndentation = state.localState.parentIndentation;
        }
      };
      mode._applyMode = function (modeName, stream, state) {
        if (/(schema|example):(\s?)\|/.test(stream.string)) {
          return mode._yaml(stream, state);
        }
        if (stream.string.trim().length > 0 && stream.indentation() <= state.localState.parentIndentation) {
          state.token = mode._yaml;
          state.localState = state.localMode = null;
          return mode._yaml(stream, state);
        }
        state.localState.overlay.cutoff = state.localState.parentIndentation;
        return mode[modeName].token(stream, state.localState);
      };
      return mode;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  function RamlFile(path, contents, options) {
    options = options || {};
    // remove the trailing slash to path if it exists
    if (path.slice(-1) === '/' && path.length > 1) {
      path = path.slice(0, -1);
    }
    this.type = 'file';
    this.path = path;
    this.name = path.slice(path.lastIndexOf('/') + 1);
    this.isDirectory = false;
    // extract extension
    if (this.name.lastIndexOf('.') > 0) {
      this.extension = this.name.slice(this.name.lastIndexOf('.') + 1);
    }
    this.contents = contents || '';
    this.persisted = options.persisted || false;
    this.dirty = options.dirty || !this.persisted;
    this.root = options.root;
  }
  angular.module('fs', [
    'raml',
    'utils'
  ]).factory('ramlRepository', [
    '$q',
    '$rootScope',
    'ramlSnippets',
    'fileSystem',
    function ($q, $rootScope, ramlSnippets, fileSystem) {
      var service = {};
      var BASE_PATH = '/';
      var rootFile;
      service.supportsFolders = fileSystem.supportsFolders || false;
      function notMetaFile(file) {
        return file.path.slice(-5) !== '.meta';
      }
      function handleErrorFor(file) {
        return function markFileWithError(error) {
          file.error = error;
          throw error;
        };
      }
      /**
        * Function used to compare two ramlFile/ramlDirectory.
        * Sorting policy:
        * - Directories comes before files
        * - Sort file/directories alphabetically
        *
        * @returns {Integer} If the returned value is less than 0, sort a to a lower index than b, vice versa
        */
      function sortingFunction(a, b) {
        if (a.isDirectory === b.isDirectory) {
          return a.name.localeCompare(b.name);
        } else {
          return a.isDirectory ? -1 : 1;
        }
      }
      function findInsertIndex(source, dest) {
        var low = 0, high = dest.children.length - 1, mid;
        while (high >= low) {
          mid = Math.floor((low + high) / 2);
          if (sortingFunction(dest.children[mid], source) > 0) {
            high = mid - 1;
          } else {
            low = mid + 1;
          }
        }
        return low;
      }
      function insertFileSystem(parent, child) {
        // This assumes the paths are correct.
        var before = parent.path === '/' ? [''] : parent.path.split('/');
        var parts = child.path.split('/').slice(0, -1);
        var promise = $q.when(parent);
        parts.slice(before.length).forEach(function (part) {
          promise = promise.then(function (parent) {
            var path = service.join(parent.path, part);
            var exists = service.getByPath(path);
            // If the current path already exists.
            if (exists) {
              if (!exists.isDirectory) {
                return $q.reject(new Error('Can not create directory, file already exists: ' + path));
              }
              return exists;
            }
            return service.createDirectory(parent, part);
          });
        });
        return promise.then(function (parent) {
          var exists = service.getByPath(child.path);
          if (exists) {
            if (exists.isDirectory && child.isDirectory) {
              return exists;
            }
            return $q.reject(new Error('Path already exists: ' + child.path));
          }
          parent.children.splice(findInsertIndex(child, parent), 0, child);
          return child;
        });
      }
      // this function takes a target(ramlFile/ramlDirectory) and a name(String) as input
      // and returns the new path(String) after renaming the target
      function generateNewName(target, newName) {
        var parentPath = target.path.slice(0, target.path.lastIndexOf('/'));
        return parentPath + '/' + newName;
      }
      function RamlDirectory(path, meta, contents) {
        // remove the trailing slash to path if it exists
        if (path.slice(-1) === '/' && path.length > 1) {
          path = path.slice(0, -1);
        }
        contents = contents || [];
        this.type = 'directory';
        this.path = path;
        this.name = path.slice(path.lastIndexOf('/') + 1);
        this.meta = meta;
        this.collapsed = true;
        this.isDirectory = true;
        var separated = {
            folder: [],
            file: []
          };
        contents.forEach(function (entry) {
          separated[entry.type || 'file'].push(entry);
        });
        var files = separated.file.filter(notMetaFile).map(function (file) {
            return new RamlFile(file.path, file.contents, {
              dirty: false,
              persisted: true,
              root: file.root
            });
          });
        var directories = separated.folder.map(function (directory) {
            return new RamlDirectory(directory.path, directory.meta, directory.children);
          });
        this.children = directories.concat(files).sort(sortingFunction);
      }
      RamlDirectory.prototype.getDirectories = function getDirectories() {
        return this.children.filter(function (t) {
          return t.isDirectory;
        });
      };
      RamlDirectory.prototype.getFiles = function getFiles() {
        return this.children.filter(function (t) {
          return !t.isDirectory;
        });
      };
      RamlDirectory.prototype.forEachChildDo = function forEachChildDo(action) {
        // BFS
        var queue = this.children.slice();
        var current;
        while (queue.length > 0) {
          current = queue.shift();
          if (current.isDirectory) {
            queue = queue.concat(current.children);
          }
          action.call(current, current);
        }
      };
      RamlDirectory.prototype.sortChildren = function sortChildren() {
        this.children.sort(sortingFunction);
      };
      // Expose the sorting function
      service.sortingFunction = sortingFunction;
      // Returns the parent directory object of a file or a directory
      service.getParent = function getParent(target) {
        var path = target.path.slice(0, target.path.lastIndexOf('/'));
        if (path.length === 0) {
          path = '/';
        }
        return service.getByPath(path);
      };
      service.canExport = function canExport() {
        return fileSystem.hasOwnProperty('exportFiles');
      };
      service.exportFiles = function exportFiles() {
        return fileSystem.exportFiles();
      };
      service.createDirectory = function createDirectory(parent, name) {
        var path = service.join(parent.path, name);
        var directory = new RamlDirectory(path);
        var exists = service.getByPath(path);
        // If the file already exists, return it.
        if (exists) {
          return $q.when(exists);
        }
        return insertFileSystem(parent, directory).then(function () {
          return fileSystem.createFolder(directory.path);
        }).then(function () {
          return directory;
        });
      };
      service.generateDirectory = function createDirectory(parent, name) {
        return service.createDirectory(parent, name).then(function (directory) {
          $rootScope.$broadcast('event:raml-editor-directory-created', directory);
          return directory;
        });
      };
      // Loads the directory from the fileSystem into memory
      service.loadDirectory = function loadDirectory() {
        return fileSystem.directory(BASE_PATH).then(function (directory) {
          rootFile = new RamlDirectory(directory.path, directory.meta, directory.children);
          return rootFile;
        });
      };
      service.removeDirectory = function removeDirectory(directory) {
        // recursively remove all the child directory and files
        // and collect all promises into an array
        var promises = [];
        directory.getDirectories().forEach(function (dir) {
          promises.push(service.removeDirectory(dir));
        });
        directory.getFiles().forEach(function (file) {
          promises.push(service.removeFile(file));
        });
        // remove this directory object from parent's children list
        var parent = service.getParent(directory);
        var index = parent.children.indexOf(directory);
        if (index !== -1) {
          parent.children.splice(index, 1);
        }
        // make sure all children is removed from FS before we remove ourselves
        return $q.all(promises).then(function () {
          return fileSystem.remove(directory.path);
        }).then(function (directory) {
          $rootScope.$broadcast('event:raml-editor-directory-removed', directory);
        });
      };
      service.renameDirectory = function renameDirectory(directory, newName) {
        var newPath = generateNewName(directory, newName);
        var promise = fileSystem.rename(directory.path, newPath);
        // renames the path of each child under the current directory
        directory.forEachChildDo(function (c) {
          c.path = c.path.replace(directory.path, newPath);
        });
        return promise.then(function () {
          directory.name = newName;
          directory.path = newPath;
          $rootScope.$broadcast('event:raml-editor-filetree-modified', directory);
          return directory;
        }, handleErrorFor(directory));
      };
      service.saveFile = function saveFile(file) {
        function modifyFile() {
          file.dirty = false;
          file.persisted = true;
          return file;
        }
        return fileSystem.save(file.path, file.contents).then(modifyFile, handleErrorFor(file));
      };
      service.renameFile = function renameFile(file, newName) {
        var newPath = generateNewName(file, newName);
        var promise = file.persisted ? fileSystem.rename(file.path, newPath) : $q.when(file);
        function modifyFile() {
          file.name = newName;
          file.path = newPath;
          $rootScope.$broadcast('event:raml-editor-filetree-modified', file);
          return file;
        }
        return promise.then(modifyFile, handleErrorFor(file));
      };
      service.loadFile = function loadFile(file) {
        function modifyFile(data) {
          file.dirty = false;
          file.persisted = true;
          file.loaded = true;
          file.contents = data;
          return file;
        }
        return fileSystem.load(file.path).then(modifyFile, handleErrorFor(file));
        ;
      };
      service.removeFile = function removeFile(file) {
        var promise;
        var parent = service.getParent(file);
        function modifyFile() {
          file.dirty = false;
          file.persisted = false;
          return Object.freeze(file);
        }
        // call to file system only when file is persisted
        // otherwise it's unknown because it's never been saved
        if (file.persisted) {
          promise = fileSystem.remove(file.path);
        } else {
          promise = $q.when(file);
        }
        return promise.then(modifyFile, handleErrorFor(file)).then(function () {
          // remove the file object from the parent's children list
          var index = parent.children.indexOf(file);
          if (index !== -1) {
            parent.children.splice(index, 1);
          }
          $rootScope.$broadcast('event:raml-editor-file-removed', file);
        });
      };
      service.createFile = function createFile(parent, name) {
        var path = service.join(parent.path, name);
        var file = new RamlFile(path);
        return insertFileSystem(parent, file).then(function () {
          $rootScope.$broadcast('event:raml-editor-file-created', file);
          return file;
        });
      };
      service.generateFile = function generateFile(parent, name) {
        return service.createFile(parent, name).then(function (file) {
          if (file.extension === 'raml') {
            file.contents = ramlSnippets.getEmptyRaml();
          }
          $rootScope.$broadcast('event:raml-editor-file-generated', file);
          return file;
        });
      };
      // Gets the ramlDirectory/ramlFile object by path from the memory
      service.getByPath = function getByPath(path) {
        // Nothing to do if no path
        if (!path) {
          return;
        }
        if (path === '/') {
          return rootFile;
        }
        path = path.replace(/\/$/, '');
        var queue = rootFile.children.slice();
        var current;
        while (queue.length) {
          current = queue.shift();
          if (current.path === path) {
            return current;
          }
          if (current.isDirectory) {
            queue = queue.concat(current.children);
          }
        }
      };
      service.rename = function rename(target, newName) {
        return target.isDirectory ? service.renameDirectory(target, newName) : service.renameFile(target, newName);
      };
      service.remove = function remove(target) {
        return target.isDirectory ? service.removeDirectory(target) : service.removeFile(target);
      };
      // move a file or directory to a specific destination
      // destination must be a ramlDirectory
      service.move = function move(target, destination) {
        if (!destination.isDirectory) {
          return;
        }
        var newPath = service.join(destination.path, target.name);
        var promise;
        if (target.isDirectory) {
          promise = fileSystem.rename(target.path, newPath);
          // renames the path of each child under the current directory
          target.forEachChildDo(function (c) {
            c.path = c.path.replace(target.path, newPath);
          });
        } else {
          promise = target.persisted ? fileSystem.rename(target.path, newPath) : $q.when(target);
        }
        return promise.then(function () {
          target.path = newPath;
          return target;
        }, handleErrorFor(target));
      };
      service.saveMeta = function saveMeta(file, meta) {
        var metaFile = new RamlFile(file.path + '.meta', JSON.stringify(meta));
        return service.saveFile(metaFile).then(function () {
          return meta;
        });
        ;
      };
      service.loadMeta = function loadMeta(file) {
        var metaFile = new RamlFile(file.path + '.meta');
        return service.loadFile(metaFile).then(function success(file) {
          return JSON.parse(file.contents);
        }, function failure() {
          return {};
        });
      };
      service.join = function () {
        return Array.prototype.reduce.call(arguments, function (path, segment) {
          if (segment == null) {
            return path;
          }
          if (segment.charAt(0) === '/') {
            return segment;
          }
          return path.replace(/\/$/, '') + '/' + segment;
        }, '/');
      };
      return service;
    }
  ]);
  ;
}());
'use strict';
// Util Functions
function range(start, stop) {
  var result = new Array(stop - start + 1);
  for (var i = start; i <= stop; i++) {
    result[i - start] = i;
  }
  return result;
}
// end Util Functions
var FSResolver = function (homeDirectory, ramlRepository) {
  this.parsePath = function (path) {
    return path.split('/').filter(function (pathMember) {
      return pathMember && pathMember !== '';
    });
  };
  this.getElement = function (path) {
    var pathMembers = this.parsePath(path);
    return this.getElementFromPath(pathMembers, 0, homeDirectory);
  };
  this.getElementFromPath = function (pathMembers, index, element) {
    if (pathMembers.length === index) {
      return element;
    }
    if (!element.isDirectory) {
      return undefined;
    }
    var child = this.getChild(element, pathMembers[index]);
    if (!child) {
      return child;
    }
    return this.getElementFromPath(pathMembers, index + 1, child);
  };
  this.getChild = function (directory, childName) {
    return directory.children.find(function (child) {
      return child.name === childName;
    });
  };
  this.getFileContentAsync = function (file) {
    if (file.loaded && file.doc) {
      return Promise.resolve(file.doc.getValue());
    }
    var getFileContent = function (file) {
      return file.contents;
    };
    return ramlRepository.loadFile(file).then(getFileContent);
  };
  this.contentAsync = function (path) {
    var element = this.getElement(path);
    if (!element || element.isDirectory) {
      return Promise.resolve('');
    }
    return this.getFileContentAsync(element);
  };
  this.list = function (path) {
    var element = this.getElement(path);
    if (!element || !element.isDirectory) {
      return [];
    }
    return element.children.map(function (child) {
      return child.name;
    });
  };
  this.listAsync = function (path) {
    return Promise.resolve(this.list(path));
  };
  this.exists = function (path) {
    return this.getElement(path);
  };
  this.existsAsync = function (path) {
    return Promise.resolve(this.exists(path));
  };
  this.dirname = function (path) {
    var element = this.getElement(path);
    if (!element) {
      return '';
    }
    if (element.isDirectory) {
      return element.path;
    }
    var result = path.substring(0, path.lastIndexOf('/'));
    return result || '';
  };
  this.resolve = function (contextPath, relativePath) {
    if (relativePath.startsWith('/')) {
      return relativePath;
    }
    var pathBeginning = contextPath.endsWith('/') ? contextPath : contextPath + '/';
    return pathBeginning + relativePath;
  };
  this.extname = function (path) {
    var element = this.getElement(path);
    if (element.isDirectory) {
      return '';
    }
    var nameParts = element.name.split('.');
    if (nameParts.length <= 1) {
      return '';
    }
    return nameParts[nameParts.length - 1];
  };
  this.isDirectory = function (path) {
    var element = this.getElement(path);
    return element && element.isDirectory;
  };
  this.isDirectoryAsync = function (path) {
    return Promise.resolve(this.isDirectory(path));
  };
};
var EditorStateProvider = function (fsResolver, path, editor) {
  function sum(total, size) {
    return total + size;
  }
  this.getText = function () {
    return editor.getValue();
  };
  this.getPath = function () {
    return path;
  };
  this.getBaseName = function () {
    var element = fsResolver.getElement(path);
    return element ? element.name : '';
  };
  var calcOffset = function (editor) {
    var cursor = editor.getCursor();
    var allPreviewsLinesSize = range(0, cursor.line - 1).map(function (index) {
        return editor.getLine(index).length + 1;
      }).reduce(sum, 0);
    return allPreviewsLinesSize + cursor.ch;
  };
  this.offset = calcOffset(editor);
  this.getOffset = function () {
    return this.offset;
  };
};
angular.module('ramlEditorApp').factory('ramlSuggest', [
  'ramlRepository',
  function (ramlRepository) {
    function codemirrorHint(editor, suggestions) {
      var currentWord = function (line) {
        if (!line) {
          return '';
        }
        var split = line.split(/:?(:|\s|\[|]|-)+/);
        return split[split.length - 1];
      };
      var render = function (element, self, data) {
        element.innerHTML = [
          '<div>',
          data.displayText,
          '</div>',
          '<div class="category">',
          data.category,
          '</div>'
        ].join('');
      };
      var codemirrorSuggestion = function (suggestion) {
        return {
          displayText: suggestion.displayText || suggestion.text,
          text: suggestion.text,
          category: suggestion.category,
          render: render
        };
      };
      function isWordPartOfTheSuggestion(word, suggestion) {
        if (!word) {
          return true;
        }
        return suggestion.text.startsWith(word) && suggestion.text !== word;
      }
      var cursor = editor.getCursor();
      var line = editor.getLine(cursor.line);
      var word = currentWord(line);
      var toCh = cursor.ch;
      var fromCh = toCh - word.length;
      var codeMirrorSuggestions = suggestions.filter(function (suggestion) {
          return isWordPartOfTheSuggestion(word, suggestion);
        }).map(codemirrorSuggestion);
      return {
        word: word,
        list: codeMirrorSuggestions,
        from: CodeMirror.Pos(cursor.line, fromCh),
        to: CodeMirror.Pos(cursor.line, toCh)
      };
    }
    function beautifyCategoryName(suggestion) {
      if (suggestion.category === undefined || suggestion.category.toLowerCase() === 'unknown') {
        suggestion.category = 'others';
      }
      return suggestion;
    }
    this.getSuggestions = function (homeDirectory, currentFile, editor) {
      var ramlSuggestions = RAML.Suggestions;
      var fsResolver = new FSResolver(homeDirectory, ramlRepository);
      var contentProvider = ramlSuggestions.getContentProvider(fsResolver);
      var editorStateProvider = new EditorStateProvider(fsResolver, currentFile.path, editor);
      return ramlSuggestions.suggestAsync(editorStateProvider, contentProvider).then(function (result) {
        return Array.isArray(result) ? result : [];
      }, function () {
        return [];
      }).then(function (suggestions) {
        return suggestions.map(beautifyCategoryName);
      });
    };
    // class methods
    this.suggest = function (homeDirectory, currentFile, editor) {
      return this.getSuggestions(homeDirectory, currentFile, editor);
    };
    this.autocompleteHelper = function (editor, callback, options, homeDirectory, currentFile) {
      if (!homeDirectory || !currentFile) {
        var $scope = angular.element(editor.getInputField()).scope();
        homeDirectory = homeDirectory || $scope.homeDirectory;
        currentFile = currentFile || $scope.fileBrowser.selectedFile;
      }
      this.getSuggestions(homeDirectory, currentFile, editor).then(function (suggestions) {
        return codemirrorHint(editor, suggestions);
      }).then(function (codemirrorHint) {
        callback(codemirrorHint);
      });
    };
    return this;
  }
]);
(function () {
  'use strict';
  function FileSystem() {
  }
  FileSystem.prototype = {
    directory: function (fullpath) {
      throw 'Not implemented: FileSystem list invoked with [fullpath=' + fullpath + ']';
    },
    save: function (fullpath, content) {
      throw 'Not implemented: FileSystem save invoked with [fullpath=' + fullpath + '] and [content=' + content + ']';
    },
    createFolder: function (fullpath) {
      throw 'Not implemented: FileSystem createFolder invoked with [fullpath=' + fullpath + ']';
    },
    load: function (fullpath) {
      throw 'Not implemented: FileSystem load invoked with [fullpath=' + fullpath + ']';
    },
    loadSync: function (fullpath) {
      throw 'Not implemented: FileSystem load invoked with [fullpath=' + fullpath + ']';
    },
    remove: function (fullpath) {
      throw 'Not implemented: FileSystem remove invoked with [fullpath=' + fullpath + ']';
    },
    rename: function (source, destination) {
      throw 'Not implemented: FileSystem rename invoked with [source=' + source + '] and [destination=' + destination + ']';
    }
  };
  angular.module('fs').factory('fileSystem', [
    '$injector',
    'config',
    function ($injector, config) {
      var fsFactory = config.get('fsFactory');
      var hasFsFactory = fsFactory && $injector.has(fsFactory);
      if (!hasFsFactory) {
        config.set('fsFactory', fsFactory = 'localStorageFileSystem');
      }
      return $injector.get(fsFactory);
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('newFileService', [
    'ramlRepository',
    'newNameModal',
    '$rootScope',
    function newFolderService(ramlRepository, newNameModal, $rootScope) {
      var self = this;
      self.prompt = function prompt(target) {
        var parent = target.isDirectory ? target : ramlRepository.getParent(target);
        var title = 'Add a new file';
        var message = [
            'For a new RAML spec, be sure to name your file <something>.raml; ',
            'For files to be !included, feel free to use an extension or not.'
          ].join('');
        var validations = [{
              message: 'That file name is already taken.',
              validate: function (input) {
                var path = ramlRepository.join(parent.path, input);
                return !ramlRepository.getByPath(path);
              }
            }];
        return newNameModal.open(message, '', validations, title).then(function (name) {
          // Need to catch errors from `generateFile`, otherwise
          // `newNameModel.open` will error random modal close strings.
          return ramlRepository.generateFile(parent, name).catch(function (err) {
            return $rootScope.$broadcast('event:notification', {
              message: err.message,
              expires: true,
              level: 'error'
            });
          });
        });
      };
      return self;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('newFolderService', [
    'ramlRepository',
    'newNameModal',
    function newFolderService(ramlRepository, newNameModal) {
      var self = this;
      self.prompt = function prompt(target) {
        var parent = target.isDirectory ? target : ramlRepository.getParent(target);
        var message = 'Input a name for your new folder:';
        var title = 'Add a new folder';
        var validations = [{
              message: 'That folder name is already taken.',
              validate: function (input) {
                var path = ramlRepository.join(parent.path, input);
                return !ramlRepository.getByPath(path);
              }
            }];
        return newNameModal.open(message, '', validations, title).then(function (name) {
          return ramlRepository.generateDirectory(parent, name);
        });
      };
      return self;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('fs').constant('LOCAL_PERSISTENCE_KEY', 'localStorageFilePersistence').constant('FOLDER', 'folder').factory('localStorageHelper', [
    'LOCAL_PERSISTENCE_KEY',
    function (LOCAL_PERSISTENCE_KEY) {
      return {
        forEach: function (fn) {
          for (var key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
              // A key is a local storage file system entry if it starts
              //with LOCAL_PERSISTENCE_KEY + '.'
              if (key.indexOf(LOCAL_PERSISTENCE_KEY + '.') === 0) {
                fn(JSON.parse(localStorage.getItem(key)));
              }
            }
          }
        },
        has: function (path) {
          var has = false;
          path = path || '/';
          this.forEach(function (entry) {
            if (entry.path.toLowerCase() === path.toLowerCase()) {
              has = true;
            }
          });
          return has;
        },
        set: function (path, content) {
          localStorage.setItem(LOCAL_PERSISTENCE_KEY + '.' + path, JSON.stringify(content));
        },
        get: function (path) {
          return JSON.parse(localStorage.getItem(LOCAL_PERSISTENCE_KEY + '.' + path));
        },
        remove: function (path) {
          localStorage.removeItem(LOCAL_PERSISTENCE_KEY + '.' + path);
        }
      };
    }
  ]).factory('localStorageFileSystem', [
    '$window',
    '$q',
    '$prompt',
    '$timeout',
    'localStorageHelper',
    'FOLDER',
    function ($window, $q, $prompt, $timeout, localStorageHelper, FOLDER) {
      function fileNotFoundMessage(path) {
        return 'file with path="' + path + '" does not exist';
      }
      function addChildren(entry, fn) {
        if (entry.type === FOLDER) {
          entry.children = fn(entry.path);
        }
      }
      function findFolder(path) {
        var entries = [];
        localStorageHelper.forEach(function (entry) {
          if (entry.path.toLowerCase() === path.toLowerCase()) {
            addChildren(entry, findFiles);
            entries.push(entry);
          }
        });
        return entries.length > 0 ? entries[0] : null;
      }
      function findFiles(path) {
        if (path.lastIndexOf('/') !== path.length - 1) {
          path += '/';
        }
        var entries = [];
        localStorageHelper.forEach(function (entry) {
          if (entry.path.toLowerCase() !== path.toLowerCase() && extractParentPath(entry.path) + '/' === path) {
            addChildren(entry, findFiles);
            entries.push(entry);
          }
        });
        return entries;
      }
      /**
       *
       * Save in localStorage entries.
       *
       * File structure are objects that contain the following attributes:
       * * path: The full path (including the filename).
       * * content: The content of the file (only valid for files).
       * * isFolder: A flag that indicates whether is a folder or file.
       */
      var service = {};
      var delay = 500;
      service.supportsFolders = true;
      function validatePath(path) {
        if (path.indexOf('/') !== 0) {
          return {
            valid: false,
            reason: 'Path should start with "/"'
          };
        }
        return { valid: true };
      }
      function isValidParent(path) {
        var parent = extractParentPath(path);
        if (!localStorageHelper.has(parent) && parent !== '') {
          return false;
        }
        return true;
      }
      function hasChildrens(path) {
        var has = false;
        localStorageHelper.forEach(function (entry) {
          if (entry.path.indexOf(path + '/') === 0) {
            has = true;
          }
        });
        return has;
      }
      function extractNameFromPath(path) {
        var pathInfo = validatePath(path);
        if (!pathInfo.valid) {
          throw 'Invalid Path!';
        }
        // When the path is ended in '/'
        if (path.lastIndexOf('/') === path.length - 1) {
          path = path.slice(0, -1);
        }
        return path.slice(path.lastIndexOf('/') + 1);
      }
      function extractParentPath(path) {
        var pathInfo = validatePath(path);
        if (!pathInfo.valid) {
          throw 'Invalid Path!';
        }
        // When the path is ended in '/'
        if (path.lastIndexOf('/') === path.length - 1) {
          path = path.slice(0, -1);
        }
        return path.slice(0, path.lastIndexOf('/'));
      }
      /**
       * List files found in a given path.
       */
      service.directory = function (path) {
        var deferred = $q.defer();
        $timeout(function () {
          var isValidPath = validatePath(path);
          if (!isValidPath.valid) {
            deferred.reject(isValidPath.reason);
            return deferred.promise;
          }
          if (!localStorageHelper.has('/')) {
            localStorageHelper.set(path, {
              path: '/',
              name: '',
              type: 'folder',
              meta: { 'created': Math.round(new Date().getTime() / 1000) }
            });
          }
          deferred.resolve(findFolder(path));
        }, delay);
        return deferred.promise;
      };
      /**
       * Persist a file to an existing folder.
       */
      service.save = function (path, content) {
        var deferred = $q.defer();
        $timeout(function () {
          var name = extractNameFromPath(path);
          var entry = localStorageHelper.get(path);
          if (!isValidParent(path)) {
            deferred.reject(new Error('Parent folder does not exists: ' + path));
            return deferred.promise;
          }
          var file = {};
          if (entry) {
            if (entry.type === FOLDER) {
              deferred.reject('file has the same name as a folder');
              return deferred.promise;
            }
            entry.content = content;
            entry.meta.lastUpdated = Math.round(new Date().getTime() / 1000);
            file = entry;
          } else {
            file = {
              path: path,
              name: name,
              content: content,
              type: 'file',
              meta: { 'created': Math.round(new Date().getTime() / 1000) }
            };
          }
          localStorageHelper.set(path, file);
          deferred.resolve();
        }, delay);
        return deferred.promise;
      };
      /**
       * Create the folders contained in a path.
       */
      service.createFolder = function (path) {
        var deferred = $q.defer();
        var isValidPath = validatePath(path);
        if (!isValidPath.valid) {
          deferred.reject(isValidPath.reason);
          return deferred.promise;
        }
        if (localStorageHelper.has(path)) {
          deferred.reject(new Error('Folder already exists: ' + path));
          return deferred.promise;
        }
        var parent = extractParentPath(path);
        if (!localStorageHelper.has(parent)) {
          deferred.reject(new Error('Parent folder does not exists: ' + path));
          return deferred.promise;
        }
        $timeout(function () {
          localStorageHelper.set(path, {
            path: path,
            name: extractNameFromPath(path),
            type: 'folder',
            meta: { 'created': Math.round(new Date().getTime() / 1000) }
          });
          deferred.resolve();
        }, delay);
        return deferred.promise;
      };
      /**
       * Loads the content of a file.
       */
      service.load = function (path) {
        var deferred = $q.defer();
        $timeout(function () {
          var entry = localStorageHelper.get(path);
          if (entry && entry.type === 'file') {
            deferred.resolve(localStorageHelper.get(path).content);
          } else {
            deferred.reject(fileNotFoundMessage(path));
          }
        }, delay);
        return deferred.promise;
      };
      /**
       * Loads the content of a file.
       */
      service.loadSync = function (path) {
        var entry = localStorageHelper.get(path);
        if (entry && entry.type === 'file') {
          return localStorageHelper.get(path).content;
        } else {
          return fileNotFoundMessage(path);
        }
      };
      /**
       * Removes a file or directory.
       */
      service.remove = function (path) {
        var deferred = $q.defer();
        $timeout(function () {
          var entry = localStorageHelper.get(path);
          if (entry && entry.type === FOLDER && hasChildrens(path)) {
            deferred.reject('folder not empty');
            return deferred.promise;
          }
          localStorageHelper.remove(path);
          deferred.resolve();
        }, delay);
        return deferred.promise;
      };
      /**
       * Renames a file or directory
       */
      service.rename = function (source, destination) {
        var deferred = $q.defer();
        $timeout(function () {
          var sourceEntry = localStorageHelper.get(source);
          if (!sourceEntry) {
            deferred.reject('Source file or folder does not exists.');
            return deferred.promise;
          }
          var destinationEntry = localStorageHelper.get(destination);
          if (destinationEntry) {
            deferred.reject('File or folder already exists.');
            return deferred.promise;
          }
          if (!isValidParent(destination)) {
            deferred.reject('Destination folder does not exist.');
            return deferred.promise;
          }
          sourceEntry.path = destination;
          sourceEntry.name = extractNameFromPath(destination);
          localStorageHelper.remove(destination);
          localStorageHelper.remove(source);
          localStorageHelper.set(destination, sourceEntry);
          if (sourceEntry.type === FOLDER) {
            // if (!isValidPath(destination)) {
            //   deferred.reject('Destination is not a valid folder');
            //   return deferred.promise;
            // }
            //move all child items
            localStorageHelper.forEach(function (entry) {
              if (entry.path.toLowerCase() !== source.toLowerCase() && entry.path.indexOf(source) === 0) {
                var newPath = destination + entry.path.substring(source.length);
                localStorageHelper.remove(entry.path);
                entry.path = newPath;
                localStorageHelper.set(newPath, entry);
              }
            });
          }
          deferred.resolve();
        }, delay);
        return deferred.promise;
      };
      service.exportFiles = function exportFiles() {
        var jszip = new $window.JSZip();
        localStorageHelper.forEach(function (item) {
          // Skip root folder
          if (item.path === '/') {
            return;
          }
          // Skip meta files
          if (item.name.slice(-5) === '.meta') {
            return;
          }
          var path = item.path.slice(1);
          // Remove starting slash
          item.type === 'folder' ? jszip.folder(path) : jszip.file(path, item.content);
        });
        var fileName = $prompt('Please enter a ZIP file name:', 'api.zip');
        fileName && $window.saveAs(jszip.generate({ type: 'blob' }), fileName);
      };
      return service;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('mockingServiceUtils', [
    '$q',
    'jsTraverse',
    'ramlRepository',
    'refParser',
    function mockingServiceUtils($q, jsTraverse, ramlRepository, refParser) {
      return { dereference: dereference };
      // ---
      function dereferenceJsons(raml) {
        return $q.when().then(function () {
          var promises = [];
          jsTraverse.traverse(raml).forEach(function (value) {
            if (this.path.slice(-2).join('.') === 'body.application/json') {
              var jsonSchema;
              if (value.schema) {
                jsonSchema = value.schema;
              } else if (value.type) {
                jsonSchema = value.type;
              }
              if (Array.isArray(jsonSchema)) {
                jsonSchema = jsonSchema[0];
              }
              try {
                promises.push(refParser.dereference(JSON.parse(jsonSchema), { $refs: { read$Ref: read$Ref } }).then(JSON.stringify).then(function (schema) {
                  value.schema = schema;
                }));
              } catch (e) {
              }
            }
          });
          return $q.all(promises);
        });
      }
      function retreiveType(raml, typeName) {
        if (!raml.types) {
          return;
        }
        var object = raml.types.filter(function (type) {
            return type[typeName];
          })[0];
        return object ? object[typeName] : object;
      }
      function dereferenceTypes(raml) {
        jsTraverse.traverse(raml).forEach(function (value) {
          if (this.path.slice(-2).join('.') === 'body.application/json' && value.type) {
            var type = value.type[0];
            var expandedTypeIsDefined = retreiveType(raml, type);
            if (expandedTypeIsDefined) {
              for (var key in expandedTypeIsDefined) {
                if (expandedTypeIsDefined.hasOwnProperty(key)) {
                  value[key] = expandedTypeIsDefined[key];
                }
              }
            }
          }
        });
      }
      function dereference(raml) {
        dereferenceTypes(raml);
        return dereferenceJsons(raml);
      }
      // ---
      function read$Ref($ref) {
        var path = $ref.path[0] === '/' ? $ref.path : '/' + $ref.path;
        var file = ramlRepository.getByPath(path);
        if (file) {
          return file.loaded ? $q.when(file) : ramlRepository.loadFile({ path: path }).then(function (file) {
            return file.contents;
          });
          ;
        }
        return $q.reject('File with path "' + path + '" does not exist');
      }
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('mockingServiceClient', [
    '$http',
    '$q',
    '$window',
    'resolveUri',
    function mockingServiceClientFactory($http, $q, $window, resolveUri) {
      var self = this;
      self.proxy = null;
      // self.baseUri = 'http://mocksvc.mulesoft.com';
      self.baseUri = 'http://ec2-52-201-242-128.compute-1.amazonaws.com';
      self.buildURL = function buildURL() {
        var url = self.baseUri + ['/mocks'].concat(Array.prototype.slice.call(arguments, 0)).join('/');
        var proxy = self.proxy || $window.RAML.Settings.proxy;
        if (proxy) {
          url = proxy + resolveUri(url);
        }
        return url;
      };
      self.simplifyMock = function simplifyMock(mock) {
        return {
          id: mock.id,
          baseUri: mock.baseUri,
          manageKey: mock.manageKey
        };
      };
      self.getMock = function getMock(mock) {
        return $http.get(self.buildURL(mock.id, mock.manageKey)).then(function success(response) {
          return self.simplifyMock(response.data);
        }, function failure(response) {
          if (response.status === 404) {
            return;
          }
          return $q.reject(response);
        });
      };
      self.createMock = function createMock(mock) {
        return $http.post(self.buildURL(), mock).then(function success(response) {
          return self.simplifyMock(response.data);
        });
      };
      self.updateMock = function updateMock(mock) {
        return $http({
          method: 'PATCH',
          url: self.buildURL(mock.id, mock.manageKey),
          data: {
            raml: mock.raml,
            json: mock.json
          }
        }).then(function success(response) {
          return self.simplifyMock(angular.extend(mock, response.data));
        });
      };
      self.deleteMock = function deleteMock(mock) {
        return $http.delete(self.buildURL(mock.id, mock.manageKey));
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('mockingService', [
    'mockingServiceClient',
    'mockingServiceUtils',
    'ramlRepository',
    function mockingServiceFactory(mockingServiceClient, mockingServiceUtils, ramlRepository) {
      var self = this;
      function getMockMeta(file) {
        return ramlRepository.loadMeta(file).then(function success(meta) {
          return meta.mock;
        });
        ;
      }
      function setMockMeta(file, mock) {
        return ramlRepository.loadMeta(file).then(function success(meta) {
          meta.mock = mock;
          return ramlRepository.saveMeta(file, meta);
        }).then(function success() {
          return mock;
        });
        ;
      }
      self.getMock = function getMock(file) {
        return getMockMeta(file);
      };
      self.createMock = function createMock(file, raml) {
        return dereferenceRaml(raml).then(function () {
          return mockingServiceClient.createMock({
            raml: file.contents,
            json: raml
          });
        }).then(function (mock) {
          return setMockMeta(file, mock);
        });
        ;
      };
      self.updateMock = function updateMock(file, raml) {
        return dereferenceRaml(raml).then(function () {
          return getMockMeta(file);
        }).then(function (mock) {
          return mock && mockingServiceClient.updateMock(angular.extend(mock, {
            raml: file.contents,
            json: raml
          }));
        }).then(function (mock) {
          return setMockMeta(file, mock);
        });
        ;
      };
      self.deleteMock = function deleteMock(file) {
        return getMockMeta(file).then(function (mock) {
          return mock && mockingServiceClient.deleteMock(mock);
        }).then(function success() {
          return setMockMeta(file, null);
        });
        ;
      };
      // ---
      function dereferenceRaml(raml) {
        return mockingServiceUtils.dereference(raml).catch(function (error) {
          console.error('dereferenceRaml failed', error.stack);
        });
        ;
      }
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('subMenuService', [
    '$timeout',
    '$window',
    function subMenuService($timeout, $window) {
      this.open = function (scope, subMenuName) {
        $timeout(function () {
          $window.addEventListener('click', function self() {
            scope.$apply(function () {
              scope[subMenuName] = false;
            });
            $window.removeEventListener('click', self);
          });
        });
        scope[subMenuName] = true;
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('importModal', [
    '$modal',
    function importModal($modal) {
      var self = this;
      self.open = function open() {
        return $modal.open({
          templateUrl: 'views/import-modal.html',
          controller: 'ImportController'
        }).result;
        ;
      };
      return self;
    }
  ]).controller('ImportController', [
    '$scope',
    '$modalInstance',
    'swaggerToRAML',
    '$q',
    '$rootScope',
    'importService',
    'ramlRepository',
    function ConfirmController($scope, $modalInstance, swaggerToRAML, $q, $rootScope, importService, ramlRepository) {
      $scope.importing = false;
      $scope.rootDirectory = ramlRepository.getByPath('/');
      // Handles <input type="file" onchange="angular.element(this).scope().handleFileSelect(this)">
      // this workaroud for binding the input file to a model won't work for 1.3.x since scope isn't available in onchange
      $scope.handleFileSelect = function (element) {
        $scope.mode.value = element.files[0];
      };
      function broadcastError(msg) {
        return $rootScope.$broadcast('event:notification', {
          message: msg,
          expires: true,
          level: 'error'
        });
      }
      /**
       * Import files from the local filesystem.
       *
       * @param {Object} mode
       */
      function importFile(mode) {
        if (!$scope.fileSupported) {
          return broadcastError('File upload not supported. Try upgrading your browser.');
        }
        $scope.importing = true;
        return importService.mergeFile($scope.rootDirectory, mode.value).then(function () {
          return $modalInstance.close(true);
        }).catch(function (err) {
          broadcastError(err.message);
        }).finally(function () {
          $scope.importing = false;
        });
      }
      /**
       * Import a RAML file from a Swagger specification.
       */
      function importSwagger(mode) {
        $scope.importing = true;
        // Attempt to import from a Swagger definition.
        return swaggerToRAML.url(mode.value).then(function (contents) {
          var filename = extractFileName(mode.value, 'raml');
          return importService.createAndSaveFile($scope.rootDirectory, filename, contents);
        }).then(function () {
          return $modalInstance.close(true);
        }).catch(function (err) {
          broadcastError('Failed to import Swagger: ' + err.message);
        }).finally(function () {
          $scope.importing = false;
        });
      }
      function importSwaggerZip(mode) {
        $scope.importing = true;
        if (importService.isZip(mode.value)) {
          return swaggerToRAML.zip($scope.rootDirectory, mode.value).then(function () {
            return $modalInstance.close(true);
          }).catch(function (err) {
            broadcastError('Failed to parse Swagger: ' + err.message);
          }).finally(function () {
            $scope.importing = false;
          });
        } else {
          return swaggerToRAML.file(mode.value).then(function (contents) {
            var filename = extractFileName(mode.value.name, 'raml');
            return importService.createAndSaveFile($scope.rootDirectory, filename, contents);
          }).then(function () {
            return $modalInstance.close(true);
          }).catch(function (err) {
            broadcastError('Failed to parse Swagger: ' + err.message);
          }).finally(function () {
            $scope.importing = false;
          });
        }
      }
      $scope.options = [
        {
          name: 'file',
          type: 'file',
          callback: importFile
        },
        {
          name: 'Swagger spec',
          type: 'swagger',
          callback: importSwagger
        },
        {
          name: 'Swagger file',
          type: 'zip',
          callback: importSwaggerZip
        }
      ];
      $scope.mode = $scope.options[0];
      // Check whether file import is supported.
      $scope.fileSupported = !!(window.File && window.FileReader && window.FileList && window.Blob);
      /**
       * Import using either import modes.
       *
       * @param {Object} form
       */
      $scope.import = function (form) {
        form.$submitted = true;
        $scope.submittedType = $scope.mode.type;
        if (form.$invalid || $scope.importing) {
          return;
        }
        try {
          return $scope.mode.callback($scope.mode);
        } catch (err) {
          $scope.importing = false;
          broadcastError(err);
        }
      };
      /**
       * Extract a usable filename from a path.
       *
       * @param  {String} path
       * @param  {String} [ext]
       * @return {String}
       */
      function extractFileName(path, ext) {
        var name = path.replace(/\/*$/, '');
        var index = name.lastIndexOf('/');
        if (index > -1) {
          name = name.substr(index);
        }
        if (ext) {
          name = name.replace(/\.[^\.]*$/, '') + '.' + ext;
        }
        return name;
      }
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('confirmModal', [
    '$rootScope',
    '$modal',
    function confirmModal($rootScope, $modal) {
      var self = this;
      /**
       * @param {String} title
       * @param {String} message
       * @param {Object} [options = {canDiscard, closeButtonLabel, discardButtonLabel, dismissButtonLabel, closeButtonCssClass}]
       */
      self.open = function open(message, title, options) {
        options = angular.extend({
          canDiscard: false,
          closeButtonLabel: 'OK',
          discardButtonLabel: 'Discard',
          dismissButtonLabel: 'Cancel',
          closeButtonCssClass: 'btn-primary'
        }, options);
        return $modal.open({
          templateUrl: 'views/confirm-modal.html',
          controller: 'ConfirmController',
          scope: angular.extend($rootScope.$new(), {
            title: title,
            message: message,
            canDiscard: options.canDiscard,
            closeButtonLabel: options.closeButtonLabel,
            discardButtonLabel: options.discardButtonLabel,
            dismissButtonLabel: options.dismissButtonLabel,
            closeButtonCssClass: options.closeButtonCssClass
          })
        }).result;
        ;
      };
      return self;
    }
  ]).controller('ConfirmController', [
    '$modalInstance',
    '$scope',
    function ConfirmController($modalInstance, $scope) {
      $scope.discard = function discard() {
        $modalInstance.dismiss(angular.extend(new Error(), { discard: true }));
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('newNameModal', [
    '$modal',
    function newNameModal($modal) {
      var self = this;
      self.open = function open(message, defaultName, validations, title) {
        return $modal.open({
          templateUrl: 'views/new-name-modal.html',
          controller: 'NewNameController',
          windowClass: 'modal in',
          resolve: {
            message: function messageResolver() {
              return message;
            },
            title: function titleResolver() {
              return title;
            },
            defaultName: function defaultNameResolver() {
              return defaultName;
            },
            validations: function validationsResolver() {
              return validations;
            }
          }
        }).result;
        ;
      };
      return self;
    }
  ]).controller('NewNameController', [
    '$modalInstance',
    '$scope',
    'message',
    'defaultName',
    'validations',
    'title',
    function NewNameController($modalInstance, $scope, message, defaultName, validations, title) {
      $scope.input = {
        newName: defaultName,
        message: message,
        title: title
      };
      $scope.validationErrorMessage = '';
      $scope.isValid = function isValid(value) {
        if (value) {
          for (var i = 0; i < validations.length; i++) {
            if (!validations[i].validate(value)) {
              $scope.validationErrorMessage = validations[i].message;
              return false;
            }
          }
        }
        return true;
      };
      $scope.submit = function submit(form) {
        if (form.$invalid) {
          form.$submitted = true;
          return;
        }
        $modalInstance.close($scope.input.newName);
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('swaggerToRAML', [
    '$window',
    '$q',
    '$http',
    'importService',
    'apiSpecConverter',
    function swaggerToRAML($window, $q, $http, importService, apiSpecConverter) {
      var self = this;
      function replaceExtension(path, ext) {
        var index = path.lastIndexOf('.');
        if (index > -1) {
          path = path.substr(0, index);
        }
        return path + '.' + ext;
      }
      function ramlConverter() {
        return new apiSpecConverter.Converter(apiSpecConverter.Formats.SWAGGER, apiSpecConverter.Formats.RAML10);
      }
      function doConvert(converter, deferred) {
        try {
          converter.convert('yaml', function (err, result) {
            if (err) {
              return deferred.reject(err);
            }
            return deferred.resolve(result);
          });
        } catch (err) {
          deferred.reject(err);
        }
      }
      function convertData(content, deferred, options) {
        var converter = ramlConverter();
        converter.loadData(content, options).then(function () {
          doConvert(converter, deferred);
        }).catch(deferred.reject);
        return deferred;
      }
      function convertZip(root, contents) {
        var decimalRegexp = /^\d+\.\d+$/;
        var swaggerYamlRegexp = /swagger\s*:\s*"{0,1}\d+\.\d+"{0,1}/;
        function isSwaggerSpec(text) {
          try {
            var parsedData = JSON.parse(text);
            return decimalRegexp.test(parsedData.swagger);
          } catch (err) {
            // Possibly YAML Data
            return swaggerYamlRegexp.test(text);
          }
        }
        var converter = function (files, name, deferred) {
          var content = files[name];
          // leave files that are not swagger unmodified
          if (!isSwaggerSpec(content)) {
            return deferred.resolve({
              name: name,
              content: content
            });
          }
          // custom fileResolver to take in memory files from the zip
          var fileResolver = {
              canRead: function (path) {
                return this.read(path) != null;
              },
              read: function (path) {
                var url = path.url.replace(window.location.origin + '/', '');
                for (var f in files) {
                  if (files.hasOwnProperty(f) && f.indexOf(url) > -1) {
                    return files[f];
                  }
                }
                return null;
              }
            };
          // convert main swagger spec
          convertData(content, $q.defer(), {
            resolve: {
              file: fileResolver,
              http: fileResolver
            }
          }).promise.then(function (convertedData) {
            deferred.resolve({
              name: replaceExtension(name, 'raml'),
              content: convertedData
            });
          });
          return deferred.promise;
        };
        return importService.importZip(root, contents, converter);
      }
      self.url = function convert(url) {
        // fetch and convert single file
        var deferred = $q.defer();
        var converter = ramlConverter();
        try {
          converter.loadFile(url, function () {
            doConvert(converter, deferred);
          });
        } catch (err) {
          deferred.reject(err);
        }
        return deferred.promise;
      };
      self.file = function zip(file) {
        var deferred = $q.defer();
        importService.readFile(file).then(function (contents) {
          convertData(contents, deferred);
        }).catch(deferred.reject);
        return deferred.promise;
      };
      self.zip = function zip(rootDirectory, file) {
        var deferred = $q.defer();
        importService.readFile(file).then(function (contents) {
          convertZip(rootDirectory, contents).then(deferred.resolve).catch(deferred.reject);
        }).catch(deferred.reject);
        return deferred.promise;
      };
      return self;
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('importService', [
    '$q',
    '$window',
    'ramlRepository',
    'importServiceConflictModal',
    function importServiceFactory($q, $window, ramlRepository, importServiceConflictModal) {
      var self = this;
      /**
       * Merge a file with the specified directory.
       *
       * @param  {Object}  directory
       * @param  {File}    file
       * @return {Promise}
       */
      self.mergeFile = function (directory, file) {
        // Import every other file as normal.
        if (!self.isZip(file)) {
          return self.importFile(directory, file);
        }
        return self.readFile(file).then(function (contents) {
          return self.mergeZip(directory, contents);
        });
      };
      /**
       * Merge files into the specified directory.
       *
       * @param  {Object}   directory
       * @param  {FileList} files
       * @return {Promise}
       */
      self.mergeFileList = function (directory, files) {
        var imports = Array.prototype.map.call(files, function (file) {
            return function () {
              return self.mergeFile(directory, file);
            };
          });
        return promiseChain(imports);
      };
      /**
       * Import a single entry into the file system.
       *
       * @param  {Object}                     directory
       * @param  {(DirectoryEntry|FileEntry)} entry
       * @return {Promise}
       */
      self.importEntry = function (directory, entry) {
        var deferred = $q.defer();
        if (entry.isFile) {
          entry.file(function (file) {
            var path = ramlRepository.join(directory.path, entry.fullPath);
            return importFileToPath(directory, path, file).then(deferred.resolve, deferred.reject);
          }, deferred.reject);
        } else {
          var reader = entry.createReader();
          reader.readEntries(function (entries) {
            var imports = entries.filter(function (entry) {
                return canImport(entry.name);
              }).map(function (entry) {
                return function () {
                  return self.importEntry(directory, entry);
                };
              });
            return promiseChain(imports).then(deferred.resolve, deferred.reject);
          });
        }
        return deferred.promise;
      };
      /**
       * Import a single item into the file system.
       *
       * @param  {Object}           directory
       * @param  {DataTransferItem} item
       * @return {Promise}
       */
      self.importItem = function (directory, item) {
        if (item.webkitGetAsEntry) {
          return self.importEntry(directory, item.webkitGetAsEntry());
        }
        return self.importFile(directory, item.getAsFile());
      };
      /**
       * Import a single file into the file system.
       *
       * @param  {Object}  directory
       * @param  {File}    file
       * @return {Promise}
       */
      self.importFile = function (directory, file) {
        return importFileToPath(directory, file.name, file);
      };
      /**
       * Import using an event object.
       *
       * @param  {Object}  directory
       * @param  {Object}  e
       * @return {Promise}
       */
      self.importFromEvent = function (directory, e) {
        // Handle items differently since Chrome has support for folders.
        if (e.dataTransfer.items) {
          return self.importItemList(directory, e.dataTransfer.items);
        }
        return self.importFileList(directory, e.dataTransfer.files);
      };
      /**
       * Import an array of items into the file system.
       *
       * @param  {Object}               directory
       * @param  {DataTransferItemList} items
       * @return {Promise}
       */
      self.importItemList = function (directory, items) {
        var imports = Array.prototype.map.call(items, function (item) {
            return function () {
              return self.importItem(directory, item);
            };
          });
        return promiseChain(imports);
      };
      /**
       * Import an array of files into the file system.
       *
       * @param  {Object}   directory
       * @param  {FileList} files
       * @return {Promise}
       */
      self.importFileList = function (directory, files) {
        var imports = Array.prototype.map.call(files, function (file) {
            return function () {
              return self.importFile(directory, file);
            };
          });
        return promiseChain(imports);
      };
      /**
       * Create and save file.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @param  {String}  content
       * @return {Promise}
       */
      self.createAndSaveFile = function (directory, name, content) {
        return self.createFile(directory, name, content).then(function (file) {
          return ramlRepository.saveFile(file);
        });
      };
      /**
       * Create a file in the filesystem.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @param  {String}  contents
       * @return {Promise}
       */
      self.createFile = function (directory, name, contents) {
        return self.checkExistence(directory, name).then(function (option) {
          if (option === importServiceConflictModal.SKIP_FILE) {
            return;
          }
          if (option === importServiceConflictModal.KEEP_FILE) {
            var altname = altFilename(directory, name);
            return createFileFromContents(directory, altname, contents);
          }
          if (option === importServiceConflictModal.REPLACE_FILE) {
            var path = ramlRepository.join(directory.path, name);
            var file = ramlRepository.getByPath(path);
            // Load the file if not loaded.
            return (file.loaded ? $q.when(file) : ramlRepository.loadFile({ path: path })).then(function (theFile) {
              // Check if content has changed.
              if (theFile.contents !== contents) {
                // Load the file current contents.
                file.contents = theFile.contents;
                // Mark the file as loaded.
                file.loaded = true;
                // When replacing a file, if it had not been opened in
                // the Designer yet, it might had not been initialized with its
                // CodeMirror instance.
                // Replace the original file contents with the imported file
                // contents.
                if (!file.doc) {
                  file.doc = new CodeMirror.Doc(contents);
                } else {
                  file.doc.setValue(contents);
                }
                // Mark the file as dirty.
                file.dirty = true;
                return file;
              }
            });
            ;
          }
          return createFileFromContents(directory, name, contents);
        });
      };
      /**
       * Create a directory in the filesystem.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @return {Promise}
       */
      self.createDirectory = function (directory, name) {
        return ramlRepository.createDirectory(directory, name);
      };
      /**
       * Check whether a file exists and make a decision based on that.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @return {Promise}
       */
      self.checkExistence = function (directory, name) {
        var path = ramlRepository.join(directory.path, name);
        if (!pathExists(path)) {
          return $q.when(null);
        }
        return importServiceConflictModal.open(path);
      };
      /**
       * Check whether a file is a zip.
       *
       * @param  {File}    file
       * @return {Boolean}
       */
      self.isZip = function (file) {
        // Can't check `file.type` as it's empty when read from a `FileEntry`.
        return /\.zip$/i.test(file.name);
      };
      /**
       * Read a file object as a text file.
       *
       * @param  {File}    file
       * @return {Promise}
       */
      self.readFile = function (file) {
        var deferred = $q.defer();
        var reader = new $window.FileReader();
        reader.onload = function () {
          return deferred.resolve(reader.result);
        };
        reader.onerror = function () {
          return deferred.reject(reader.error);
        };
        if (self.isZip(file)) {
          reader.readAsArrayBuffer(file);
        } else {
          reader.readAsText(file);
        }
        return deferred.promise;
      };
      /**
       * Parse a ZIP file.
       *
       * @param  {String} contents
       * @return {Object}
       */
      self.parseZip = function (contents) {
        var zip = new $window.JSZip(contents);
        return sanitizeZipFiles(zip.files);
      };
      /**
       * Merge a zip with a directory in the file system.
       *
       * @param  {Object}  directory
       * @param  {String}  contents
       * @return {Promise}
       */
      self.mergeZip = function (directory, contents) {
        var files = removeCommonFilePrefixes(self.parseZip(contents));
        return importZipFiles(directory, files);
      };
      /**
       * Import a zip file into the current directory.
       *
       * @param  {Object}  directory
       * @param  {String}  contents
       * @param  {Function}  converter
       * @return {Promise}
       */
      self.importZip = function (directory, contents, converter) {
        var files = self.parseZip(contents);
        return importZipFiles(directory, files, converter);
      };
      /**
       * Import a single file at specific path.
       *
       * @param  {Object}  directory
       * @param  {String}  path
       * @param  {File}    file
       * @return {Promise}
       */
      function importFileToPath(directory, path, file) {
        return self.readFile(file).then(function (contents) {
          if (self.isZip(file)) {
            // Remove the zip file name from the end of the path.
            var dirname = path.replace(/[\\\/][^\\\/]*$/, '');
            return self.createDirectory(directory, dirname).then(function (directory) {
              return self.importZip(directory, contents);
            });
          }
          return self.createFile(directory, path, contents);
        });
      }
      /**
       * Import files from the zip object.
       *
       * @param  {Object}  directory
       * @param  {Object}  files
       * @param  {Function}  converter
       * @return {Promise}
       */
      function importZipFiles(directory, files, converter) {
        var imports = Object.keys(files).filter(canImport).map(function (name) {
            return function () {
              if (!converter) {
                return self.createAndSaveFile(directory, name, files[name]);
              } else {
                // convert content before importing file
                var defer = $q.defer();
                converter(files, name, defer);
                return defer.promise.then(function (file) {
                  return self.createAndSaveFile(directory, file.name, file.content);
                });
              }
            };
          });
        return promiseChain(imports);
      }
      /**
       * Sanitize a zip file object and remove unwanted metadata.
       *
       * @param  {Object} originalFiles
       * @return {Object}
       */
      function sanitizeZipFiles(originalFiles) {
        var files = {};
        Object.keys(originalFiles).forEach(function (name) {
          if (/^__MACOSX\//.test(name) || /\/$/.test(name)) {
            return;
          }
          files[name] = originalFiles[name].asText();
        });
        return files;
      }
      /**
       * Remove the common file prefix from a files object.
       *
       * @param  {Object} prefixedFiles
       * @return {String}
       */
      function removeCommonFilePrefixes(prefixedFiles) {
        // Sort the file names in order of length to get the common prefix.
        var prefix = Object.keys(prefixedFiles).map(function (name) {
            if (!/[\\\/]/.test(name)) {
              return [];
            }
            return name.replace(/[\\\/][^\\\/]*$/, '').split(/[\\\/]/);
          }).reduce(function (prefix, name) {
            // Iterate over each part and check the prefix matches. If a part
            // does not match, return everything before it as the new prefix.
            for (var i = 0; i < prefix.length; i++) {
              if (name[i] !== prefix[i]) {
                return name.slice(0, i);
              }
            }
            return prefix;
          }).join('/');
        // Return the file object with the same file names.
        if (!prefix) {
          return angular.extend({}, prefixedFiles);
        }
        var files = {};
        // Iterate over the original files and create a new object.
        Object.keys(prefixedFiles).forEach(function (name) {
          var newName = name.substr(prefix.length + 1);
          // If no text is left, it must have been the root directory.
          if (newName) {
            files[newName] = prefixedFiles[name];
          }
        });
        return files;
      }
      /**
       * Check whether a certain file should be imported.
       *
       * @param  {String}  name
       * @return {Boolean}
       */
      function canImport(name) {
        return !/(?:^|[\/\\])\./.test(name);
      }
      /**
       * Check whether the path already exists.
       *
       * @param  {String}  path
       * @return {Boolean}
       */
      function pathExists(path) {
        return !!ramlRepository.getByPath(path);
      }
      /**
       * Create a file in the filesystem without checking prior existence.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @param  {String}  contents
       * @return {Promise}
       */
      function createFileFromContents(directory, name, contents) {
        return ramlRepository.createFile(directory, name).then(function (file) {
          file.contents = contents;
          return file;
        });
      }
      /**
       * Generate an alternative file name for storage.
       *
       * @param  {Object} directory
       * @param  {String} name
       * @return {String}
       */
      function altFilename(directory, name) {
        var path;
        var index = 0;
        var extIndex = name.lastIndexOf('.');
        var basename = extIndex > -1 ? name.substr(0, extIndex) : name;
        var extension = extIndex > -1 ? name.substr(extIndex) : '';
        do {
          var filename = basename + '-' + ++index + extension;
          path = ramlRepository.join(directory.path, filename);
        } while (pathExists(path));
        return path;
      }
      /**
       * Chain promises one after another.
       *
       * @param  {Array}   promises
       * @return {Promise}
       */
      function promiseChain(promises) {
        return promises.reduce(function (promise, chain) {
          return promise.then(chain);
        }, $q.when());
      }
    }
  ]);
}());
(function () {
  'use strict';
  var SKIP_FILE = 0;
  var KEEP_FILE = 1;
  var REPLACE_FILE = 2;
  angular.module('ramlEditorApp').service('importServiceConflictModal', [
    '$modal',
    function newNameModal($modal) {
      var self = this;
      self.open = function open(path) {
        return $modal.open({
          backdrop: 'static',
          templateUrl: 'views/import-service-conflict-modal.html',
          controller: 'ImportServiceConflictModal',
          resolve: {
            path: function pathResolver() {
              return path;
            }
          }
        }).result;
      };
      self.KEEP_FILE = KEEP_FILE;
      self.SKIP_FILE = SKIP_FILE;
      self.REPLACE_FILE = REPLACE_FILE;
      return self;
    }
  ]).controller('ImportServiceConflictModal', [
    '$scope',
    '$modalInstance',
    'path',
    function ImportServiceConflictModal($scope, $modalInstance, path) {
      $scope.path = path;
      $scope.skip = function () {
        $modalInstance.close(SKIP_FILE);
      };
      $scope.keep = function () {
        $modalInstance.close(KEEP_FILE);
      };
      $scope.replace = function () {
        $modalInstance.close(REPLACE_FILE);
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('apiSpecConverter', [
    '$window',
    function apiSpecConverter($window) {
      return $window.apiSpecConverter;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('jsTraverse', [
    '$window',
    function jsTraverse($window) {
      return $window.jsTraverse;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('refParser', [
    '$window',
    function refParser($window) {
      return $window.$RefParser;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('stringFilters', []).filter('dasherize', function () {
    return function (input) {
      return input ? input.toLowerCase().trim().replace(/\s/g, '-') : '';
    };
  });
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').constant('UPDATE_RESPONSIVENESS_INTERVAL', 800).controller('ramlEditorMain', [
    'UPDATE_RESPONSIVENESS_INTERVAL',
    '$scope',
    '$rootScope',
    '$timeout',
    '$window',
    'safeApply',
    'safeApplyWrapper',
    'debounce',
    'throttle',
    'ramlParser',
    'ramlParserAdapter',
    'ramlRepository',
    'codeMirror',
    'codeMirrorErrors',
    'config',
    '$prompt',
    '$confirm',
    '$modal',
    'mockingServiceClient',
    '$q',
    'ramlEditorMainHelpers',
    function (UPDATE_RESPONSIVENESS_INTERVAL, $scope, $rootScope, $timeout, $window, safeApply, safeApplyWrapper, debounce, throttle, ramlParser, ramlParserAdapter, ramlRepository, codeMirror, codeMirrorErrors, config, $prompt, $confirm, $modal, mockingServiceClient, $q, ramlEditorMainHelpers) {
      var editor, lineOfCurrentError, currentFile;
      function extractCurrentFileLabel(file) {
        var label = '';
        if (file) {
          label = file.path;
          if (file.dirty) {
            label = '* ' + label;
          }
        }
        return label;
      }
      function calculatePositionOfErrorMark(currentLine) {
        function onlyFolds(textMark) {
          return textMark.__isFold;
        }
        function toStartingLine(textMark) {
          return textMark.find().from.line;
        }
        function toMinimum(currentMin, val) {
          return Math.min(currentMin, val);
        }
        var position = { line: currentLine };
        return editor.findMarksAt(position).filter(onlyFolds).map(toStartingLine).reduce(toMinimum, lineOfCurrentError);
      }
      function formatErrorMessage(message, actualLine, displayLine) {
        if (displayLine === actualLine) {
          return message;
        }
        return 'Error on line ' + (actualLine + 1) + ': ' + message;
      }
      $window.setTheme = function setTheme(theme) {
        config.set('theme', theme);
        $scope.theme = $rootScope.theme = theme;
        safeApply($scope);
      };
      $scope.$on('event:raml-editor-file-selected', function onFileSelected(event, file) {
        currentFile = file;
        if (ramlEditorMainHelpers.isApiDefinitionLike(file.contents)) {
          // Empty console so that we remove content from previous open RAML file
          $rootScope.$broadcast('event:raml-parsed', {});
        }
        // Every file must have a unique document for history and cursors.
        if (!file.doc) {
          file.doc = new CodeMirror.Doc(file.contents);
        }
        editor.swapDoc(file.doc);
        editor.focus();
        // After swapping the doc, configure the editor for the current file
        // extension.
        codeMirror.configureEditor(editor, file.extension);
        $scope.fileParsable = $scope.getIsFileParsable(file);
        // Inform the editor source has changed. This is also called when the
        // editor triggers the change event, swapping the doc does not trigger
        // that event, so we must explicitly call the sourceUpdated function.
        $scope.sourceUpdated();
      });
      $scope.$watch('fileBrowser.selectedFile.contents', function (contents) {
        if (contents != null && contents !== editor.getValue()) {
          currentFile.doc = new CodeMirror.Doc(contents);
          editor.swapDoc(currentFile.doc);
        }
      });
      var updateFile = debounce(function updateFile() {
          $rootScope.$broadcast('event:file-updated');
        }, config.get('updateResponsivenessInterval', UPDATE_RESPONSIVENESS_INTERVAL));
      $scope.$on('event:raml-editor-file-created', updateFile);
      $scope.$on('event:raml-editor-file-removed', updateFile);
      $scope.$on('event:raml-editor-file-removed', function onFileSelected(event, file) {
        if (currentFile === file) {
          currentFile = undefined;
          editor.swapDoc(new CodeMirror.Doc(''));
        }
      });
      $scope.canExportFiles = function canExportFiles() {
        return ramlRepository.canExport();
      };
      $scope.supportsFolders = ramlRepository.supportsFolders;
      $scope.sourceUpdated = function sourceUpdated() {
        var source = editor.getValue();
        var selectedFile = $scope.fileBrowser.selectedFile;
        $scope.clearErrorMarks();
        selectedFile.contents = source;
        $scope.fileParsable = $scope.getIsFileParsable(selectedFile);
        updateFile();
      };
      $scope.loadRaml = function loadRaml(definition, location) {
        return ramlParserAdapter.loadPath(location, function contentAsync(path) {
          var file = ramlRepository.getByPath(path);
          if (file) {
            return (file.loaded ? $q.when(file) : ramlRepository.loadFile({ path: path })).then(function (file) {
              return file.contents;
            });
            ;
          }
          return $q.reject('ramlEditorMain: loadRaml: contentAsync: ' + path + ': no such path');
        }).then(function (raml) {
          return ramlEditorMainHelpers.isApiDefinitionLike(definition) ? raml : null;
        });
        ;
      };
      $scope.clearErrorMarks = function clearErrorMarks() {
        codeMirrorErrors.clearAnnotations();
        $scope.hasErrors = false;
      };
      $scope.$on('event:file-updated', function onFileUpdated() {
        $scope.clearErrorMarks();
        var file = $scope.fileBrowser.selectedFile;
        if (!file || !$scope.fileParsable || file.contents.trim() === '') {
          $scope.currentError = undefined;
          lineOfCurrentError = undefined;
          return;
        }
        $scope.loadRaml(file.contents, file.path).then(safeApplyWrapper($scope, function success(value) {
          // hack: we have to make a full copy of an object because console modifies
          // it later and makes it unusable for mocking service
          var raml = ramlParserAdapter.expandApiToJSON(value);
          var ramlExpanded = ramlParserAdapter.expandApiToJSON(value, true);
          $scope.fileBrowser.selectedFile.raml = raml;
          $scope.fileBrowser.selectedFile.ramlExpanded = ramlExpanded;
          $rootScope.$broadcast('event:raml-parsed', raml);
        }), safeApplyWrapper($scope, function failure(error) {
          $rootScope.$broadcast('event:raml-parser-error', error);
        }));
      });
      $scope.$on('event:raml-parsed', safeApplyWrapper($scope, function onRamlParser(event, raml) {
        $scope.raml = raml;
        $scope.title = raml && raml.title;
        $scope.version = raml && raml.version;
        $scope.currentError = undefined;
        lineOfCurrentError = undefined;
      }));
      $scope.$on('event:raml-parser-error', safeApplyWrapper($scope, function onRamlParserError(event, error) {
        var parserErrors = error.parserErrors || [{
              line: 0,
              column: 1,
              message: error.message,
              isWarning: error.isWarning
            }];
        codeMirrorErrors.displayAnnotations(parserErrors.map(function mapErrorToAnnotation(error) {
          var errorInfo = error;
          var tracingInfo = {
              line: undefined,
              column: undefined,
              path: undefined
            };
          var needErrorPath = error.trace !== undefined;
          if (needErrorPath) {
            errorInfo = error.trace.find(function getTraceForCurrentFile(trace) {
              return trace.path === event.currentScope.fileBrowser.selectedFile.name;
            });
            tracingInfo = {
              line: (error.range && error.range.start.line || 0) + 1,
              column: error.range && error.range.start.column || 1,
              path: error.path
            };
          }
          return {
            line: (errorInfo.range && errorInfo.range.start.line || 0) + 1,
            column: errorInfo.range && errorInfo.range.start.column || 1,
            message: errorInfo.message,
            severity: errorInfo.isWarning ? 'warning' : 'error',
            path: tracingInfo.path,
            tracingLine: tracingInfo.line,
            tracingColumn: tracingInfo.column
          };
        }));
      }));
      $scope.openHelp = function openHelp() {
        $modal.open({ templateUrl: 'views/help.html' });
      };
      $scope.getIsFileParsable = function getIsFileParsable(file) {
        return ramlEditorMainHelpers.isRamlFile(file.extension) && ramlEditorMainHelpers.isApiDefinitionLike(file.contents);
      };
      $scope.getIsMockingServiceVisible = function getIsMockingServiceVisible() {
        if ($scope.mockingServiceDisabled || !$scope.fileParsable) {
          return false;
        }
        return true;
      };
      $scope.getIsShelfVisible = function getIsShelfVisible() {
        if (!$scope.fileParsable) {
          return false;
        }
        return true;
      };
      $scope.getIsConsoleVisible = function getIsConsoleVisible() {
        return $scope.fileParsable && $scope.raml;
      };
      $scope.toggleShelf = function toggleShelf() {
        $scope.shelf.collapsed = !$scope.shelf.collapsed;
        config.set('shelf.collapsed', $scope.shelf.collapsed);
      };
      $scope.getSelectedFileAbsolutePath = function getSelectedFileAbsolutePath() {
        return extractCurrentFileLabel(currentFile);
      };
      $scope.$on('event:toggle-theme', function onToggleTheme() {
        $window.setTheme($scope.theme === 'dark' ? 'light' : 'dark');
      });
      (function bootstrap() {
        $scope.currentError = undefined;
        $scope.theme = $rootScope.theme = config.get('theme', 'dark');
        $scope.shelf = {};
        $scope.shelf.collapsed = JSON.parse(config.get('shelf.collapsed', 'false'));
        $scope.editor = editor = codeMirror.initEditor();
        editor.on('fold', function (cm, start, end) {
          if (start.line <= lineOfCurrentError && lineOfCurrentError <= end.line) {
            codeMirrorErrors.displayAnnotations([{
                line: start.line + 1,
                message: formatErrorMessage($scope.currentError.message, lineOfCurrentError, start.line)
              }]);
          }
        });
        editor.on('unfold', function () {
          var displayLine = calculatePositionOfErrorMark(lineOfCurrentError);
          var message = formatErrorMessage($scope.currentError.message, lineOfCurrentError, displayLine);
          codeMirrorErrors.displayAnnotations([{
              line: displayLine + 1,
              message: message
            }]);
        });
        editor.on('change', function onChange() {
          $scope.sourceUpdated();
        });
        $window.alreadyNotifiedExit = false;
        $window.editorFilesystemIsDirty = function editorFilesystemIsDirty() {
          var dirtyFile = false;
          $scope.homeDirectory.forEachChildDo(function (t) {
            dirtyFile = t.dirty || dirtyFile;
          });
          return dirtyFile;
        };
        // Warn before leaving the page
        $window.onbeforeunload = function () {
          if (!$window.alreadyNotifiedExit && $window.editorFilesystemIsDirty()) {
            return 'WARNING: You have unsaved changes. Those will be lost if you leave this page.';
          }
        };
        if ($scope.mockingServiceBaseUri) {
          mockingServiceClient.baseUri = $scope.mockingServiceBaseUri;
        }
      }());
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('ramlEditorMainHelpers', function ramlEditorMainHelpers() {
    return {
      isRamlFile: isRamlFile,
      isApiDefinitionLike: isApiDefinitionLike
    };
    // ---
    function isRamlFile(extension) {
      return extension === 'raml';
    }
    function isApiDefinitionLike(raml) {
      return isApiDefinition(raml) || isTypedFragment(raml);
    }
    // ---
    function isApiDefinition(raml) {
      return /^#%RAML\s(0\.8|1\.0)\s*$/.test(getFirstLine(raml));
    }
    function isTypedFragment(raml) {
      return /^#%RAML\s1\.0\s(Trait|ResourceType|Library|Overlay|Extension|DataType|DocumentationItem|NamedExample|AnnotationTypeDeclaration|SecurityScheme)\s*$/.test(getFirstLine(raml));
    }
    function getFirstLine(raml) {
      return raml.split(/\r\n|\n/)[0];
    }
  });
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('applySuggestion', function applySuggestionFactory() {
    return function applySuggestion(editor, suggestion) {
      var replacementPrefix = suggestion.replacementPrefix || '';
      var cursor = editor.getCursor();
      var rangeEnd = cursor;
      var rangeStart = {
          line: cursor.line,
          ch: cursor.ch - replacementPrefix.length
        };
      editor.replaceRange(suggestion.key, rangeStart, rangeEnd);
      var suggestionLines = suggestion.key.split('\n');
      var ch = suggestionLines.length > 1 ? suggestionLines[suggestionLines.length - 1].length : cursor.ch + suggestionLines[0].length - replacementPrefix.length;
      var line = cursor.line + suggestionLines.length - 1;
      editor.setCursor({
        line: line,
        ch: ch
      });
      editor.focus();
    };
  }).factory('newSuggestions', [
    'ramlSuggest',
    function (ramlSuggest) {
      Array.prototype.groupBy = function (key) {
        var addItemToResult = function (result, item) {
          var list = result[item[key]] || [];
          list.push(item);
          result[item[key]] = list;
          return result;
        };
        return this.reduce(addItemToResult, {});
      };
      var createModel = function (suggestions) {
        var items = suggestions.map(function (suggestion) {
            return {
              category: suggestion.category,
              title: suggestion.displayText || suggestion.text,
              key: suggestion.text,
              replacementPrefix: suggestion.replacementPrefix || ''
            };
          });
        var categoryMap = items.groupBy('category');
        var categories = Object.keys(categoryMap).map(function (key) {
            return {
              name: key,
              items: categoryMap[key]
            };
          });
        // model.path = suggestions.path;
        return { categories: categories };  // model
      };
      return function (homeDirectory, selectedFile, editor) {
        return ramlSuggest.suggest(homeDirectory, selectedFile, editor).then(createModel);
      };
    }
  ]).controller('ramlEditorShelf', [
    '$scope',
    'safeApplyWrapper',
    'newSuggestions',
    'applySuggestion',
    function ($scope, safeApplyWrapper, newSuggestions, applySuggestion) {
      var editor = $scope.editor;
      function updateModel(suggestions) {
        $scope.model = suggestions;
        $scope.$digest();
      }
      $scope.cursorMoved = safeApplyWrapper(null, function cursorMoved() {
        newSuggestions($scope.homeDirectory, $scope.fileBrowser.selectedFile, editor).then(updateModel);
      });
      $scope.orderSections = function orderSections(section) {
        var index = [
            'root',
            'docs',
            'methods',
            'parameters',
            'responses',
            'security',
            'resources',
            'traits and types'
          ].indexOf(section.name.toLowerCase());
        return index === -1 ? index.length : index;
      };
      $scope.itemClick = function itemClick(suggestion) {
        applySuggestion(editor, suggestion);
      };
      editor.on('cursorActivity', $scope.cursorMoved);
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').constant('NOTIFICATION_TIMEOUT', 3000).controller('notifications', [
    'NOTIFICATION_TIMEOUT',
    '$scope',
    '$timeout',
    function (NOTIFICATION_TIMEOUT, $scope, $timeout) {
      var notifications = [];
      $scope.shouldDisplayNotifications = false;
      function processNotifications() {
        var args;
        if (notifications.length) {
          args = notifications.splice(0, 1)[0];
          $scope.message = args.message;
          $scope.expires = args.expires;
          $scope.level = args.level || 'info';
          // info, error
          $scope.shouldDisplayNotifications = true;
          if (args.expires) {
            $timeout(function () {
              $scope.shouldDisplayNotifications = false;
              processNotifications();
            }, NOTIFICATION_TIMEOUT);
          }
        }
      }
      $scope.$on('event:notification', function (e, args) {
        notifications.push(JSON.parse(JSON.stringify(args)));
        processNotifications();
      });
      $scope.hideNotifications = function () {
        $scope.shouldDisplayNotifications = false;
        processNotifications();
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').controller('mockingServiceController', [
    '$scope',
    'mockingService',
    'getNode',
    function mockingServiceControllerFactory($scope, mockingService, getNode) {
      function addBaseUri() {
        function setLine(lineNumber, line, prefix) {
          $scope.editor.setLine(lineNumber, (prefix || '') + $scope.editor.getLine(lineNumber) + '\n' + line);
        }
        var baseUri = 'baseUri: ' + $scope.mock.baseUri;
        var node = getNode($scope.editor, 0);
        // try to find `baseUri` line
        while (node) {
          if (node.getKey() === 'baseUri') {
            setLine(node.lineNumber, baseUri, '#');
            return;
          }
          node = node.getNextSibling();
        }
        // try to find `---` line
        for (var i = 0; $scope.editor.getLine(i); i++) {
          if ($scope.editor.getLine(i).trim() === '---') {
            setLine(i, baseUri);
            return;
          }
        }
        // place it right after RAML version tag
        setLine(0, baseUri);
      }
      function removeBaseUri() {
        var baseUriLine = 'baseUri: ' + $scope.mock.baseUri;
        var lineNumber = void 0;
        var line = void 0;
        // trying to find mocked baseUri
        // and remove it
        for (lineNumber = 0; lineNumber < $scope.editor.lineCount(); lineNumber++) {
          line = $scope.editor.getLine(lineNumber).trim();
          if (line === baseUriLine) {
            $scope.editor.removeLine(lineNumber);
            break;
          }
        }
        // trying to find previous commented out baseUri
        // and uncomment it
        for (lineNumber = Math.min(lineNumber, $scope.editor.lineCount() - 1); lineNumber >= 0; lineNumber--) {
          line = $scope.editor.getLine(lineNumber).trim();
          if (line.indexOf('#') === 0 && line.slice(1).trim().indexOf('baseUri: ') === 0) {
            $scope.editor.setLine(lineNumber, line.slice(1).trim());
            break;
          }
        }
      }
      function loading(promise) {
        $scope.loading = true;
        return promise.finally(function onFinally() {
          $scope.loading = false;
        });
      }
      function setMock(mock) {
        $scope.mock = mock;
        $scope.enabled = !!mock;
      }
      function getMock() {
        loading(mockingService.getMock($scope.fileBrowser.selectedFile).then(setMock));
      }
      function createMock() {
        loading(mockingService.createMock($scope.fileBrowser.selectedFile, $scope.fileBrowser.selectedFile.ramlExpanded).then(setMock).then(addBaseUri));
      }
      function updateMock() {
        mockingService.updateMock($scope.fileBrowser.selectedFile, $scope.fileBrowser.selectedFile.ramlExpanded).then(setMock);
        ;
      }
      function deleteMock() {
        loading(mockingService.deleteMock($scope.fileBrowser.selectedFile).then(function () {
          removeBaseUri();
        }).then(setMock));
      }
      $scope.toggleMockingService = function toggleMockingService() {
        if (!$scope.fileBrowser.selectedFile) {
          return;
        }
        if ($scope.enabled) {
          deleteMock();
          return;
        }
        createMock();
      };
      $scope.$watch('fileBrowser.selectedFile', function watch(newValue) {
        if (newValue) {
          getMock();
        } else {
          setMock();
        }
      });
      $scope.$watch('fileBrowser.selectedFile.raml', function watch() {
        if ($scope.enabled) {
          updateMock();
        }
      });
    }
  ]);
  ;
}());
(function () {
  'use strict';
  /**
   * Flex layout splitter
   */
  angular.module('splitter', []).directive('ngSplitter', [
    '$window',
    'config',
    function ($window, config) {
      // Extend angular jqlite with .prev as an opposite to .next
      if (!angular.element.prototype.prev) {
        /**
           * Get the immediately preceding sibling of each element in the set of matched elements.
           */
        angular.element.prototype.prev = function prev() {
          var value;
          if (this.length) {
            value = this[0].previousSibling;
            while (value !== null && value.nodeType !== 1) {
              value = value.previousSibling;
            }
          }
          return angular.isDefined(value) ? angular.element(value) : this;
        };
      }
      function getCollapseTarget(splitter) {
        return splitter.attr('ng-splitter-collapse-target');
      }
      function getMinWidth(splitter) {
        return splitter.attr('ng-splitter-min-width');
      }
      function getCollapseTargetEl(splitter) {
        return splitter[getCollapseTarget(splitter)]();
      }
      function getNonCollapseTargetEl(splitter) {
        return splitter[{
          next: 'prev',
          prev: 'next'
        }[getCollapseTarget(splitter)]]();
      }
      /**
         * Scales the splitter to the requested size, clipping the size based on
         * our constraints and toggling the resize chevron if the size of the
         * next element goes to the minimum value.
         *
         * @param splitter Splitter that was moved
         * @param size Pixels to resize to
         */
      function resizeCollapseTarget(splitter, size) {
        var minWidth = getMinWidth(splitter);
        if (typeof minWidth === 'undefined' || size >= minWidth) {
          getCollapseTargetEl(splitter).css('min-width', Math.max(0, size) + 'px');
        }
        return Math.max(0, size);
      }
      /**
         * @param splitter Splitter that was moved
         * @param sizeAttr 'width' or 'height'
         * @param delta Pixels to resize by
         * @returns New collapse target size after it has been resized
         */
      function performResizeCollapseTarget(splitter, sizeAttr, delta) {
        var collapseTargetEl = getCollapseTargetEl(splitter);
        var collapseTargetElSize = getOffsetSize(collapseTargetEl, sizeAttr);
        var nonCollapseTargetEl = getNonCollapseTargetEl(splitter);
        var nonCollapseTargetElSize = getOffsetSize(nonCollapseTargetEl, sizeAttr);
        var sign = {
            next: 1,
            prev: -1
          }[getCollapseTarget(splitter)];
        // Force delta to be as small as possible to make
        // sure collapse target doesn't over grow if there is
        // no space left
        if (nonCollapseTargetElSize + delta * sign < 0) {
          delta = nonCollapseTargetElSize * sign * -1;
        }
        if (delta) {
          collapseTargetElSize = resizeCollapseTarget(splitter, collapseTargetElSize - delta * sign);
        }
        return collapseTargetElSize;
      }
      /**
         * @param element Element whose offset size we want
         * @param sizeAttr 'width' or 'height'
         * @returns {Number} offset size
         */
      function getOffsetSize(element, sizeAttr) {
        var offsetSizeProperty = 'offset' + sizeAttr[0].toUpperCase() + sizeAttr.slice(1);
        return element[0][offsetSizeProperty];
      }
      //region Splitter config
      /**
         * Loads the splitter size and optionally applies it to the next element
         * after the splitter
         * @param splitter The splitter element. Should have a unique id.
         * @param sizeAttr 'width' or 'height'
         * @returns {Number} The splitter size
         */
      function loadSize(splitter, sizeAttr) {
        //If no size was saved, use the current size;
        return config.get('splitterSize_' + splitter.attr('id')) || saveSize(splitter, sizeAttr);
      }
      /**
         * Saves the splitter size
         * @param splitter The splitter element. Should have a unique id.
         * @param sizeAttr 'width' or 'height'
         * @returns {Number} The size of the splitter
         */
      function saveSize(splitter, sizeAttr) {
        var size = getOffsetSize(getCollapseTargetEl(splitter), sizeAttr);
        config.set('splitterSize_' + splitter.attr('id'), size);
        return size;
      }
      /**
         * Loads whether the splitter was collapsed by the user
         * @param splitter The splitter element. Should have a unique id.
         * @returns {boolean} Whether the splitter was collapsed by the user
         */
      function loadIsCollapsed(splitter) {
        return config.get('splitterCollapsed_' + splitter.attr('id')) === 'true';
      }
      /**
         * Saves whether the splitter is collapsed
         * @param splitter The splitter element. Should have a unique id.
         * @param collapsed Whether the splitter is collapsed
         */
      function saveIsCollapsed(splitter, collapsed) {
        config.set('splitterCollapsed_' + splitter.attr('id'), collapsed);
      }
      /**
         * Toggles the collapse target visibility
         * @param splitter The splitter that owns the chevron
         * @param collapse False means expand collapse target, true
         * means collapse target is shown
         */
      function toggleCollapseTarget(splitter, collapse) {
        collapse = arguments.length > 1 ? collapse : !loadIsCollapsed(splitter);
        splitter.toggleClass('collapsed', collapse);
        getCollapseTargetEl(splitter).toggleClass('hide-display', collapse);
        saveIsCollapsed(splitter, collapse);
      }
      //endregion
      return {
        restrict: 'A',
        link: function (scope, splitter, attrs) {
          var isActive = false;
          var userIsDragging = true;
          var vertical = attrs.ngSplitter === 'vertical';
          var sizeAttr = vertical ? 'width' : 'height';
          var posAttr = vertical ? 'clientX' : 'clientY';
          var lastPos;
          var lastSize = loadSize(splitter, sizeAttr);
          var lastCollapsed = loadIsCollapsed(splitter);
          var parent = splitter.parent();
          // Restore collapse target state (size and collapsed)
          // from last session
          resizeCollapseTarget(splitter, lastSize);
          toggleCollapseTarget(splitter, lastCollapsed);
          // Configure UI events
          splitter.on('mousedown', function onMouseDown(event) {
            // Only respond to left mouse button
            if (event.button !== 0) {
              return;
            }
            lastPos = event[posAttr];
            lastSize = loadSize(splitter, sizeAttr);
            lastCollapsed = loadIsCollapsed(splitter);
            isActive = true;
            parent.addClass('noselect');
          });
          ;
          angular.element($window).on('mousemove', function onMouseMove(event) {
            if (isActive) {
              userIsDragging = true;
              // Scale the collapse target
              var collapsed = performResizeCollapseTarget(splitter, sizeAttr, event[posAttr] - lastPos) === 0;
              // Collapse the target if its size has reached zero
              //
              // We don't want to toggle the state every 1px and for
              // that reason we compare current state with last one
              if (collapsed !== lastCollapsed) {
                toggleCollapseTarget(splitter, collapsed);
              }
              lastPos = event[posAttr];
              lastCollapsed = collapsed;
            }
          }).on('mouseup', function onMouseUp() {
            if (isActive) {
              if (lastCollapsed) {
                // Preserve collapse target's size if it
                // has reached collapsed state during drag & drop operation
                //
                // We do it to make sure collapsed target expands to proper size
                // when users try to expand it in current or next session
                toggleCollapseTarget(splitter, true);
                resizeCollapseTarget(splitter, lastSize);
              } else {
                saveSize(splitter, sizeAttr);
              }
              isActive = false;
              parent.removeClass('noselect');
            }
          });
          ;
          // Wire up the tiny button that handles collapse and expand operations
          splitter.children('.split').on('mousedown', function onClick() {
            userIsDragging = false;
          });
          splitter.children('.split').on('mouseup', function onClick() {
            // Need to make sure that the user is clicking, not dragging:
            if (!userIsDragging) {
              toggleCollapseTarget(splitter);
              userIsDragging = true;
              isActive = false;
            }
          });
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('validate', []).directive('ngValidate', [
    '$parse',
    function ($parse) {
      return {
        require: 'ngModel',
        link: function (scope, element, attrs, ngModelController) {
          var fn = $parse(attrs.ngValidate);
          scope.$watch(attrs.ngModel, function (value) {
            var validity = fn(scope, { $value: value });
            ngModelController.$setValidity('validate', validity);
          });
        }
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('autoFocus', []).directive('ngAutoFocus', [
    '$timeout',
    function ($timeout) {
      return {
        link: function (scope, element, attrs) {
          scope.$watch(attrs.ngAutoFocus, function (value) {
            if (!value) {
              return;
            }
            $timeout(function () {
              element[0].focus();
            });
          });
        }
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('rightClick', []).directive('ngRightClick', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngRightClick);
        element.on('contextmenu', function (e) {
          scope.$apply(function () {
            e.preventDefault();
            fn(scope, { $event: e });
          });
        });
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditor', function () {
    return {
      restrict: 'E',
      scope: {
        mockingServiceDisabled: '=',
        mockingServiceBaseUri: '='
      },
      templateUrl: 'views/raml-editor-main.tmpl.html',
      controller: 'ramlEditorMain'
    };
  });
  ;
}());
(function () {
  'use strict';
  angular.module('dragAndDrop', []).directive('ngDragEnter', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngDragEnter);
        var entered = 0;
        element.on('dragleave', function () {
          entered--;
        });
        element.on('dragenter', function (e) {
          entered++;
          if (entered !== 1) {
            return;
          }
          scope.$apply(function () {
            e.preventDefault();
            fn(scope, { $event: e });
          });
        });
      };
    }
  ]).directive('ngDragLeave', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngDragLeave);
        var entered = 0;
        element.on('dragenter', function () {
          entered++;
        });
        element.on('dragleave', function (e) {
          entered--;
          if (entered !== 0) {
            return;
          }
          scope.$apply(function () {
            e.preventDefault();
            fn(scope, { $event: e });
          });
        });
      };
    }
  ]).directive('ngDrop', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngDrop);
        element.on('dragover', function (e) {
          e.preventDefault();
        });
        element.on('drop', function (e) {
          scope.$apply(function () {
            e.preventDefault();
            e.stopPropagation();
            fn(scope, { $event: e.originalEvent });
          });
        });
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorContextMenu', [
    '$injector',
    '$window',
    'confirmModal',
    'newNameModal',
    'ramlRepository',
    'newFileService',
    'newFolderService',
    'scroll',
    function ramlEditorContextMenu($injector, $window, confirmModal, newNameModal, ramlRepository, newFileService, newFolderService, scroll) {
      function createActions(target) {
        var saveAction = {
            label: 'Save',
            execute: function execute() {
              return ramlRepository.saveFile(target);
            }
          };
        var newFileAction = {
            label: 'New File',
            execute: function execute() {
              return newFileService.prompt(target);
            }
          };
        var newFolderAction = {
            label: 'New Folder',
            execute: function execute() {
              return newFolderService.prompt(target);
            }
          };
        var renameAction = {
            label: 'Rename',
            execute: function execute() {
              var parent = ramlRepository.getParent(target);
              var message = target.isDirectory ? 'Enter a new name for this folder:' : 'Enter a new name for this file:';
              var title = target.isDirectory ? 'Rename a folder' : 'Rename a file';
              var validations = [{
                    message: 'This name is already taken.',
                    validate: function validate(input) {
                      var path = ramlRepository.join(parent.path, input);
                      return !ramlRepository.getByPath(path);
                    }
                  }];
              return newNameModal.open(message, target.name, validations, title).then(function (name) {
                ramlRepository.rename(target, name);
              });
              ;
            }
          };
        var deleteAction = {
            label: 'Delete',
            execute: function execute() {
              var message;
              var title;
              if (target.isDirectory) {
                message = 'Are you sure you want to delete "' + target.name + '" and all its contents?';
                title = 'Delete folder';
              } else {
                message = 'Are you sure you want to delete "' + target.name + '"?';
                title = 'Delete file';
              }
              return confirmModal.open(message, title, {
                closeButtonLabel: 'Delete',
                closeButtonCssClass: 'btn-danger'
              }).then(function () {
                return ramlRepository.remove(target);
              });
              ;
            }
          };
        if (target.isDirectory) {
          return [
            newFileAction,
            newFolderAction,
            renameAction,
            deleteAction
          ];
        }
        return [
          saveAction,
          renameAction,
          deleteAction
        ];
      }
      function outOfWindow(el) {
        var rect = el.getBoundingClientRect();
        return !(rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth));
      }
      return {
        restrict: 'E',
        templateUrl: 'views/raml-editor-context-menu.tmpl.html',
        link: function link(scope, element) {
          function positionMenu(element, event) {
            var top = event.pageY;
            var left = event.pageX;
            var menuContainer = angular.element(element[0].children[0]);
            menuContainer.css('top', top + 'px');
            menuContainer.css('left', left + 'px');
            setTimeout(function () {
              if (outOfWindow(menuContainer[0])) {
                menuContainer.css('top', top - menuContainer[0].offsetHeight + 'px');
              }
            }, 0);
          }
          function close() {
            scroll.enable();
            scope.$apply(function () {
              delete contextMenuController.target;
              scope.opened = false;
              $window.removeEventListener('click', close);
              $window.removeEventListener('keydown', closeOnEscape);
            });
          }
          function closeOnEscape(e) {
            if (e.which === 27) {
              e.preventDefault();
              close();
            }
          }
          var contextMenuController = {
              open: function open(event, target) {
                scroll.disable();
                this.target = target;
                scope.actions = createActions(target);
                event.stopPropagation();
                positionMenu(element, event);
                $window.addEventListener('click', close);
                $window.addEventListener('keydown', closeOnEscape);
                scope.opened = true;
              }
            };
          scope.registerContextMenu(contextMenuController);
        },
        scope: true
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorFileBrowser', [
    '$q',
    '$window',
    '$rootScope',
    '$timeout',
    'config',
    'ramlRepository',
    'newNameModal',
    'importService',
    function ($q, $window, $rootScope, $timeout, config, ramlRepository, newNameModal, importService) {
      function Controller($scope) {
        var fileBrowser = this;
        var unwatchSelectedFile = angular.noop;
        var contextMenu = void 0;
        $scope.toggleFolderCollapse = function (node) {
          node.collapsed = !node.collapsed;
        };
        $scope.fileTreeOptions = function () {
          var duplicateName = false;
          return {
            accept: function (sourceNodeScope, destNodesScope, destIndex) {
              var accept;
              var source = sourceNodeScope.$modelValue;
              var dest = destIndex < 0 ? $scope.homeDirectory : destNodesScope.$modelValue[destIndex];
              // if the destination is a file, select its parent directory as destination
              if (!dest.isDirectory) {
                dest = destNodesScope.$nodeScope ? destNodesScope.$nodeScope.$modelValue : $scope.homeDirectory;
              }
              // Check if the destination is a child of the source
              var destIsChild = ramlRepository.getParent(source).path === dest.path || dest.path.slice(0, source.path.length) === source.path;
              duplicateName = dest.children.filter(function (c) {
                return c.name === source.name;
              }).length > 0;
              accept = !duplicateName && !destIsChild;
              if (accept) {
                fileBrowser.cursorState = 'ok';
              } else {
                fileBrowser.cursorState = 'no';
              }
              return accept;
            },
            dropped: function (event) {
              var source = event.source.nodeScope.$modelValue;
              var dest = event.dest.nodesScope.$nodeScope ? event.dest.nodesScope.$nodeScope.$modelValue : $scope.homeDirectory;
              // do the actual moving
              ramlRepository.move(source, dest).then(function () {
                return fileBrowser.select(source);
              });
            },
            dragStop: function (event) {
              // when drag is stopped or canceled, reset the cursor
              fileBrowser.cursorState = '';
              if (!event.canceled && duplicateName) {
                $rootScope.$broadcast('event:notification', {
                  message: 'Failed: duplicate file name found in the destination folder.',
                  expires: true,
                  level: 'error'
                });
              }
            }
          };
        }();
        fileBrowser.select = function select(target) {
          if (target.isDirectory) {
            return fileBrowser.selectDirectory(target);
          }
          return fileBrowser.selectFile(target);
        };
        $scope.$on('event:raml-editor-file-select', function (event, filePath) {
          var file = ramlRepository.getByPath(filePath);
          fileBrowser.selectFile(file);
        });
        fileBrowser.selectFile = function selectFile(file) {
          // If we select a file that is already active, just modify 'currentTarget', no load needed
          if (fileBrowser.selectedFile && fileBrowser.selectedFile.$$hashKey === file.$$hashKey) {
            fileBrowser.currentTarget = file;
            return;
          }
          unwatchSelectedFile();
          var isLoaded = file.loaded || !file.persisted;
          var afterLoading = isLoaded ? $q.when(file) : ramlRepository.loadFile(file);
          afterLoading.then(function (file) {
            fileBrowser.selectedFile = fileBrowser.currentTarget = file;
            $scope.$emit('event:raml-editor-file-selected', file);
            unwatchSelectedFile = $scope.$watch('fileBrowser.selectedFile.contents', function (newContents, oldContents) {
              if (newContents !== oldContents) {
                file.dirty = true;
              }
            });
          });
        };
        fileBrowser.selectDirectory = function selectDirectory(directory) {
          $scope.$emit('event:raml-editor-directory-selected', directory);
        };
        /**
         * This function is used for expanding all the ancestors of a target
         * node in the file tree.
         *
         * @param target {RamlDirectory/RamlFile}
         */
        function expandAncestors(target) {
          // stop at the top-level directory
          if (target.path === '/') {
            return;
          }
          var parent = ramlRepository.getParent(target);
          parent.collapsed = false;
          expandAncestors(parent);
        }
        fileBrowser.saveFile = function saveFile(file) {
          ramlRepository.saveFile(file).then(function () {
            return $rootScope.$broadcast('event:notification', {
              message: 'File saved.',
              expires: true
            });
          });
          ;
        };
        fileBrowser.dropFile = function dropFile(event, directory) {
          return importService.importFromEvent(directory, event).then(function () {
            directory.collapsed = false;
          }).catch(function (err) {
            $rootScope.$broadcast('event:notification', {
              message: err.message,
              expires: true,
              level: 'error'
            });
          });
        };
        fileBrowser.showContextMenu = function showContextMenu(event, target) {
          contextMenu.open(event, target);
        };
        fileBrowser.contextMenuOpenedFor = function contextMenuOpenedFor(target) {
          return contextMenu && contextMenu.target === target;
        };
        function saveListener(e) {
          if (e.which === 83 && (e.metaKey || e.ctrlKey) && !(e.shiftKey || e.altKey)) {
            e.preventDefault();
            $scope.$apply(function () {
              fileBrowser.saveFile(fileBrowser.selectedFile);
            });
          }
        }
        $window.addEventListener('keydown', saveListener);
        $scope.fileBrowser = fileBrowser;
        $scope.registerContextMenu = function registerContextMenu(cm) {
          contextMenu = cm;
        };
        $scope.$on('event:raml-editor-file-generated', function (event, file) {
          fileBrowser.selectFile(file);
        });
        $scope.$on('event:raml-editor-directory-created', function (event, dir) {
          fileBrowser.selectDirectory(dir);
        });
        $scope.$on('event:raml-editor-file-selected', function (event, file) {
          expandAncestors(file);
        });
        $scope.$on('event:raml-editor-directory-selected', function (event, dir) {
          expandAncestors(dir);
        });
        $scope.$on('event:raml-editor-filetree-modified', function (event, target) {
          var parent = ramlRepository.getParent(target);
          parent.sortChildren();
        });
        $scope.$on('event:raml-editor-file-removed', function (event, file) {
          $timeout(function () {
            var files = $scope.homeDirectory.getFiles();
            if (files.length === 0) {
              promptWhenFileListIsEmpty();
            } else if (file === fileBrowser.selectedFile) {
              fileBrowser.selectFile(files[0]);
            }
          });
        });
        $scope.$on('$destroy', function () {
          $window.removeEventListener('keydown', saveListener);
        });
        // watch for selected file path changes, update config if needed
        $scope.$watch('fileBrowser.selectedFile.path', function (newPath, oldPath) {
          if (newPath !== oldPath) {
            config.set('currentFile', JSON.stringify({
              path: newPath,
              name: newPath.slice(newPath.lastIndexOf('/') + 1)
            }));
          }
        });
        function promptWhenFileListIsEmpty() {
          var defaultName = 'Untitled-1.raml';
          var message = 'File system has no files, please input a name for the new file:';
          var validation = [];
          var title = 'Add a new file';
          newNameModal.open(message, defaultName, validation, title).then(function (result) {
            return ramlRepository.generateFile($scope.homeDirectory, result);
          }, function () {
            return ramlRepository.generateFile($scope.homeDirectory, defaultName);
          });
        }
        /**
         * Finds a root file which should have `root` property set to `true`
         * starting at root directory and going down through hierarchy using DFS
         * and current position pointer instead of `shift` operation which is
         * expensive. If there are multiple root files, which should not happen,
         * it returns the very first one and stops the search.
         *
         * @param rootDirectory {RamlDirectory} A root directory to start search at
         *
         * @returns {RamlFile} A root file which is a file with `root` property set to `true`
         */
        function findRootFile(rootDirectory) {
          var queue = [rootDirectory];
          var pos = 0;
          while (pos < queue.length) {
            var directory = queue[pos];
            var files = directory.children;
            var entity = void 0;
            for (var i = 0; i < files.length; i++) {
              entity = files[i];
              if (entity.type === 'file' && entity.root) {
                return entity;
              }
              if (entity.type === 'directory') {
                queue.push(entity);
              }
            }
            pos += 1;
          }
        }
        ramlRepository.loadDirectory().then(function (directory) {
          $scope.homeDirectory = directory;
          fileBrowser.rootFile = findRootFile(directory);
          var files = [];
          $scope.homeDirectory.forEachChildDo(function (child) {
            if (!child.isDirectory) {
              files.push(child);
            }
          });
          if (!files.length) {
            promptWhenFileListIsEmpty();
            return;
          }
          // select a file in the following order:
          //   - previously selected file
          //   - root file
          //   - first file
          var currentFile = JSON.parse(config.get('currentFile', '{}'));
          var fileToOpen = ramlRepository.getByPath(currentFile.path) || fileBrowser.rootFile || files[0];
          fileBrowser.selectFile(fileToOpen);
        });
        ;
      }
      return {
        restrict: 'E',
        templateUrl: 'views/raml-editor-file-browser.tmpl.html',
        controller: Controller
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorSaveFileButton', [
    '$rootScope',
    'ramlRepository',
    '$window',
    '$timeout',
    '$q',
    'subMenuService',
    function ramlEditorSaveFileButton($rootScope, ramlRepository, $window, $timeout, $q, subMenuService) {
      return {
        restrict: 'E',
        template: [
          '<span role="save-button" ng-click="saveFile()"><i class="fa fa-save"></i>&nbsp;Save</span>',
          '<span class="menu-item-toggle" ng-click="openContextMenu($event)">',
          '  <i class="fa fa-caret-down"></i>',
          '</span>',
          '<ul role="context-menu" class="menu-item-context" ng-show="contextMenuOpen">',
          '  <li role="context-menu-item" ng-click="saveAllFiles()">Save All</li>',
          '</ul>'
        ].join('\n'),
        link: function (scope) {
          scope.openContextMenu = function () {
            subMenuService.open(scope, 'contextMenuOpen');
          };
          scope.saveFile = function saveFile() {
            var file = scope.fileBrowser.selectedFile;
            return ramlRepository.saveFile(file).then(function success() {
              $rootScope.$broadcast('event:notification', {
                message: 'File saved.',
                expires: true
              });
            });
          };
          scope.saveAllFiles = function saveAllFiles() {
            var promises = [];
            scope.homeDirectory.forEachChildDo(function (file) {
              if (file.isDirectory) {
                return;
              }
              if (file.dirty) {
                return promises.push(ramlRepository.saveFile(file));
              }
            });
            return $q.all(promises).then(function success() {
              $rootScope.$broadcast('event:notification', {
                message: 'All files saved.',
                expires: true
              });
            });
          };
          scope.$on('event:save-all', function () {
            scope.saveAllFiles();
          });
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorNewFolderButton', [
    'newFolderService',
    function ramlEditorNewFolderButton(newFolderService) {
      return {
        restrict: 'E',
        template: '<span role="new-button" ng-click="newFolder()"><i class="fa fa-folder-open"></i>&nbsp;New Folder</span>',
        link: function (scope) {
          scope.newFolder = function newFolder() {
            return newFolderService.prompt(scope.homeDirectory);
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorNewFileButton', [
    'newFileService',
    function ramlEditorNewFileButton(newFileService) {
      return {
        restrict: 'E',
        template: '<span role="new-button" ng-click="newFile()"><i class="fa fa-plus"></i>&nbsp;New File</span>',
        link: function (scope) {
          scope.newFile = function newFile() {
            return newFileService.prompt(scope.homeDirectory);
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorExportFilesButton', [
    '$rootScope',
    'ramlRepository',
    function ramlEditorExportFilesButton($rootScope, ramlRepository) {
      return {
        restrict: 'E',
        template: '<span role="export-button" ng-click="exportFiles()"><i class="fa fa-download"></i>&nbsp;Export files</span>',
        link: function (scope) {
          scope.exportFiles = function exportFiles() {
            ramlRepository.exportFiles();
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorImportButton', [
    '$injector',
    'importModal',
    function ramlEditorImportButton($injector, importModal) {
      return {
        restrict: 'E',
        template: '<span role="new-button" ng-click="importFile()"><i class="fa fa-cloud-download"></i> Import</span>',
        link: function (scope) {
          scope.importFile = function importFile() {
            return importModal.open();
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorHelpButton', [
    '$modal',
    '$timeout',
    '$window',
    'subMenuService',
    function ramlEditorHelpButton($modal, $timeout, $window, subMenuService) {
      return {
        restrict: 'E',
        templateUrl: 'views/menu/help-menu.tmpl.html',
        link: function (scope) {
          scope.openHelpContextMenu = function () {
            subMenuService.open(scope, 'menuContextHelpOpen');
          };
          scope.openHelpModal = function openHelpModal() {
            $modal.open({ templateUrl: 'views/modal/help.html' });
          };
        }
      };
    }
  ]);
}());
/**
 * This file overwrites the ui-tree-node directive from the angular-ui-tree
 * module to modify the behaviour of tree drag-and-drop to better suit the use case
 * of file trees
 */
(function () {
  'use strict';
  angular.module('ui.tree').directive('uiTreeNode', [
    'treeConfig',
    '$uiTreeHelper',
    '$window',
    '$document',
    '$timeout',
    'ramlRepository',
    'config',
    function (treeConfig, $uiTreeHelper, $window, $document, $timeout, ramlRepository, config) {
      return {
        require: [
          '^uiTreeNodes',
          '^uiTree',
          '?uiTreeNode'
        ],
        link: function (scope, element, attrs, controllersArr) {
          var currentConfig = {};
          angular.extend(currentConfig, treeConfig);
          if (currentConfig.nodeClass) {
            element.addClass(currentConfig.nodeClass);
          }
          scope.init(controllersArr);
          scope.collapsed = !!$uiTreeHelper.getNodeAttribute(scope, 'collapsed');
          scope.$watch(attrs.collapsed, function (val) {
            if (typeof val === 'boolean') {
              scope.collapsed = val;
            }
          });
          scope.$watch('collapsed', function (val) {
            $uiTreeHelper.setNodeAttribute(scope, 'collapsed', val);
            attrs.$set('collapsed', val);
          });
          var elements;
          // As a parameter for callbacks
          var firstMoving, dragInfo, pos, dropAccpeted;
          var dragElm, hiddenPlaceElm;
          var hasTouch = 'ontouchstart' in window;
          var dragDelaying = true;
          var dragStarted = false;
          var dragTimer = null;
          var dragCanceled = false;
          var expandTimer = null;
          var expandDelay = 1000;
          // ms
          var body = document.body, html = document.documentElement, documentHeight, documentWidth;
          var dragStart = function (e) {
            if (!hasTouch && (e.button === 2 || e.which === 3)) {
              // disable right click
              return;
            }
            if (e.uiTreeDragging || e.originalEvent && e.originalEvent.uiTreeDragging) {
              // event has already fired in other scope.
              return;
            }
            // the element which is clicked
            var eventElm = angular.element(e.target);
            var eventScope = eventElm.scope();
            if (!eventScope || !eventScope.$type) {
              return;
            }
            if (eventScope.$type !== 'uiTreeNode' && eventScope.$type !== 'uiTreeHandle') {
              // Check if it is a node or a handle
              return;
            }
            if (eventScope.$type === 'uiTreeNode' && eventScope.$handleScope) {
              // If the node has a handle, then it should be clicked by the handle
              return;
            }
            var eventElmTagName = eventElm.prop('tagName').toLowerCase();
            if (eventElmTagName === 'input' || eventElmTagName === 'textarea' || eventElmTagName === 'button' || eventElmTagName === 'select') {
              // if it's a input or button, ignore it
              return;
            }
            // check if it or it's parents has a 'data-nodrag' attribute
            while (eventElm && eventElm[0] && eventElm[0] !== element) {
              if ($uiTreeHelper.nodrag(eventElm)) {
                // if the node mark as `nodrag`, DONOT drag it.
                return;
              }
              eventElm = eventElm.parent();
            }
            if (!scope.beforeDrag(scope)) {
              return;
            }
            e.uiTreeDragging = true;
            // stop event bubbling
            if (e.originalEvent) {
              e.originalEvent.uiTreeDragging = true;
            }
            e.preventDefault();
            var eventObj = $uiTreeHelper.eventObj(e);
            firstMoving = true;
            dragInfo = $uiTreeHelper.dragInfo(scope);
            var tagName = scope.$element.prop('tagName');
            hiddenPlaceElm = angular.element($window.document.createElement(tagName));
            if (currentConfig.hiddenClass) {
              hiddenPlaceElm.addClass(currentConfig.hiddenClass);
            }
            pos = $uiTreeHelper.positionStarted(eventObj, scope.$element);
            dragElm = angular.element($window.document.createElement(scope.$parentNodesScope.$element.prop('tagName'))).addClass(scope.$parentNodesScope.$element.attr('class')).addClass(currentConfig.dragClass).addClass(config.get('theme') === 'light' ? 'drag-light' : '');
            dragElm.css('z-index', 9999);
            scope.$element.after(hiddenPlaceElm);
            dragElm.append(scope.$element.clone().html(scope.$element.children()[0].innerHTML));
            $document.find('body').append(dragElm);
            dragElm.css({
              'left': eventObj.pageX - pos.offsetX + 'px',
              'top': eventObj.pageY - pos.offsetY + 'px'
            });
            elements = { dragging: dragElm };
            scope.$element.addClass('drag-elm');
            // get the node that is being dragged collasp it
            var dragNode = angular.element(dragElm[0].lastChild).scope();
            dragNode.collapsed = true;
            angular.element($document).bind('touchend', dragEndEvent);
            angular.element($document).bind('touchcancel', dragEndEvent);
            angular.element($document).bind('touchmove', dragMoveEvent);
            angular.element($document).bind('mouseup', dragEndEvent);
            angular.element($document).bind('mousemove', dragMoveEvent);
            angular.element($document).bind('mouseleave', dragCancelEvent);
            documentHeight = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
            documentWidth = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
            scope.$treeScope.isDragging = true;
          };
          var dragMove = function (e) {
            if (!dragStarted) {
              if (!dragDelaying) {
                dragStarted = true;
                scope.$apply(function () {
                  scope.$callbacks.dragStart(dragInfo.eventArgs(elements, pos));
                });
              }
              return;
            }
            var eventObj = $uiTreeHelper.eventObj(e);
            var leftElmPos, topElmPos, boundingRect;
            if (dragElm) {
              e.preventDefault();
              if ($window.getSelection) {
                $window.getSelection().removeAllRanges();
              } else if ($window.document.selection) {
                $window.document.selection.empty();
              }
              leftElmPos = eventObj.pageX - pos.offsetX;
              topElmPos = eventObj.pageY - pos.offsetY;
              boundingRect = {
                left: leftElmPos,
                right: leftElmPos + dragElm[0].scrollWidth + 5,
                top: topElmPos,
                bottom: topElmPos + dragElm[0].scrollHeight
              };
              // check horizontal boundaries
              if (boundingRect.left < 0) {
                leftElmPos = 0;
              } else if (boundingRect.right > documentWidth) {
                leftElmPos = documentWidth - dragElm[0].scrollWidth - 5;
              }
              // check vertical boundaries
              if (boundingRect.top < 0) {
                topElmPos = 0;
              } else if (boundingRect.bottom > documentHeight) {
                topElmPos = documentHeight - dragElm[0].scrollHeight;
              }
              dragElm.css({
                'left': leftElmPos + 'px',
                'top': topElmPos + 'px'
              });
              var topScroll = window.pageYOffset || $window.document.documentElement.scrollTop;
              var bottomScroll = topScroll + (window.innerHeight || $window.document.clientHeight || $window.document.clientHeight);
              // to scroll down if cursor y-position is greater than the bottom position the vertical scroll
              if (bottomScroll < eventObj.pageY && bottomScroll <= documentHeight) {
                window.scrollBy(0, 10);
              }
              // to scroll top if cursor y-position is less than the top position the vertical scroll
              if (topScroll > eventObj.pageY) {
                window.scrollBy(0, -10);
              }
              $uiTreeHelper.positionMoved(e, pos, firstMoving);
              if (firstMoving) {
                firstMoving = false;
                return;
              }
              // Select the drag target. Because IE does not support CSS 'pointer-events: none', it will always
              // pick the drag element itself as the target. To prevent this, we hide the drag element while
              // selecting the target.
              var displayElm;
              if (angular.isFunction(dragElm.hide)) {
                dragElm.hide();
              } else {
                displayElm = dragElm[0].style.display;
                dragElm[0].style.display = 'none';
              }
              var targetX = eventObj.pageX - $window.document.body.scrollLeft;
              var targetY = eventObj.pageY - (window.pageYOffset || $window.document.documentElement.scrollTop);
              // when using elementFromPoint() inside an iframe, you have to call
              // elementFromPoint() twice to make sure IE8 returns the correct value
              $window.document.elementFromPoint(targetX, targetY);
              var targetElm = angular.element($window.document.elementFromPoint(targetX, targetY));
              if (angular.isFunction(dragElm.show)) {
                dragElm.show();
              } else {
                dragElm[0].style.display = displayElm;
              }
              var targetNode = targetElm.scope();
              if (!pos.dirAx && targetNode !== scope.prevHoverNode) {
                var isEmpty = false;
                scope.prevHoverNode = targetNode;
                if (!targetNode) {
                  return;
                }
                if (targetNode.$type === 'uiTree' && targetNode.dragEnabled) {
                  isEmpty = targetNode.isEmpty();  // Check if it's empty tree
                }
                if (targetNode.$type === 'uiTreeHandle') {
                  targetNode = targetNode.$nodeScope;
                }
                if (targetNode.$type === 'uiTreeDummyNode') {
                  // Check if it is dropped at the tree root
                  dropAccpeted = targetNode.$parentNodesScope.accept(scope, -1);
                  if (dropAccpeted) {
                    dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.$parentNodesScope.childNodes(), findInsertIndex(scope.$modelValue, targetNode.$parentNodesScope.$modelValue));
                  }
                  $('.dragover').removeClass('dragover');
                  targetElm.addClass('dragover');
                  if (expandTimer) {
                    $timeout.cancel(expandTimer);
                    expandTimer = null;
                  }
                  return;
                }
                if (targetNode.$type !== 'uiTreeNode' && !isEmpty) {
                  // Check if it is a uiTreeNode or it's an empty tree
                  return;
                }
                $timeout.cancel(expandTimer);
                $('.dragover').removeClass('dragover');
                if (targetNode.$childNodesScope) {
                  // It's a folder
                  angular.element(targetNode.$element.children()[0]).addClass('dragover');
                  // Expand the folder automatically if it was originally collapsed
                  if (targetNode.collapsed) {
                    expandTimer = $timeout(function () {
                      targetNode.collapsed = false;
                      scope.nodeToExpand = null;
                    }, expandDelay);
                  }
                  scope.nodeToExpand = targetNode;
                } else if (targetNode.$parentNodeScope) {
                  // It's a file, we modify its parent
                  targetElm.addClass('dragover');
                  angular.element(targetNode.$parentNodeScope.$element.children()[0]).addClass('dragover');
                  scope.nodeToExpand = targetNode.$parentNodeScope;
                } else {
                  // file at root
                  targetElm.addClass('dragover');
                }
                if (isEmpty) {
                  // it's an empty tree
                  if (targetNode.$nodesScope.accept(scope, 0)) {
                    dragInfo.moveTo(targetNode.$nodesScope, targetNode.$nodesScope.childNodes(), 0);
                  }
                } else if (targetNode.dragEnabled()) {
                  // drag enabled
                  targetElm = targetNode.$element;
                  // Get the element of ui-tree-node
                  dropAccpeted = targetNode.$parentNodesScope.accept(scope, targetNode.index());
                  if (dropAccpeted) {
                    if (targetNode.$childNodesScope) {
                      dragInfo.moveTo(targetNode.$childNodesScope, targetNode.childNodes(), findInsertIndex(scope.$modelValue, targetNode.$childNodesScope.$modelValue));
                    } else {
                      dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.$parentNodesScope.childNodes(), findInsertIndex(scope.$modelValue, targetNode.$parentNodesScope.$modelValue));
                    }
                  }
                }
              }
              scope.$apply(function () {
                scope.$callbacks.dragMove(dragInfo.eventArgs(elements, pos));
              });
            }
          };
          var dragEnd = function (e) {
            e.preventDefault();
            if (dragElm) {
              scope.$treeScope.$apply(function () {
                scope.$callbacks.beforeDrop(dragInfo.eventArgs(elements, pos));
              });
              // roll back elements changed
              hiddenPlaceElm.replaceWith(scope.$element);
              dragElm.remove();
              dragElm = null;
              if (scope.$$apply) {
                dragInfo.apply();
                scope.$treeScope.$apply(function () {
                  scope.$callbacks.dropped(dragInfo.eventArgs(elements, pos));
                });
              } else {
                bindDrag();
              }
              scope.$treeScope.$apply(function () {
                var eventArgs = dragInfo.eventArgs(elements, pos);
                eventArgs.canceled = dragCanceled;
                scope.$callbacks.dragStop(eventArgs);
              });
              scope.$$apply = false;
              dragInfo = null;
            }
            angular.element($document).unbind('touchend', dragEndEvent);
            // Mobile
            angular.element($document).unbind('touchcancel', dragEndEvent);
            // Mobile
            angular.element($document).unbind('touchmove', dragMoveEvent);
            // Mobile
            angular.element($document).unbind('mouseup', dragEndEvent);
            angular.element($document).unbind('mousemove', dragMoveEvent);
            angular.element($window.document.body).unbind('mouseleave', dragCancelEvent);
            // reset variables
            $('.dragover').removeClass('dragover');
            scope.$element.removeClass('drag-elm');
            scope.$treeScope.isDragging = false;
            scope.prevHoverNode = null;
            dragCanceled = false;
          };
          // find the index to insert a element into a sorted array
          var findInsertIndex = function (source, dest) {
            var low = 0, high = dest.length - 1, mid;
            while (high >= low) {
              mid = Math.floor((low + high) / 2);
              if (ramlRepository.sortingFunction.call(null, dest[mid], source) > 0) {
                high = mid - 1;
              } else {
                low = mid + 1;
              }
            }
            return low;
          };
          var dragStartEvent = function (e) {
            if (scope.dragEnabled()) {
              dragStart(e);
            }
          };
          var dragMoveEvent = function (e) {
            dragMove(e);
          };
          var dragEndEvent = function (e) {
            scope.$$apply = dropAccpeted;
            dragEnd(e);
          };
          var dragCancelEvent = function (e) {
            scope.$$apply = false;
            dragCanceled = true;
            dragEnd(e);
          };
          var bindDrag = function () {
            $timeout(function () {
              element.unbind();
              element.bind('touchstart mousedown', function (e) {
                dragDelaying = true;
                dragStarted = false;
                dragTimer = $timeout(function () {
                  dragDelaying = false;
                  dragStartEvent(e);
                }, scope.dragDelay);
              });
              element.bind('touchend touchcancel mouseup', function () {
                $timeout.cancel(dragTimer);
              });
            });
          };
          bindDrag();
          angular.element($window.document.body).bind('keydown', function (e) {
            if (e.keyCode === 27) {
              dragCancelEvent(e);
            }
          });
        }
      };
    }
  ]).directive('uiTreeDummyNode', [
    'treeConfig',
    function (treeConfig) {
      return {
        require: [
          '^uiTreeNodes',
          '^uiTree'
        ],
        template: '<div class="file-item dummy" ng-class="{\'no-drop\': fileBrowser.cursorState === \'no\', copy: fileBrowser.cursorState === \'ok\'}"></div>',
        restrict: 'E',
        replace: true,
        controller: function ($scope, $element) {
          this.scope = $scope;
          $scope.$element = $element;
          $scope.$parentNodeScope = null;
          // uiTreeNode Scope of parent node;
          $scope.$childNodesScope = null;
          // uiTreeNodes Scope of child nodes.
          $scope.$parentNodesScope = null;
          // uiTreeNodes Scope of parent nodes.
          $scope.$treeScope = null;
          // uiTree scope
          $scope.$$apply = false;
          $scope.$type = 'uiTreeDummyNode';
          $scope.init = function (controllersArr) {
            var treeNodesCtrl = controllersArr[0];
            $scope.$treeScope = controllersArr[1] ? controllersArr[1].scope : null;
            // find the scope of it's parent node
            $scope.$parentNodeScope = treeNodesCtrl.scope.$nodeScope;
            $scope.$parentNodesScope = treeNodesCtrl.scope;
          };
        },
        link: function (scope, element, attr, controllersArr) {
          var config = {};
          angular.extend(config, treeConfig);
          if (config.nodeClass) {
            element.addClass(config.nodeClass);
          }
          scope.init(controllersArr);
        }
      };
    }
  ]);
}());
angular.module('ramlEditorApp').run([
  '$templateCache',
  function ($templateCache) {
    'use strict';
    $templateCache.put('views/confirm-modal.html', '<form name="form" novalidate>\n' + '  <div class="modal-header">\n' + '    <h3>{{title}}</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body">\n' + '    <p>{{message}}</p>\n' + '  </div>\n' + '\n' + '  <div class="modal-footer">\n' + '    <button type="button" class="btn btn-default" ng-click="$dismiss()">{{dismissButtonLabel}}</button>\n' + '    <button type="button" class="btn btn-default" ng-if="canDiscard" ng-click="discard()">{{discardButtonLabel}}</button>\n' + '    <button type="button" class="btn" ng-class="closeButtonCssClass" ng-click="$close()" ng-auto-focus="true">{{closeButtonLabel}}</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/import-modal.html', '<form name="form" novalidate ng-submit="import(form)">\n' + '  <div class="modal-header">\n' + '    <h3>Import file</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body" ng-class="{\'has-error\': submittedType === mode.type && form.$invalid}">\n' + '    <div style="text-align: center; font-size: 2em; margin-bottom: 1em;" ng-show="importing">\n' + '      <i class="fa fa-spin fa-spinner"></i>\n' + '    </div>\n' + '\n' + '    <div class="form-group" style="margin-bottom: 10px;">\n' + '      <div style="float: left; width: 130px;">\n' + '        <select class="form-control" ng-model="mode" ng-options="option.name for option in options"></select>\n' + '      </div>\n' + '\n' + '      <div style="margin-left: 145px;" ng-switch="mode.type">\n' + '        <input id="swagger" name="swagger" type="text" ng-model="mode.value" class="form-control" required ng-switch-when="swagger" placeholder="http://example.swagger.wordnik.com/api/api-docs">\n' + '\n' + '        <input id="file" name="file" type="file" ng-model="mode.value" class="form-control" required ng-switch-when="file" onchange="angular.element(this).scope().handleFileSelect(this)">\n' + '\n' + '        <input id="zip" name="zip" type="file" ng-model="mode.value" class="form-control" required ng-switch-when="zip" onchange="angular.element(this).scope().handleFileSelect(this)">\n' + '      </div>\n' + '    </div>\n' + '\n' + '    <div ng-if="submittedType === \'swagger\'">\n' + '      <p class="help-block" ng-show="form.swagger.$error.required">Please provide a URL.</p>\n' + '    </div>\n' + '\n' + '    <div ng-if="submittedType === \'file\'">\n' + '      <p class="help-block" ng-show="form.file.$error.required">Please select a file to import.</p>\n' + '    </div>\n' + '\n' + '    <div ng-if="submittedType === \'zip\'">\n' + '      <p class="help-block" ng-show="form.zip.$error.required">Please select a zip to import.</p>\n' + '    </div>\n' + '\n' + '    <div ng-if="mode.type !== \'swagger\'">\n' + '      <p>If you want to upload multiple files, you can .zip them and import them in a single step.</p>\n' + '    </div>\n' + '\n' + '    <div ng-if="mode.type !== \'file\'">\n' + '      <p>Note: Currently supports Swagger v2.0</p>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="modal-footer" style="margin-top: 0;">\n' + '    <button type="button" class="btn btn-default" ng-click="$dismiss()">Close</button>\n' + '    <button type="submit" class="btn btn-primary">Import</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/import-service-conflict-modal.html', '<form name="form" novalidate>\n' + '  <div class="modal-header">\n' + '    <h3>Path already exists</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body">\n' + '    The path (<strong>{{path}}</strong>) already exists.\n' + '  </div>\n' + '\n' + '  <div class="modal-footer">\n' + '    <button type="button" class="btn btn-default pull-left" ng-click="skip()">Skip</button>\n' + '    <button type="submit" class="btn btn-primary" ng-click="keep()">Keep Both</button>\n' + '    <button type="submit" class="btn btn-primary" ng-click="replace()">Replace</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/menu/help-menu.tmpl.html', '<span role="help-button">\n' + '  <i class="fa fa-question-circle"></i>&nbsp;Help\n' + '</span>\n' + '<span class="menu-item-toggle" ng-click="openHelpContextMenu($event)">\n' + '  <i class="fa fa-caret-down"></i>\n' + '</span>\n' + '<ul role="context-menu" class="menu-item-context" ng-show="menuContextHelpOpen">\n' + '  <li role="context-menu-item"><a href="http://raml.org" target="_blank">About RAML</a></li>\n' + '  <li role="context-menu-item"><a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-08/raml-08.md" target="_blank">Language Spec (0.8)</a></li>\n' + '  <li role="context-menu-item"><a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md" target="_blank">Language Spec (1.0)</a></li>\n' + '  <li role="context-menu-item"><a href="http://raml.org/docs.html" target="_blank">Tutorial</a></li>\n' + '  <li role="context-menu-item"><a href="https://github.com/mulesoft/api-designer/issues" target="_blank">Report a Bug</a></li>\n' + '  <hr class="line-with-linear-gradient">\n' + '  <li role="context-menu-item" ng-click="openHelpModal()">About API Designer</li>\n' + '</ul>\n');
    $templateCache.put('views/modal/help.html', '<div class="modal-header">\n' + '    <h3>About</h3>\n' + '</div>\n' + '\n' + '<div class="modal-body">\n' + '    <p>\n' + '        The API Designer for RAML is built by MuleSoft, and is a web-based editor designed to help you author RAML specifications for your APIs.\n' + '        <br />\n' + '        <br />\n' + '        RAML is a human-and-machine readable modeling language for REST APIs, backed by a workgroup of industry leaders.\n' + '    </p>\n' + '\n' + '    <p>\n' + '        To learn more about the RAML specification and other tools which support RAML, please visit <a href="http://www.raml.org" target="_blank">http://www.raml.org</a>.\n' + '        <br />\n' + '        <br />\n' + '        For specific questions, or to get help from the community, head to the community forum at <a href="http://forums.raml.org" target="_blank">http://forums.raml.org</a>.\n' + '    </p>\n' + '</div>\n');
    $templateCache.put('views/new-name-modal.html', '<form name="form" novalidate ng-submit="submit(form)">\n' + '  <div class="modal-header">\n' + '    <h3>{{input.title}}</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body">\n' + '    <!-- name -->\n' + '    <div class="form-group" ng-class="{\'has-error\': form.$submitted && form.name.$invalid}">\n' + '      <p>{{input.message}}</p>\n' + '      <!-- label -->\n' + '      <label for="name" class="control-label required-field-label">Name</label>\n' + '\n' + '      <!-- input -->\n' + '      <input id="name" name="name" type="text"\n' + '             ng-model="input.newName" class="form-control"\n' + '             ng-validate="isValid($value)"\n' + '             ng-maxlength="64" ng-auto-focus="true" required>\n' + '\n' + '      <!-- error -->\n' + '      <p class="help-block" ng-show="form.$submitted && form.name.$error.required">Please provide a name.</p>\n' + '      <p class="help-block" ng-show="form.$submitted && form.name.$error.maxlength">Name must be shorter than 64 characters.</p>\n' + '      <p class="help-block" ng-show="form.$submitted && form.name.$error.validate">{{validationErrorMessage}}</p>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="modal-footer">\n' + '    <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n' + '    <button type="submit" class="btn btn-primary">OK</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/raml-editor-context-menu.tmpl.html', '<ul role="context-menu" ng-show="opened">\n' + '  <li role="context-menu-item" ng-repeat="action in actions" ng-click="action.execute()">{{ action.label }}</li>\n' + '</ul>\n');
    $templateCache.put('views/raml-editor-file-browser.tmpl.html', '<raml-editor-context-menu></raml-editor-context-menu>\n' + '\n' + '<script type="text/ng-template" id="file-item.html">\n' + '  <div ui-tree-handle class="file-item" ng-right-click="fileBrowser.showContextMenu($event, node)" ng-click="fileBrowser.select(node)"\n' + '    ng-class="{currentfile: fileBrowser.currentTarget.path === node.path && !isDragging,\n' + '      dirty: node.dirty,\n' + '      geared: fileBrowser.contextMenuOpenedFor(node),\n' + '      directory: node.isDirectory,\n' + '      \'no-drop\': fileBrowser.cursorState === \'no\',\n' + '      copy: fileBrowser.cursorState === \'ok\'}"\n' + '    ng-drop="node.isDirectory && fileBrowser.dropFile($event, node)">\n' + '    <span class="file-name" ng-click="toggleFolderCollapse(node)">\n' + '      <i class="fa icon fa-caret-right fa-fw" ng-if="node.isDirectory" ng-class="{\'fa-rotate-90\': !collapsed}"></i>\n' + '      <i class="fa icon fa-fw" ng-class="{\'fa-folder-o\': node.isDirectory, \'fa-file-text-o\': !node.isDirectory}"></i>\n' + '      &nbsp;{{node.name}}\n' + '    </span>\n' + '    <i class="fa fa-cog" ng-click="fileBrowser.showContextMenu($event, node)" ng-class="{hidden: isDragging}" data-nodrag></i>\n' + '  </div>\n' + '\n' + '  <ul ui-tree-nodes ng-if="node.isDirectory" ng-class="{hidden: collapsed}" ng-model="node.children">\n' + '    <li ui-tree-node ng-repeat="node in node.children" ng-include="\'file-item.html\'" data-collapsed="node.collapsed">\n' + '    </li>\n' + '  </ul>\n' + '</script>\n' + '\n' + '<div ui-tree="fileTreeOptions" ng-model="homeDirectory" class="file-list" data-drag-delay="300" data-empty-place-holder-enabled="false" ng-drop="fileBrowser.dropFile($event, homeDirectory)" ng-right-click="fileBrowser.showContextMenu($event, homeDirectory)">\n' + '  <ul ui-tree-nodes ng-model="homeDirectory.children" id="tree-root">\n' + '    <ui-tree-dummy-node class="top"></ui-tree-dummy-node>\n' + '    <li ui-tree-node ng-repeat="node in homeDirectory.children" ng-include="\'file-item.html\'" data-collapsed="node.collapsed"\n' + '     ng-drag-enter="node.collapsed = false"\n' + '     ng-drag-leave="node.collapsed = true"></li>\n' + '    <ui-tree-dummy-node class="bottom" ng-click="fileBrowser.select(homeDirectory)"></ui-tree-dummy-node>\n' + '  </ul>\n' + '</div>\n');
    $templateCache.put('views/raml-editor-main.tmpl.html', '<div role="raml-editor" class="{{theme}}">\n' + '  <div role="notifications" ng-controller="notifications" class="hidden" ng-class="{hidden: !shouldDisplayNotifications, error: level === \'error\'}">\n' + '    {{message}}\n' + '    <i class="fa" ng-class="{\'fa-check\': level === \'info\', \'fa-warning\': level === \'error\'}" ng-click="hideNotifications()"></i>\n' + '  </div>\n' + '\n' + '  <header>\n' + '    <h1>\n' + '      <strong>API</strong> Designer\n' + '    </h1>\n' + '\n' + '    <a role="logo" target="_blank" href="http://mulesoft.com"></a>\n' + '  </header>\n' + '\n' + '  <ul class="menubar">\n' + '    <li class="menu-item menu-item-ll">\n' + '      <raml-editor-new-file-button></raml-editor-new-file-button>\n' + '    </li>\n' + '    <li ng-show="supportsFolders" class="menu-item menu-item-ll">\n' + '      <raml-editor-new-folder-button></raml-editor-new-folder-button>\n' + '    </li>\n' + '    <li class="menu-item menu-item-ll">\n' + '      <raml-editor-save-file-button></raml-editor-save-file-button>\n' + '    </li>\n' + '    <li class="menu-item menu-item-ll">\n' + '      <raml-editor-import-button></raml-editor-import-button>\n' + '    </li>\n' + '    <li ng-show="canExportFiles()" class="menu-item menu-item-ll">\n' + '      <raml-editor-export-files-button></raml-editor-export-files-button>\n' + '    </li>\n' + '    <li class="menu-item menu-item-ll">\n' + '      <raml-editor-help-button></raml-editor-help-button>\n' + '    </li>\n' + '    <li class="spacer file-absolute-path">{{getSelectedFileAbsolutePath()}}</li>\n' + '    <li class="menu-item menu-item-fr menu-item-mocking-service" ng-show="getIsMockingServiceVisible()" ng-controller="mockingServiceController" ng-click="toggleMockingService()">\n' + '      <div class="title">Mocking Service</div>\n' + '      <div class="field-wrapper" ng-class="{loading: loading}">\n' + '        <i class="fa fa-spin fa-spinner" ng-if="loading"></i>\n' + '        <div class="field" ng-if="!loading">\n' + '          <input type="checkbox" value="None" id="mockingServiceEnabled" ng-checked="enabled" ng-click="$event.preventDefault()" />\n' + '          <label for="mockingServiceEnabled"></label>\n' + '        </div>\n' + '      </div>\n' + '    </li>\n' + '  </ul>\n' + '\n' + '  <div role="flexColumns">\n' + '    <raml-editor-file-browser role="browser"></raml-editor-file-browser>\n' + '\n' + '    <div id="browserAndEditor" ng-splitter="vertical" ng-splitter-collapse-target="prev"><div class="split split-left">&nbsp;</div></div>\n' + '\n' + '    <div role="editor" ng-class="{error: currentError}">\n' + '      <div id="code" role="code"></div>\n' + '\n' + '      <div role="shelf" ng-show="getIsShelfVisible()" ng-class="{expanded: !shelf.collapsed}">\n' + '        <div role="shelf-tab" ng-click="toggleShelf()">\n' + '          <i class="fa fa-inbox fa-lg"></i><i class="fa" ng-class="shelf.collapsed ? \'fa-caret-up\' : \'fa-caret-down\'"></i>\n' + '        </div>\n' + '\n' + '        <div role="shelf-container" ng-show="!shelf.collapsed" ng-include src="\'views/raml-editor-shelf.tmpl.html\'"></div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '    <div id="consoleAndEditor" ng-show="getIsConsoleVisible()" ng-splitter="vertical" ng-splitter-collapse-target="next" ng-splitter-min-width="470"><div class="split split-right">&nbsp;</div></div>\n' + '\n' + '    <div ng-show="getIsConsoleVisible()" role="preview-wrapper" class="raml-console-embedded">\n' + '      <raml-console\n' + '        raml="raml"\n' + '        options="{\n' + '          singleView: true,\n' + '          disableThemeSwitcher: true,\n' + '          disableRamlClientGenerator: true,\n' + '          disableTitle: true\n' + '        }"\n' + '        style="padding: 0; margin-top: 0;"></raml-console>\n' + '    </div>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('views/raml-editor-shelf.tmpl.html', '<ul role="sections" ng-controller="ramlEditorShelf">\n' + '  <li role="section" ng-repeat="category in model.categories | orderBy:orderSections" class="{{category.name | dasherize}}">\n' + '    {{category.name}}&nbsp;({{category.items.length}})\n' + '    <ul role="items">\n' + '      <li ng-repeat="item in category.items" ng-click="itemClick(item)"><i class="fa fa-reply"></i><span>{{item.title}}</span></li>\n' + '    </ul>\n' + '  </li>\n' + '</ul>\n');
  }
]);